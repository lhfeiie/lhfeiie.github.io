<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"flipXIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第一章 基础算法排序快速排序">
<meta property="og:type" content="article">
<meta property="og:title" content="算法基础课">
<meta property="og:url" content="http://example.com/2023/02/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/index.html">
<meta property="og:site_name" content="Lee&#39;s Blog">
<meta property="og:description" content="第一章 基础算法排序快速排序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.3dxceqg1vy20.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E4%B8%80.4vb9hmjtfns0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E4%BA%8C.fvi1ths0saw.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.57h4seis2sc0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F.3k7f1su09xy0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86.2t6ea7gq62e0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%B8%80.2hjmnn6u8cs0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%BA%8C.3o7gy9ypz9q0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97%E8%8C%83%E5%9B%B4.6ku0ipk963w0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.al9ojtpkbs8.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B.6u3evz6drks0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F.5mk2accbqks0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9B%BE%E8%A7%A3.51vvew6d9rg0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/Trie%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.55lvr89ejrg0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/Trie%E6%A0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%87%E8%AE%B0.406xugkf9360.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%A0%86%E5%9B%BE%E8%A7%A3.10htkpyc4af4.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3.5bvyeatn0k00.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8B%89%E9%93%BE%E6%B3%95%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E6%96%B9%E5%BC%8F.35nzeivguik0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F.7bxlg7916qw0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC.5s1vlkzittc0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/DFS%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.es7pqrwojuw.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/BFS%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.o5jvdhxxxa8.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.1lzgbf605hts.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6%E4%B8%8E%E5%87%BA%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5.ph0f34a1tq8.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D.33xr5ga43h80.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/bellman-ford%E7%AE%97%E6%B3%95%E8%B4%9F%E6%9D%83%E5%9B%9E%E8%B7%AF.3o3c2ryta120.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/bellman-ford%E7%AE%97%E6%B3%95%E5%8A%A0%E5%A4%87%E4%BB%BD%E4%B8%BE%E4%BE%8B.3nlt4b99b2g0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84.2hcxmaye6fg0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E6%9E%84.62fxxjuia9c0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E5%85%AC%E5%BC%8F.4hfk4a36lyg0.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%9F%A6%E6%81%A9%E5%9B%BE.yhuedj9l2uo.webp">
<meta property="og:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/DP.683rgx39pv00.webp">
<meta property="article:published_time" content="2023-02-15T06:19:07.000Z">
<meta property="article:modified_time" content="2023-02-16T11:09:58.106Z">
<meta property="article:author" content="Lee">
<meta property="article:tag" content="导航">
<meta property="article:tag" content="分享">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.3dxceqg1vy20.webp">

<link rel="canonical" href="http://example.com/2023/02/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法基础课 | Lee's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lee's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Dreams will be true!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/02/15/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202106%2F13%2F20210613235426_7a793.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1678977005&t=93fbeaf5703aa746a965441eda08d9d0">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="欢迎来到我的个人网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lee's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法基础课
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-15 14:19:07" itemprop="dateCreated datePublished" datetime="2023-02-15T14:19:07+08:00">2023-02-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-16 19:09:58" itemprop="dateModified" datetime="2023-02-16T19:09:58+08:00">2023-02-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>54k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>49 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>流程：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.3dxceqg1vy20.webp" alt="快速排序流程"></p>
<p>调整区间做法一（暴力做法）：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E4%B8%80.4vb9hmjtfns0.webp" alt="调整区间一"></p>
<p>建立两个数组a，b分别存储将要排序的数组q。随机取一个x，在q中遍历，小于等于x的值存放在a中，大于x的值存放在b中，然后更新数组q（将a，b两数组的元素存在q中，a在左，b在右）。</p>
<p>调整区间做法二（双指针做法）：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E4%BA%8C.fvi1ths0saw.webp" alt="调整区间二"></p>
<p>在数组中定义两个指针i，j分别指向数组的最左边和最右边，i先开始遍历，当i指向的元素小于x，指针i继续往后遍历，直至遇到大于等于x的元素停下来，接下来遍历指针j，与i的遍历方式相反，遇到小于等于x的元素停下来，然后用swap函数将两个指针指向的元素交换，接下来继续上述操作，直到i和j相遇结束循环，排序成功。</p>
<p><strong>快速排序模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//进行递归遍历后，最终为一个元素为一个数组，此时l = r,所以停止递归</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//先将i和j指向空</span></span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//&gt;&gt;为位运算，表示二进制右移一位，等价于/2</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//每当i和j相遇后就会出现分界，调用递归函数进行下一步的遍历交换，此为左半部分</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//同理，此为右半部分,当以此为分界时，x的值还可以取q[l]</span></span><br><span class="line">    <span class="comment">//quick_sort(q, l, i - 1);//也可以用i来表示，但x的值为q[l + r + 1 &gt;&gt; 1]或q[r],防止进入死循环</span></span><br><span class="line">    <span class="comment">//quick_sort(q, i, r);</span></span><br><span class="line">&#125;<span class="comment">//面试考点</span></span><br></pre></td></tr></table></figure>

<p><strong>在上述模板中，如果x取值为q[l + r &gt;&gt; 1]或q[l]，那么递归方式为<code>quick_sort(q, l, j); quick_sort(q, j + 1, r);</code>，如果x取值为q[l + r + 1 &gt;&gt; 1]或q[r]，那么递归方式为<code>quick_sort(q, l, i - 1); quick_sort(q, i, r);</code>。</strong></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.57h4seis2sc0.webp" alt="归并排序流程"></p>
<p>与快速排序不同的是，归并排序的分界点是数组的中间值，而快排的分界点是数组中随机的一个点（也可以是中间值）。分界点的作用是将一个数组分为两个数组。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F.3k7f1su09xy0.webp" alt="归并排序方式"></p>
<p>两个指针分别指向两个数组的最小元素（每一个元素都是从小到大排好序的），比较两个指针所指向的元素的大小，把最小的一个元素存入res数组中，然后指向该最小元素的指针向后移动一位继续比较，以此类推，直至有一个指针指向其数组的最终位置，最后将指针未指向终点的数组的剩余元素补进res数组中。</p>
<p>归并排序模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//当数组中的元素为一个时，递归结束</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);<span class="comment">//与快排的递归思想一致，但是这里是将数组递归分为若干个数组，直到一个元素为一个数组为止，执行递归函数下面的语句</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<span class="comment">//当左半边没有循环完，把剩余部分补进tmp数组中</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<span class="comment">//同理，但此为右半边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<span class="comment">//复制回q数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>单调性与二分的关系：有单调性一定可以二分，可以二分的题目不一定非得有单调性。</p>
<p>二分的本质并不是单调性。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86.2t6ea7gq62e0.webp" alt="二分"></p>
<p>给定一个区间，定义某一种性质，使得区间的右半部分满足该性质，左半部分不满足，整个区间被一分为二，两个部分的边界不相交。二分就可以寻找该性质的边界，既可以寻找图中绿颜色的边界，也可以寻找红颜色的边界，此为二分的性质，二分有两个模板。</p>
<p>模板一：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%B8%80.2hjmnn6u8cs0.webp" alt="二分模板一"></p>
<p>在二分出红色点的情况下，在[l, r]区间确定中间值，判断该中间值是否满足红色区间的性质，若满足，则中间值mid在红色区间内，此时区间[mid, r]是可以取到边界点的，因此在该区间答案是存在的，接下来更新区间为[mid, r]（mid在红色区间内，因为要二分红色区间，所以mid有可能是答案，因此区间要包含mid）。若不满足，则mid在绿色区间内，此时答案一定在区间[l, mid -1],因此更新区间为[l, mid - 1]（因为mid本就不在红色区间内，所以mid本身就不用考虑）。<strong>最终得到的结果为右边界。</strong></p>
<p>模板二：   </p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%BA%8C.3o7gy9ypz9q0.webp" alt="二分模板二"></p>
<p>与模板一相反，此时二分出绿色点。<strong>最终得到的结果为左边界。</strong></p>
<p><strong>$mid&#x3D;\frac{l+r}{2}$与$mid&#x3D;\frac{l+r+1}{2}$的判断方式：</strong></p>
<p>​	<strong>如果$r &#x3D; mid -1 \quad l &#x3D; mid$时，$mid&#x3D;\frac{l+r+1}{2}$，如果$r &#x3D; mid \quad l &#x3D; mid + 1$时，$mid&#x3D;\frac{l+r}{2}$。红向上(右)取（mid取 $r$，所以 $l + r + 1$），绿向下（左）取（mid取 $l$，所以 $l + r$）。（当 $r$ 与 $l$ 相差为1时更好理解($r - l &#x3D; 1$)，如果不加1，$l$ 更新始终为 $l$，得到的新的区间始终为[l , r], 此时会进入死循环,如果加1，$l$ 会更新为 $r$,此时更新的区间为[r , r],因为左右区间相等，所以停止循环）</strong></p>
<p>整数二分模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)<span class="comment">//l和r在该循环中会时刻更新，因此当l大于等于r时作为循环终止条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;<span class="comment">//可以这样理解，这里的mid + 1相当于对l已经做了上取整操作，所以mid的值不需要再加1(mid = l + r &gt;&gt; 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;<span class="comment">//此模板找到左边界</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;<span class="comment">//这里的l没有做上取整操作，因此在取mid的值时需要加1上取整(mid = l + r + 1 &gt;&gt; 1)</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;<span class="comment">//此模板找到右边界</span></span><br></pre></td></tr></table></figure>

<p>二分算法用于解决查找问题。</p>
<p>当mid满足存在于左半边时，最终二分出的结果为右边界，反之得到的结果为左边界。（<strong>分左得右，分右得左</strong>）</p>
<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>浮点数二分不需要处理边界，因此不需要考虑 $l + r$ 要不要加1，并且此模板只有一个。</p>
<p>浮点数二分模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)<span class="comment">//当精度特别小的时候就可以停止循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模板一般用于求浮点数的平方根，也属于查找问题。</p>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>高精度常用于C++语言。</p>
<p><strong>高精度一般用于两个超过C++最长整数范围的加减乘除计算。加减法用于两个大整数之间的运算，乘除法一般用于一个大整数与一个小整数之间的运算，也会出现两个超大整数之间的运算，但用的次数不是很多。</strong></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97%E8%8C%83%E5%9B%B4.6ku0ipk963w0.webp" alt="高精度运算范围"></p>
<p>存取大整数的方法是将每一位存入一个数组当中， 从数组开头开始，将整数从个位开始依次存入，数组末尾元素是整数的最高位。</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>高精度加法模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><span class="comment">//返回值类型为vector数组类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>在高精度减法中，要考虑A和B谁比谁大，如果A &gt; B，则直接计算结果，如果A &lt; B，则要将AB颠倒过来计算，之后再输出的结果前加负号即可。判断AB的大小需要自己定义函数去判断。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )<span class="comment">//这里是保证A &gt; B，因此只需要遍历到两个数中长度最长的长度，也就是A.size()，t为借位</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;<span class="comment">//减去上一位是否借位的情况，如果有借位，减去的t是1，如果没有借位，减去的t是0</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//这里包含了两种情况，如果t大于等于0，那么t加10余10就是t本身(t永远都是个位数，只不过会出现正负数两种情况，这里(t + 10) % 10既处理了负数的情况，还能解决正数加10的情况)，此时t就是A[i] - B[i]的结果，如果t小于0，那么就说明要向上一位借位，因此要加10，t + 10就是借位后得到的结果，再余10也还是t + 10本身</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">//如果t小于0，则说明向高一位借位，在下一循环中计算的是高位的减法，由于当前循环中t小于0，因此当前循环的减法向高位借1，所以在下一循环的高位减法中要减去当前循环借的1位，所以t要赋值为1</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;<span class="comment">//t大于等于0，没有借位，因此t为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) 			C.<span class="built_in">pop_back</span>();<span class="comment">//如果A - B得到的是个位数，由于结果输出是在数组中倒着输出，因此高位的0会一起输出，所以要把高位等于0的元素pop出去，以确保输出的是个位数</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><p>在高精度乘法中，A是高精度，b是低精度（高精度乘高精度不常考），因此在实现该算法时A中的每一位要乘b的整体，然后计算进位，并不是每一位乘每一位，与我们人类的计算方式是不同的，由于b是低精度，因此b不需要进行字符串转换整型数组，直接将b存入整型变量中即可，这样也更方便实现A中的每一位数乘b的整体。</p>
<p>高精度乘低精度模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )<span class="comment">//从个位开始遍历，当A的长度遍历完之后，有可能会出现进位，因此还要判断超过A的长度之后，t是否为0，若不为0，则向A的最大长度后进位，也就是将t的值放入后一位数组位置中，若为0，则说明不需要进位，因此退出循环得出结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);<span class="comment">//1</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//2</span></span><br><span class="line">    &#125;<span class="comment">//1和2的代码与高精度加法相同，当t为个位数时，除以10为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//可有可无，但为了保险最好加上，有可能会出现多位数0相乘的情况，此时得到的结果只需输出一位0即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><p>与乘法一样，高精度除以高精度不常考，因此这里只需要考虑高精度除以低精度。</p>
<p>高精度除以低精度模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span><span class="comment">//在高精度除法中，还要返回余数r，因此r在函数参数中定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//除法是从最高位开始运算，与其他三种运算方式的起始位置是不同的，因此从高位开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];<span class="comment">//r是上一位除法计算得到的余数，因此在当前循环中r就是遍历到当前数的上一位，因此要乘10让r成为十位数再加上当前数</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);<span class="comment">//然后再将除数放入数组当中，商是b，因为A与b做除法</span></span><br><span class="line">        r %= b;<span class="comment">//保存当前位的余数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());<span class="comment">//除法中得到的结果C数组中数组首元素存放的是最高位，末尾元素存放的是第一位，为了与其他加减乘的存入方式统一，这里要将数组C反转，以便主函数能够正确输出结果，也方便下一语句代码判断末尾元素是否为0（在反转之前第一位存放的有可能是0，因此反转之后就成为了末尾元素）</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>给定长度为n的数组$a_1,a_2,a_3,…,a_n$，前缀和则表示为$S_i &#x3D; a_1 + a_2 + … + a_i$。前缀和下标一定要从1开始，这样例如当求区间[1, 10]之间的和时，只需求$S_{10} - S_0$即可($S_0 &#x3D; 0$)。前缀和相当于高中的数列求和。（$S_i &#x3D; S_{i - 1} + a_i$）</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维前缀和</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><code>ios::sync_with_stdio(false);</code>可以提高cin的读取速度，但不能使用scanf读入。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.al9ojtpkbs8.webp" alt="二维前缀和"></p>
<p>二维前缀和中，如上图所示，$a_{ij}$表示中间的一点，$S_{ij}$表示图中阴影部分所有元素的和，也就是左上角所有元素的和。</p>
<p>如上图所示，要求出图中最小的正方形区域内的和，设小正方形左上角的坐标为($x_1$, $y_1$),右下角坐标为($x_2$, $y_2$)，那么小正方形区域内的和为：$S_{x_2y_2} - S_{x_2(y_1 - 1)} - S_{(x_1-1)y_2} + S_{(x_1 - 1)(y_1 - 1)}$（由于$S_{(x_1 - 1)(y_1 - 1)}$减了两次，因此还要加上多减的一次）。($S_{ij} &#x3D; S_{(i - 1)j} + S_{i(j - 1)} - S_{(i - 1)(j - 1)} + a_{ij}$)</p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分是前缀和的逆运算，给定长度为n的数组$a_1,a_2,…,a_n$，然后构造b数组$b_1,b_2,…,b_n$，使得$a_i&#x3D;b_1+b_2+…+b_i$，也就是a数组是b数组的前缀和，由此可得出$b_1&#x3D;a_1,b_2&#x3D;a_2-a_1,b_3&#x3D;a_3-a_2,…,b_n&#x3D;a_n-a_{n-1}$，此时b就称为a的差分，二维差分也是此思想。</p>
<p>假设要在[$a_l$,$a_r$]内统一加c，如果使用循环所花费的时间复杂度为O(n),若想让时间复杂度变为O(1)，此时就可以通过b数组来完成，因为$a_l&#x3D;b_1+…+b_l,a_r&#x3D;b_1+…+b_l+…+b_r$，如果要让区间[$a_l,a_r$]内每一个元素加c，只需给$b_l+c,b_{r+1}-c$即可，由于$b_l+c$导致$a_r$之后所有a数组元素加c，因此$b_{r+1}-c$将$a_r$之后的所有元素再减c（不包括$a_r$），这样就不会影响所求区间以外的值了，这样时间复杂度就变为了O(1)。 </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维差分</span></span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br><span class="line">    </span><br><span class="line"><span class="comment">//二维差分</span></span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c<span class="comment">//S[x1, y1] += c是对二维矩阵的右下部分所有元素加c，此时要将与所求区间内无关的元素多加的数值减去，使其成为最开始的值，有一片区域减了两次c，所以要加回来一次</span></span><br></pre></td></tr></table></figure>

<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>第一类双指针：</p>
<p>​	有两个序列，每一个指针指向一个序列。</p>
<p>第二类双指针：</p>
<p>​	两个指针指向一个序列。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B.6u3evz6drks0.webp" alt="双指针算法类型"></p>
<p>双指针算法是O(n)的。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;<span class="comment">//check(i, j)表示根据题目满足某一性质</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑,依据题目要求，在这里还要加一些代码</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算用于求n的二进制表示中第k位是几。首先将n右移k位(n &gt;&gt; k)，然后在求出右移后的值的个位(n &gt;&gt; k &amp; 1)，所得个位就是第k位。如$n&#x3D;15$时，二进制表示为$(1_31_21_11_0)_2$（1的下标表示当前的1处于第几(k)位），二进制中左边为最高位，右边为最低位,因此若要输出某一十进制的二进制表示，因从最高位开始循环输出<code>n &gt;&gt; k &amp; 1</code>。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n<span class="comment">//-n表示n的补码（取反加1）</span></span><br></pre></td></tr></table></figure>

<p><code>lowbit(n)</code>表示返回n的二进制表示最右边的1之后的表示，如某一二进制为$1010$,则lowbit返回$10$,二进制为$101000$,则返回$1000$。lowbit一般用于求二进制中出现1的次数。</p>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>这里特指整数的离散化。在$0-10^9$的范围内随机取出几个不连续的整数，然后将这些取出来的整数按从小到大的顺序映射到一个数组中。如在范围内取出五个整数1,3,100,2000,500000，然后把这五个数放在一个数组中，使得1对应的数组下标是0，3是1，100是2，2000是3，500000是4，也就是把这些值映射到下标。如果取出的数有重复的，那么需要去重。然后再算出某一x值在这部分数组中的下标是多少。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素，unique表示将数组中的所有重复元素去重，然后返回去重后的新数组的末尾，在新数组的末尾后面都是重复出现的元素，在unique中返回的是去重后新数组的末尾，在此末尾后还有一些之前重复出现的元素，那么erase中第二个参数就表示整个数组（去重后的新数组加重复出现的元素）的末尾，所以就表示删除重复出现的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求离散化问题时要根据题意将前缀和结合起来。</p>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p> 给定n个不同的区间，将这n个区间所有有交集的区间进行合并，然后输出合并之后的区间个数。如果两个区间只有端点相交（第一个区间的末尾元素和第二个区间的首元素相等），这样的区间也可以合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span><span class="comment">//PII为二元组，segs.first存放区间的左端点，segs.second存放区间的右端点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//二元组的排序是优先对二元组中的first排序，如果first都相等，那么就对second排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//初始区间，设置边界值，因为最开始还没有遍历区间，所以设置的左右边界都是同一值，只是将该左右边界放在数轴的最左边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)<span class="comment">//判断当前区间的右端点是否与下一个区间有交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//放入答案的区间不能是初始区间，因此需要判断将新的非初始区间放入答案</span></span><br><span class="line">            st = seg.first, ed = seg.second;<span class="comment">//更新区间的左右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//有交集，更新右端点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) <span class="comment">//防止区间为空</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//将最后一个区间加进去，这里指合并后的新区间</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第一章习题"><a href="#第一章习题" class="headerlink" title="第一章习题"></a>第一章习题</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/819/">快速排序</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x = q[l];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/788/">第k个数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; q[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/789/">归并排序</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i ++ , j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></p>
<p>解题思路：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F.5mk2accbqks0.webp" alt="逆序对的数量"></p>
<p>出现逆序对总共有三种情况，第一种在左半边内部，第二种在右半边内部，第三种一个在左半边一个在右半边，第三种情况包含前两种情况，因为第三种情况中的两个数组是最后一次递归得到的结果，此时两个数组分别已排好顺序，当L数组中有一个元素是严格大于R数组中的某一个元素时，则L数组中的这个元素之后的元素都是大于R数组中的某一个元素，所以以上图R[j]元素为基准，L数组中大于R[j]的个数总共有$mid - i + 1$个。在R数组中还会出现与R[j]相同的情况，将这些情况的数量相加就是最终的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++ , j ++ ) q[i] = tmp[j];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数二分-1"><a href="#整数二分-1" class="headerlink" title="整数二分"></a>整数二分</h2><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/791/">数的范围</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">做法一：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= k) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[r] != k) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= k) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">做法二：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">while</span> (k -- )&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; x) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &gt; x) r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二章-数据结构"><a href="#第二章-数据结构" class="headerlink" title="第二章 数据结构"></a>第二章 数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>在笔试中一般考察数组模拟链表，动态链表（结构体加指针）在创建节点时非常耗时，常在面试中考察。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;<span class="comment">//链表结点结构</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Node</span>();<span class="comment">//创建节点</span></span><br><span class="line"><span class="comment">//上述为动态链表</span></span><br></pre></td></tr></table></figure>

<p>单链表在笔试或算法题中用的最多的是邻接表。邻接表的应用是存储树和图。双链表用来优化某些问题。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表中，最开始有一个头节点，该头节点最开始指向空节点，每次会往里插入新元素，每一个节点都会存入节点的值和指向下一节点的next指针。</p>
<p>在数组模拟单链表中，需要定义e[N]存放某个节点的值，ne[N]表示next的指针，它存放的值是e数组某一节点元素的下一节点元素的下标，也就是将节点所处的位置作为ne数组的值，ne的下标表示当前节点的位置，存放的值表示指向下一节点的位置，最后一个节点所指向的节点为空节点，因此该空节点存放的值为-1，也就是说该空节点不指向任何下一个节点所以在此空节点中，ne存放的值为-1。e数组中存放的值是节点的值，下标表示当前节点所处的位置。这里的数组都是整型数组。 在链表中还需要定义一个整型变量head来指向头节点，与ne性质类似。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9B%BE%E8%A7%A3.51vvew6d9rg0.webp" alt="用数组模拟单链表图解"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点，相当于一个指针</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;<span class="comment">//一开始创建n个节点，由于最开始这n个节点都没有用到，因此idx指向头节点，当要使用节点存放值的时候，idx就指向下一个没有用到的节点，上一个节点就分配出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//初始化链表中没有任何节点，因此头指针指向空</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//表示当前可以从创建好的未用到的n个节点的0号节点（头节点）开始用，可以理解为idx创建节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;<span class="comment">//将要插入的节点指向head指向的节点，然后将head指向要插入的节点，所有的插入操作结束之后，由于当前的idx被分配出去，因此idx指向下一个没有用到的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];<span class="comment">//直接将head指向当前节点的下一节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];<span class="comment">//ne[ne[k]]表示下标为k的节点的下一个节点的下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>双链表每一个节点有两个指针，一个指针指向前一个节点，一个指针指向后一个节点。双链表没有指向的空节点，因为每一个节点都有指向的前后指针，因此初始链表是两个节点，并且这两个节点相互指向构成一个环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;<span class="comment">//0号节点和1号节点已经被分配了出去，因此idx指向第三个未使用的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span><span class="comment">//如果想在a节点的左边插入节点，那么就相当于在a节点的左节点的右边插入节点，所以只需将参数a改为l[a]即可</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//先赋值</span></span><br><span class="line">    l[idx] = a, r[idx] = r[a];<span class="comment">//插入新节点的右指针指向节点a的下一节点，左指针指向节点a本身</span></span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;<span class="comment">//设置完新节点左右指针的指向后，由于要构成双链表，因此要更新新节点左右两边节点的指向，新节点左边的节点的右指针要指向新节点，右边的节点的左指针也要指向新节点</span></span><br><span class="line">    <span class="comment">//双链表的插入节点时先将新节点的左右指针赋值，在更改新节点的左右节点的指针指向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];<span class="comment">//将要删除的节点的右节点的左指针指向要删除的节点的左指针指向的节点</span></span><br><span class="line">    r[l[a]] = r[a];<span class="comment">//将要删除的节点左节点的右指针指向要删除的节点的右指针指向的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是先进后出的数据结构。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;<span class="comment">//将所有元素插入栈中后，最先进入栈的元素在最栈底，最后进的元素在栈顶，因此弹出元素是在栈顶弹出，所以栈是先进后出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;<span class="comment">//从栈顶弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)<span class="comment">//如果大于0说明栈中有元素，不为空，否则为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是在队尾插入元素，队头弹出元素，先进先出。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">普通队列：</span><br><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;<span class="comment">//将队头指针向后移动一位，也就是将队头元素弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];<span class="comment">//取出队头元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)<span class="comment">//队头指针小于队尾指针说明队列不是空的，队头指针和队尾指针有可能相等，此时说明队列中还存在最后一个元素，当在此情况下hh ++ 之后弹出该元素，此时hh &gt; tt，则说明队列为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">循环队列：</span><br><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>给定一个序列，求序列中的每一个数的左边或右边离它最近而且比它大或小的数在什么地方。这样的问题一般用单调栈来解决。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;<span class="comment">//删除不满足条件的栈顶元素</span></span><br><span class="line">    stk[ ++ tt] = i;<span class="comment">//在这里已经将不满足条件的栈顶中删除，因此i可以入栈</span></span><br><span class="line">&#125;<span class="comment">//与双指针类似</span></span><br></pre></td></tr></table></figure>

<p>在单调栈问题中，i每往右边移动一个数时，就给栈里面加入一个元素。也就是说当i指向$a_i$时，此时栈里的元素为$a_1, a_2, … ,a_{i - 1}$,每一次寻找从栈顶开始往后找，直到找到第一个结果为止。当然在栈里的所有元素都要保持严格的单调性，要么单调上升，要么单调下降（上升和下降指的是栈中的元素按大小排列方式），也就是说，根据题目要求，如果要查找i的左边第一个比它小的数，那么在栈中的一些满足条件的元素永远都不会作为结果输出，因为只查找离i最近的且满足条件的元素。举个例子，在栈中$a_3&gt;&#x3D; a_5$,由于要在栈中查找某一最近的元素小于$a_i$,已知$a_3 &lt; a_i$且$a_3&gt;&#x3D;a_5$，因为$a_5$在$a_3$的右边离$a_i$最近，所以只取$a_5$ 而不取$a_3$,因此在这样的情况下$a_3$是永远都不会作为结果输出，所以在这样的例子下，$a_3$就可以被删掉，把这样类似的情况的元素都删除掉之后，剩下的栈里的元素都形成一个严格单调上升的情形。</p>
<p>总结一下：在查找离i最近的且比它小的元素时，那么在插入栈的时候栈顶元素不能比i大，如果比i大那么就删除栈顶元素，直到有一个栈顶元素比i小，则这个栈顶元素就是离i最近且比它小的元素，然后i入栈，继续遍历数组中的下一个元素（i + 1）循环上述操作。如果要查找离i最近且比它大的元素，反过来即可。</p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列与单调栈的思路相同。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口，也就是检查窗口里的第一个元素是否大于队头元素，如果成立，则需要将头指针向后移动一位以保证以头指针处于窗口的第一个位置（队列和窗口中存放的是数组下标，因此是有顺序的）</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单调栈的问题中，栈里存放的是输入的值，可以不需要建立辅助数组，而单调队列问题中队列里存放的是数组下标，因此要先建立数组把输入的值存进去，然后遍历数组入队。</strong></p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP一般用来解决字符串匹配问题。 </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：<span class="comment">//next数组中每一个元素存放的是以依次遍历模式串中的某一位i作为终点（next[i]），然后从模式串的开头到此终点查找最长的前缀和后缀相等（比如一个字符串&quot;ababa&quot;,它的最长前缀和后缀相等为3，因为前缀和后缀的&quot;aba&quot;是相等的且长度为3(将这样最大前缀后缀相等的长度存入next[i])，假设一个字符串长度为i，然后找到其前缀和后缀最长相等的子串，长度为j，那么前缀的长度为1到j,后缀的长度为i - j + 1到i，并且长缀后缀相等(next[i] = j)），然后将这个长度存入next数组中对应的位置i中,next数组存放的是以模式串某一位置为终点的最长前缀和后缀相等，与长文本没有关系</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )<span class="comment">//ne[1]可以不用考虑，因为当第一个字母失败了（查询最长长度），只能从0开始，所以ne[1]永远都为0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;<span class="comment">//查找模式串每一个位置（作为终点）的前面的最长前缀和后缀相等的长度，将这样的长度存入next数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )<span class="comment">//每一次匹配模式串要在长文本前面一位</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//当出现不匹配的时候，ne[j]存放的是以模式串当前j的位置为终点的最长前缀和后缀相等的长度，更新j并且保证这样长度的内容与长文本的内容是相等的，也就是说出现不匹配的情况，将模式串往后移动，然后继续判断下一个位置是否匹配，如果不匹配，继续移动，直到模式串的全部内容与长文本中的某一段内容匹配或者j退无可退的时候（j退到了起点，说明模式串的内容与长文本不匹配到），退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//如果该位置匹配，那么模式串移动到下一位置，等待在长文本的下一个位置（下一循环）继续匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)<span class="comment">//m是模式串的长度，如果j和m相等，说明匹配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];<span class="comment">//匹配成功后，j往后退一步继续寻找长文本中下一个能够匹配的字符串片段</span></span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里强调一下，每次判断是否匹配时，长文本的位置是i，模式串的位置是j + 1。</p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>trie树是用来高效地存储和查找字符串集合的数据结构。</p>
<p>trie树存储字符串的方式是从根节点开始，查找字符串中每一个字符是否在树结构中存在，若不存在则创建节点将字符存进去，若存在则直接利用不需要再次创建，第一个字符串存储成功之后，存储第二个字符串也是从根节点开始，遍历字符串字符，若树结构中存在，则不需创建直接利用，否则创建新节点。每一次存储下一个字符串时，都要从根节点开始查找存储。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/Trie%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.55lvr89ejrg0.webp" alt="Trie树存储结构"></p>
<p>所有字符串存储结束之后都要在每一个字符串结尾做一个标记来表明一个字符串，如果不标记则无法判断树结构中有哪些字符串。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/Trie%E6%A0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%87%E8%AE%B0.406xugkf9360.webp" alt="Trie树字符串标记"></p>
<p>以上是字符串的存储，接下来是字符串的查找，查找每一个字符串都要从树的根节点开始依次查找，每当查找到一个字符，就继续寻找下一个节点查找下一个字符，如果下一个字符不存在则说明查找失败，如果字符串中的每一个字符都查找到，当查找的最后一个字符在树结构中没有标记，也属于查找失败，因为在存储每一个字符串的时候都要在存储后的字符串结尾字符添加标记表示树结构中存在这样的字符串，因此就算在查找字符串中的每一个字符都成功的查找到，但这个字符串的结尾字符没有被标记，所以说明该树结构不存在这样的一个字符串，所以说明没有在树结构中查找到这样的字符串。<strong>成功查找到字符串需要满足两个条件：1. 字符串的每一个字符都能够在树结构中查找到。2. 该字符串的结尾字符在树结构中有标记。</strong></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点，该数组第一个中括号表示该节点的上一个节点的idx值，第二个中括号表示要存入的所有字符串当中，出现最多字符的个数（也就是存在某一个字符串，它的字符串中的每一个字符都不一样，比如要存入树结构的字符串都是小写字母，那么会有一种最长的字符串长度是26，因为有26个不同的小写字母）,son[p][u]表示p节点的第u个儿子节点，也就是说第一个中括号表示某一个节点，第二个中括号表示该节点的第几个子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量，相当于做标记</span></span><br><span class="line"><span class="comment">//idx与链表中的idx一样，表示可以用到的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;<span class="comment">//每次存入新的字符串都要从根节点开始遍历存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//将遍历到的字符映射成整型数字，为了表示数组下标</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<span class="comment">//如果在树结构中没有这样的字符，则创建节点并存入字符，也就是在当前节点创建一个子结点</span></span><br><span class="line">        p = son[p][u];<span class="comment">//走到下一个节点 </span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;<span class="comment">//做标记，表示树结构中存在这样的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果要查找的字符串中的某一字符在树结构中的当前路径的下一节点不存在，则说明查找失败</span></span><br><span class="line">        p = son[p][u];<span class="comment">//否则走到下一节点，进入下一循环继续查找下一字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];<span class="comment">//返回以某一字符结尾的单词个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是面试中常考的算法，因为该算法比较考验考生的思维能力。</p>
<p>并查集用来快速的将两个集合合并或询问两个元素是否在一个集合当中。并查集可以在近乎O(1)的时间中完成这两个操作。</p>
<p>每一个集合通过一个树的形式来维护（不一定是二叉树）。树根节点的编号就是当前集合的编号，每一个点都存储它的父节点。当想求某一点是属于哪一个集合时，根据这个点的父节点是否属于树根，若不是树根继续往上找，直到找到树根为止，那么该某一点属于的集合编号就是这个树根的编号。</p>
<p>合并两个集合：在两个集合中选中任意一个集合，将其树根节点连接到另一棵树的根节点，使得其中一棵树是另一棵树的儿子或父亲，完成合并。</p>
<p>在查找某一节点属于哪一个集合的操作时，一旦找到它的根节点，那么将该某一结点的查找到根节点的路径当中经过的所有结点（包括该某一节点）都指向根节点，这样在第二次要查找这些指向根节点的其中一个节点时只需走一步即可查找到集合的编号，大大缩减了查找的时间（O(1)），也就是对查找操作做出的优化。此优化操作称为路径压缩。</p>
<p>并查集还有另外一个优化是按秩合并，但此优化效果并不明显，一般常使用路径优化。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：<span class="comment">//常用于集合的合并</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点（）根节点，这里同时存在路径压缩</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//如果x不是根节点，那么就让它的父节点指向祖宗节点，这里的递归可以理解为先找到每一个x的根节点，然后将每一个x的父节点指向根节点，即路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;<span class="comment">//查找根节点，也就是集合编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;<span class="comment">//一开始每一个节点都指向自己</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//找到a节点和b节点的根节点，然后将任意一个根节点作为另一个节点的父节点或子节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：<span class="comment">//常用于查询某一集合的节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量，也就是说如果要查找某一集合中某一节点所在的集合的点的数量，那么需要找到该节点的根节点，因为集合的数量只存储在根节点中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;<span class="comment">//最开始每一个集合只有一个点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];<span class="comment">//两个集合合并之后，他们的集合的点的数量要相加</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;<span class="comment">//最开始是一个节点为一个集合，所以距离都为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>

<p><strong>并查集的核心就是find()函数。</strong></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆的基本操作：</p>
<ol>
<li>插入一个数</li>
<li>求集合当中的最小值</li>
<li>删除最小值</li>
<li><strong>删除任意一个元素</strong></li>
<li><strong>修改任意一个元素</strong></li>
</ol>
<p>4和5在STL容器中的堆是没法直接实现的。而在手写堆的数据结构中是可以直接实现的。</p>
<p>堆是一个二叉树或完全二叉树结构。存储方式是用一个一维数组来存储，一号点是根节点，每一个节点x（数组下标）的左儿子是2x，右儿子是2x加一，依次存入一维数组当中。这里的x指的是节点存入数组的下标，并不是存入的具体的值。</p>
<p>小根堆：每一个节点都是小于等于左右儿子的，则根节点是整个堆结构中的最小值。最下面的一层是整个小根堆中的每一层的最大值。</p>
<p>堆的两个操作：</p>
<pre><code>1. down(x)：把某一个节点往下调整
1. up(x)：把某一个节点往上调整
</code></pre>
<p>堆的五个操作完全可以用down()和up()两个函数组合起来。</p>
<p>以小根堆为例，down()函数表示，如果某一个节点的值变大了，那么需要把这个节点下沉，也就是依次对它的两个儿子的最小值交换，直到还原为小根堆的结构为止。up()函数则与之相反，但在小根堆的结构当中只需要依次对它的父节点进行交换即可，它的兄弟节点不需要参与进来。</p>
<p>上述描述见下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%A0%86%E5%9B%BE%E8%A7%A3.10htkpyc4af4.webp" alt="堆图解"></p>
<p>插入元素是在整个堆的最后一个元素插入，然后把该插入的值不断往上移动（up()函数）以保持小根堆或大根堆的状态。求堆的最小值（小根堆）或最大值（大根堆）只需要找到根节点即可。</p>
<p>如果想删除一个最小值，在删除该最小值后用整个堆里的最后一个元素覆盖到堆顶（根节点），然后让堆的总个数减一，最后将该覆盖后的节点值不断往下移动（down()函数）以保持堆的状态。不直接删除最小值的原因是因为整个堆是通过一维数组来维护的，因此根节点很难删除，所以通过删除最后一个节点来间接的删除根节点，删除之后只需要将数组的长度减一即可。</p>
<p>删除任意元素k与删除最小值类似，但是需要判断它变化的值是变大还是变小来决定需要调用down()函数还是up()函数，因此在删除元素后，同时输入down()和up()两个函数让系统来判断，两个函数只有其中一个会被调用。</p>
<p>修改任意元素与删除任意元素类似，在修改一个元素后，同样输入两个函数。</p>
<p>堆的操作代码详解见下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3.5bvyeatn0k00.webp" alt="堆操作详解"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<span class="comment">//交换两个元素插入的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);<span class="comment">//两个元素在第几个点插入的位置交换后，还要将它们是第几个插入的进行交换</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);<span class="comment">//交换堆中两个元素</span></span><br><span class="line">&#125;<span class="comment">//总结，在堆的交换操作中，不仅要把两个节点的值交换，还要把他们所处的位置进行交换，将他们所处的位置交换后，它们是第几个插入的元素也要进行交换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//这里的参数u并不是节点里存放的值，而是一维数组存储每一个节点的数组下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">//u * 2表示左儿子，然后找到两个节点的最小值</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//u * 2 + 1表示右儿子，与上同理</span></span><br><span class="line">    <span class="comment">//上面两个if语句表示找寻某一位置的节点和它的左右两个儿子节点中的最小值</span></span><br><span class="line">    <span class="keyword">if</span> (u != t)<span class="comment">//如果u不等于t，说明在查找三个节点的最小值之前，根节点不是最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);<span class="comment">//交换两个值</span></span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//这里的t指的是位置，不是存储的值，上面的交换操作也只是交换了值，并没有交换位置，此时u成为了最小值，t存储的最大值，然后递归将此最大值继续下移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])<span class="comment">//u / 2表示u节点的父节点并且该点存在（大于0），同样是找到最小值并赋值给父节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;<span class="comment">//相当于除以2，交换操作已经结束，因此位置需要移动到父节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);<span class="comment">//在一开始已经将输入的各个元素存入一维数组中，此时的一维数组可以理解为已经属于一个堆的结构，只不过还没有进行排序</span></span><br></pre></td></tr></table></figure>

<p><strong>存储堆元素的一维数组下标从1开始。</strong></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表：</p>
<pre><code> 1. 存储结构
  	1. 开放寻址法
  	1. 拉链法
 1. 字符串哈希方式
</code></pre>
<p>哈希表用来把一个特别大的空间映射到一个小空间中，例如大空间的大小为$10^9$，哈希表的数组长度大小为$10^5$，要将大空间的数映射到哈希表中，只需要将大空间中的每一个数与$10^5$取模（$x % 10^5$）存入哈希表相应的位置中即可,哈希表的数组长度一般取为质数，因为这样出现的冲突概率是最小的，因此最接近并且大于$10^5$的质数是$10^5 + 3$，因此哈希表的数组长度取为$10^5 + 3$。哈希表在存储的过程中会出现多个不一样的数映射到哈希表中的同一个数，这就出现了冲突，因此需要处理这样的冲突。</p>
<p>处理冲突的方式有两种，第一种为拉链法，首先开一个一维数组用来存储所有的哈希值，在哈希的过程中会出现两个不同的数放在一维数组中的同一个元素中，所以要处理这样的冲突，也就是将一维数组中的每一个元素看作一个槽，用来存放哈希之后的数字，在每一个槽中都拉一条链，用来存储这个槽上当前有的所有数，当出现冲突时，只需在这条链的后面加入这个数即可，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8B%89%E9%93%BE%E6%B3%95%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E6%96%B9%E5%BC%8F.35nzeivguik0.webp" alt="哈希表拉链法处理冲突方式"></p>
<p>在每一个槽后面拉的一个链就是单链表。</p>
<p>在算法题中，哈希表只有插入和查找操作，一般没有删除操作。如果必须要实现删除操作，一般不会真的把某一数删除，而是开一个布尔数组，将哈希表中要删除的数做一个标记即可。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line">	<span class="comment">//e[N], ne[N], idx都是单链表中的内容，因为每一个槽都要连接一条链用来存放出现冲突的数，所以会用到单链表结构，h[N]是哈希表数组长度，h[N]中每一个元素相当于单链表的头节点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h)<span class="comment">//在一开始建立哈希表数组时要使用memset()将每一个数组的值改为-1，因为哈希表中的每一个元素相当于不同的单链表的头指针，因此在初始化时每一个头指针都要指向空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//x有可能是负数，需要将其转换为正数 </span></span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;<span class="comment">//单链表的插入方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历单链表，查询要找的值</span></span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<span class="comment">//null是定义的一个值，一般是超过int型数据范围之外的一个值，比如const int null = 0x3f3f3f3f（一般设置最大值就是这个值）.该循环一定是可以停止的，因为哈希表的数组长度是题目数据范围的两倍，所以哈希表中一定会有没有存放的位置用来结束循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;<span class="comment">//如果t之后的所有元素都不是空位，那么循环从头开始继续查找空位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;<span class="comment">//开放寻址法中的find函数表示如果该数在哈希表中存在，那么返回该数在哈希表中所在的位置，如果该数不存在，则返回该数应该存放在哈希表中的位置</span></span><br></pre></td></tr></table></figure>

<p>开放寻址法只开了一个一维数组，不存在单链表，但是数组的长度一般要开到题目数据范围的2-3倍，这样的范围出现冲突的概率更小，同样是质数。如题目的数据范围是$10^5$,那么哈希表的数组长度为$2*10^5$,因为要取质数，所以最近的质数为$2 * 10^5 + 3$。</p>
<p>开放寻址法处理冲突的方式是从一维数组的第k位开始找空位，如果第k位没有空位，那么继续往后查找，直到找到第一个有空位的位置插入，查找操作也是如此。在查找到某一数时，如果想删除它，和拉链法的做标记相同。</p>
<p>字符串哈希：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];<span class="comment">//处理前缀字符串的哈希值</span></span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;<span class="comment">//计算P的i次方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串哈希又称字符串前缀哈希法。例如有一串字符串str的内容为”ABCABCDEFYXCACWING”，那么哈希之后在哈希表h中存储的方式为，h[0] &#x3D; 0, h[1] &#x3D; “A”, h[2] &#x3D; “AB”, h[3] &#x3D; “ABC”, h[4] &#x3D; “ABCA”,以此类推，也就是在哈希表数组中，数组下标为几，那么该数组位置所存放的内容就为字符串str中的前几个字符，所以称为字符串前缀哈希法。注意哈希表h数组每一个元素存放的不是字符串，而是对应前缀字符串的哈希值，因此在存放之前要对该前缀字符串求哈希值。</p>
<p>定义某一前缀的哈希值：</p>
<p>​	首先把一个字符串看成是一个p进制的数。举例：加入要求一个前缀字符串”ABCD”的哈希值，那么先把这个字符串看作p进制的数，该字符串一共有四个字母，那么看成四位（前缀字符串有几个字母，就看做几位），第一位数是A，第二位数是B，第三位数是C，第四位数是D。接下来对每一个字母赋值，按照A到Z（1到26）的顺序来赋值，那么A为1，B为2，C为3，以此类推。那么字符串”ABCD”就可以看作$(1_32_23_14_0)_p$,所以它对应的十进制的数就是$1<em>p^3 + 2</em>p^2 + 3<em>p^1 + 4</em>p^0$（这就是预处理前缀字符串的哈希值，就是<code>h[i] = h[i - 1] * P + str[i]</code>），那么就可以通过这样一个方式将字符串转换为数字。由于字符串的长度有可能会非常长，那么转换的数字也会非常大，这样非常大的数是不好存储的，所以还要对求得的每一个哈希值模一个比较小的数Q，然后就可以通过取模把整个数字映射到从0到Q-1的一个数。</p>
<p>​	总结：定义前缀哈希值时，首先把字符串看作p进制的数，然后根据字符串字母的个数定义位数，之后将该p进制的数转换为十进制数，最后对该十进制数取模，通过这样一个方式就可以把任何一个字符串映射到从0到Q-1之间的数。</p>
<p>​	注意：</p>
<pre><code>      1. 在一般情况下不能把某一个字母映射成0
      2. 当$p=131或p=13331$,$Q = 2^&#123;64&#125;$时，有99.99%的概率是不会发生冲突的。在数字哈希的问题中是可以容忍冲突的，但在字符串哈希中是假定哈希的情况是最好的，不存在冲突的问题。
</code></pre>
<p>字符串哈希数字的方式如下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F.7bxlg7916qw0.webp" alt="字符串哈希数字的方式"></p>
<p>求字符串子串的哈希值(如下图所示)：</p>
<p>​	假设要求str字符串L到R之间的子串的哈希值，那么h[L - 1]为前缀为1到L - 1的字符串，h[R]为前缀为1到R的字符串。先将字符串转换为p进制的数，那么在str字符串这一段中左边为高位，右边为低位（这里指的是p进制的高位和低位）。然后分别找到h[L - 1]和h[R]的高位和低位，在h[R]中，前缀为R的字符串最左边为第$R-1$位（$p^{R - 1}$），最右边为第0位($p^0$)。在h[L - 1]中，前缀位L - 1的字符串最左边为第$L - 2$位($p^{L - 2}$)，最右边为第0位($p^0$)。然后将L - 1这一段与R这一段的最右边对其，也就是对L - 1这一段乘$p^{R - L + 1}$,最后再用R这一段减去移动后的L - 1段的字符串值即可得到子串的哈希值，公式为$h[R] - h[L  - 1]*p^{R-L+1}$。图中的公式写错了，应该是h[L - 1]。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC.5s1vlkzittc0.webp" alt="求字符串子串的哈希值"></p>
<p>字符串哈希一般用于处理快速判断两个字符串是否相等的问题。</p>
<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector为变长数组，是可以动态变化的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()  返回第一个数</span><br><span class="line">    <span class="built_in">back</span>()   返回最后一个数</span><br><span class="line">    <span class="built_in">push_back</span>()  在最后插入一个数</span><br><span class="line">    <span class="built_in">pop_back</span>()   删除最后一个数</span><br><span class="line">    <span class="built_in">begin</span>()  第一个数</span><br><span class="line">    <span class="built_in">end</span>()    最后一个数的下一个位置</span><br><span class="line">    [] <span class="comment">//支持随机寻址</span></span><br><span class="line">    支持比较运算，按字典序<span class="comment">//例如两个vector数组之间的比较</span></span><br></pre></td></tr></table></figure>

<p>vector数组a初始化：<code>vector&lt;int&gt; a;</code></p>
<p>定义长度为n的数组a：<code>vector&lt;int&gt; a(n);</code></p>
<p>将数组a中的每一个元素初始化为特定的数m：<code>vector&lt;int&gt; a(n, m);</code></p>
<p>也可以定义数组：<code>vector&lt;int&gt; a[n];</code></p>
<p>vector遍历方式：</p>
<pre><code>1. `for (int i = 0; i &lt; a.size(); i ++ ) cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;`
1. 迭代器遍历，`for (vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i ++ ) cout &lt;&lt; *i &lt;&lt; &#39; &#39;;`(`vector&lt;int&gt;::iterator`可以用auto代替)
1. 范围遍历，`for (auto x : a) cout &lt;&lt; x &lt;&lt; &#39; &#39;;`
</code></pre>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br></pre></td></tr></table></figure>

<p>pair初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, string&gt; p;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;yxc&quot;</span>);</span><br><span class="line">p = &#123;<span class="number">20</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;p;<span class="comment">//这样可以存储三元组</span></span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br></pre></td></tr></table></figure>

<p>定义队列：<code>queue&lt;int&gt; q;</code></p>
<p>如果已经定义了队列，<code>q = queue&lt;int&gt;();</code>可以重新构造队列</p>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>

<p>定义堆：<code>priority_queue&lt;int&gt; heap;</code></p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    [] <span class="comment">//支持随机寻址</span></span><br></pre></td></tr></table></figure>

<p>deque的缺点是速度慢。</p>
<h3 id="set与multiset"><a href="#set与multiset" class="headerlink" title="set与multiset"></a>set与multiset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> <span class="title">erase</span><span class="params">()</span>输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span><span class="comment">//k是x的个数</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> <span class="title">erase</span><span class="params">()</span>输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span><span class="comment">//set的核心操作</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br></pre></td></tr></table></figure>

<p>set定义：<code>set&lt;int&gt; s</code></p>
<p>multiset定义：<code>multiset&lt;int&gt; MS</code></p>
<p>set是不能有重复元素，如果插入重复的元素，该操作是自动被忽略掉，而multiset是可以有重复元素的。</p>
<h3 id="map与multimap"><a href="#map与multimap" class="headerlink" title="map与multimap"></a>map与multimap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map/<span class="function">multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br></pre></td></tr></table></figure>

<p>定义：</p>
<p>​	<code>map&lt;string, int&gt; a;</code></p>
<p>​	<code>a[&quot;yxc&quot;] = 1;</code></p>
<p>​	<code>cout &lt;&lt; a[&quot;yxc&quot;] &lt;&lt; endl</code>输出1</p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bitset, 圧位</span><br><span class="line">    bitset&lt;10000&gt; s;<span class="comment">//中括号中写的是bitset的个数</span></span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~（取反）</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>

<p>bitset可以省8倍空间，这是bitset最主要的特点。</p>
<h1 id="第三章-搜索与图论"><a href="#第三章-搜索与图论" class="headerlink" title="第三章 搜索与图论"></a>第三章 搜索与图论</h1><h2 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS(深度优先遍历)"></a>DFS(深度优先遍历)</h2><p>DFS对整个空间进行遍历，搜索的结构是一棵树，DFS的搜索方式是一搜到底，并且搜索到底后会返回上一节点并判断该节点是否还能继续往下搜，如果不能则返回上一节点继续判断，直到返回到根节点为止，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/DFS%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.es7pqrwojuw.webp" alt="DFS搜索方式"></p>
<p>DFS使用的数据结构是栈，由于他是一搜到底，所以空间与它的深度成正比，所以空间是O(h)。DFS不具有最短路性。空间上DFS比较占优势。</p>
<p>图的深度优先遍历模板（dfs没有固定模板）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过，u表示第几层的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//这里是使用链表的遍历方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS搜到最深一层后要回溯继续搜索其他节点，因此遍历完一条路径后需要恢复现场。</p>
<p>DFS的剪枝是提前判断，也就是遍历某一条路径时还没有遍历到最深一层就发现这条路径不符合题意，那么这条路径之后的节点不再遍历，直接回溯遍历其他路径。</p>
<h2 id="BFS（宽度优先遍历）"><a href="#BFS（宽度优先遍历）" class="headerlink" title="BFS（宽度优先遍历）"></a>BFS（宽度优先遍历）</h2><p>BFS同样对整个空间进行遍历，搜索的结构也是一棵树，它与DFS不同的是BFS是一层一层的搜索而不是一搜到底，BFS的搜索方式比较像眼观六路耳听八方，它同时可以搜索很多条路，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/BFS%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.o5jvdhxxxa8.webp" alt="BFS搜索方式"></p>
<p>BFS使用的数据结构是队列，由于它每次会把整个一层的数据都存起来，所以BFS的空间是指数级别，所以空间是O($2^h$)。由于BFS是一层一层的扩展，所以它第一次搜到的点一定是最近的点，因此它有一个最短路的概念。空间上BFS占劣势。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树和图的存储方式"><a href="#树和图的存储方式" class="headerlink" title="树和图的存储方式"></a>树和图的存储方式</h2><p>树是一种特殊的图，图分为有向图和无向图。有向图就是有方向的图，比如a到b，而无向图可以理解为双向图，a可以到b，b也可以到a，因此无向图可以看作一种特殊的有向图。</p>
<p>有向图分为邻接矩阵和邻接表。邻接表用的最多，邻接表与哈希表中的拉链法类似，每一个点都是单链表，就是存图中的每个点的下一个点都有哪些，这些下一个到达的点的存储是没有顺序的，也就是这样存储的每一个点能够到达的下一个所有的点是无序的，怎么排列都可以，例如节点1的链表既可以$1-&gt;3-&gt;4-&gt;\varnothing$这样存储，也可以$1-&gt;4-&gt;3-&gt;\varnothing$这样存储，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.1lzgbf605hts.webp" alt="邻接表存储方式"></p>
<p>邻接表某一点的插入或删除与链表的方式一样。  </p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>有向图的拓扑序列就是图的宽度优先遍历的一个应用，拓扑序列一定是针对有向图，有向图才会有拓扑序列。</p>
<p>如果一个点的序列满足对于每条有向边（x,y），x都出现在y的前面，那就称这个序列是这个图的一个拓扑序列。  环是不可能存在拓扑序。</p>
<p>有向无环图一定存在一个拓扑序列，有向无环图也被称为拓扑图。</p>
<p>有向图的每个点都有入度和出度，也就是一个点有几条边进来就有几个入度，有几条边出去就有几个出度。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6%E4%B8%8E%E5%87%BA%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5.ph0f34a1tq8.webp" alt="有向图入度与出度的概念"></p>
<p>在有向图中入度为0意味着没有任何一条边指向该点，所以该点可以排在当前最前面的位置，因此将所有入度为0的点入队。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;<span class="comment">//队尾为-1是因为此时队列为空，在遍历一遍所有点之后，如果有一个点的入度为0则入队，如果所有点的入度都不为0，则没有点入队，因此队列始终为空，就不会执行下面的while循环语句，此时就说明不存在拓扑序列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])<span class="comment">//队列中存放的是所有入度为0的节点</span></span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)<span class="comment">//每取出队头元素，该节点的下一个节点的入度就会减1，如果减去一个入度后为0，则入队尾</span></span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;<span class="comment">//队尾是从-1开始的，因此当所有点都入队后，队尾的长度为n - 1,如果队尾的长度最终不为n - 1，则说明不存在拓扑序列，因此返回-1</span></span><br><span class="line">&#125;<span class="comment">//入队之后的所有点的次序就是拓扑序</span></span><br></pre></td></tr></table></figure>

<h2 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h2><p>最短路分为单源最短路和多源汇最短路，单源最短路一般求从一个点到其他所有点的最短距离，多源汇最短路就是起点和终点都是不确定的。源点就是起点，汇点就是终点。单源最短路又分两种情况，第一种是所有边权都是正数，它包含的算法有朴素Dijkstra算法（O($n^2$) (n表示点的数量)）和堆优化版的Dijkstra算法（O(m$logn$) (m表示边的数量)），第二种是存在负权边，也就是存在某些边权重是负数，它包含的算法有Bellman-Ford算法（O(nm)）和SPFA算法（Bellman-Ford算法的优化，一般情况下O(m)，最坏O(nm)）。多源汇最短路的算法是Floyd算法（O($n^3$)）。其分支介绍如下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D.33xr5ga43h80.webp" alt="最短路算法介绍"></p>
<p>最短路问题的难点在建图。</p>
<h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><ol>
<li>先初始化距离，一号点到起点的距离为0，其余所有点都为正无穷。</li>
<li>i从1到n循环，建立一个集合S用来存放当前已经确定最短距离的点。在循环中，第一步找到不在S中的距离最近的点，第二步将这样的点加到S中，第三步用这样的点更新其他点的距离。整个循环之后就可以确定每个点的最短路径的距离了。</li>
</ol>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边的长度，存储边的时候，如果存在重边，只需保留最短的那一条边即可，g[a][b]可以理解为a到b的距离</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//第一步初始化距离</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//只有第一个点的距离是确定的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )<span class="comment">//该循环为外层循环，它的意思表示每一次循环都会找出一个已经确定最短路径的点，总共有n个点，所以会循环n或n - 1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )<span class="comment">//当循环到哪一个点时，这个点到起点的距离一定是最短的距离，只需要查找该点的下一个点到起点的距离即可</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;<span class="comment">//选择已经确定出最短路径的点（该点已为true）的下一个距离此点最近的一个点，因为这个已经确定好的点可能会直接指向多个不同的点，而指向多个不同的点（出度大于1）的距离有长也有短，比如一号点的距离为0且已经确定（一号点为true），此时一号点分别指向二号点和三号点，一号点到二号点的距离为4，一号点到三号点的距离为2，如果通过二号点（此时二号点为4）来查找到其他点的最短路，则有可能查找完之后所有的点到源点的距离都不是最短路，因为一号点到二号点虽然是距离为4，但是有可能会出现一号点到三号点再到二号点的距离为3，这个距离比一号点直接到二号点的距离更短，因此，在一号点的最短距离确定的情况下（一号点为true），并且一号点的出度大于1时，选择与一号点直接连接的所有点（选择下一个合适的点）中距离最短的那一个点是最好的选择，因此在上例中应该选择三号点，这也就是对if语句中dist[t] &gt; dist[j]的解释，同样，这个解释也可以理解下面的for循环语句。那么t = j语句就可以理解为选择一个更为合适的点作为查找其他最短路径的点的操作。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点到起点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);<span class="comment">//更新当前点的最短路径，t点是上一循环已经确定好的最短路径，j点是t点的下一个点（t点与j点直接连接的距离已经记录在邻接矩阵g中，t点与j点间接连接则为正无穷），因此只需要将t点的最短路径加t点到j点的路径，得到的就是j点到起点的最短路径</span></span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//整个循环会遍历到所有的点，如果有一个点的值还是正无穷，那么说明该点与起点是不连通的</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>边数很多的图是稠密图，它用邻接矩阵来存储，稀疏图用邻接表存储。</p>
<h3 id="堆优化版dijkstra算法"><a href="#堆优化版dijkstra算法" class="headerlink" title="堆优化版dijkstra算法"></a>堆优化版dijkstra算法</h3><p>当点数远大于边数时（稀疏图），需要进行优化。对图的存储方式也要改为邻接表的形式，需要用到的容器为优先队列，它可以实现堆结构。堆优化版的dijkstra算法不需要对重边做处理，因为此算法保证一定会选最短路的边。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//小根堆中每一个节点都是pair，存放点的距离和点的编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边，w表示权重，也就是边的长度</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="comment">//定义小根堆，因为要存放每一个点的最短距离，所以用小根堆来实现</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号，已知第一个点的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();<span class="comment">//每次找到堆中在距离最小的点，因为是小根堆，所以堆的顶点，也就是根，一定是最距离小的</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();<span class="comment">//弹出堆顶元素，每取出一个堆顶元素（说明该点已经是最短的距离了），那么就要把这个节点从堆中取出来，保证堆中的节点都是未确认最短距离的点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;<span class="comment">//取出该堆顶元素的距离和编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;<span class="comment">//如果这个点之前已经取出来过了，那么说明该点是冗余备份。可以这样理解，堆中的顶点永远都是最短距离的点，当取出该点后，如果在后面的取顶操作再次遇到该点，说明这个点的距离是比最初取出来的点的距离大的（两个点的编号一样，距离不一样，第一个出去的点的距离永远都是最短的），它不是最短距离，因此这个点就没必要做处理了</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//每一个点都以邻接表的形式存储了他的下一个点都是谁。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];<span class="comment">//e中存放的是图中点的编号</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])<span class="comment">//distance表示此邻接表中的头元素的距离，也就是取出来的堆顶元素，然后通过遍历此堆顶元素的邻接表，更新当前已经确定最短路径的堆顶元素到它的下一个点的距离，i表示分配（idx）出去的节点编号，所以w[i]表示该分配节点（idx）的编号中所存放的图中的点的编号的权重</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);<span class="comment">//虽然更新了距离，但还不是最短的距离，所以将其放入堆中继续更新距离，直至其更新至堆顶元素，那么它一定就是最短距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度 O(mlogn), n表示点数，m表示边数</span></span><br></pre></td></tr></table></figure>

<h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><p>bellman-ford算法中边的存储方式用结构体存储。bellman-ford算法循环结束后对于所有的边都满足$dist[b] &lt;&#x3D; dist[a] + w$，即三角不等式。bellman-ford算法可以处理有负权边的图。</p>
<p>在求最短路的时候，如果有负权回路，最短路是不一定存在的，如下图所示的负权回路中，在遍历选择最短路的时候的时候，2，3，4节点构成一个环，要查找1号节点到5号节点的最短路，由于存在负权边，因此在查找最短路时，中间的一个环会一直循环查找下去，查找到的最短路会无限减小，也就是负无穷，因此1号节点到5号节点的最短路也会为负无穷，那么这样1号节点到5号节点的最短路是不存在的。所以如果能够求出最短路，那么图中一般是不会存在负权回路的。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/bellman-ford%E7%AE%97%E6%B3%95%E8%B4%9F%E6%9D%83%E5%9B%9E%E8%B7%AF.3o3c2ryta120.webp" alt="bellman-ford算法负权回路"></p>
<p>bellman-ford算法可以用来查找负权环，假设一个图中有n - 1条边，n个节点，那么外层循环应该循环n次，当第n次循环还有路径更新的话（如果有n - 1条边的话，在第n次循环应该没有路径更新），那么说明存在一条路径有n条边，有n + 1个节点，由于总共有n个节点，但在循环后有n + 1个节点，那么说明存在两个相同的节点，则该路径上必然构成一个环，假设这条环是正权环，由于是要找最短路径，那么这个正权环是一定会抛弃的，因此不存在正权环的情况，所以当出现环时，该环一定是负权环。由于bellman-ford算法求负环的时间复杂度较高，一般不会用此算法查找负环。</p>
<p>bellman-ford算法的时间复杂度 O(nm), n 表示点数，m 表示边数。</p>
<p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，如果不加备份，在更新的时候可能发生串联， 以下图为例，当题目要求对求最短路径的边数有限制时，假设边数限制为一条边，那么观察图中可发现最短路本应该是2，即$1-&gt;2-&gt;3$，但因为限制了边数，即使这条路径是最短路径，但它的边数为二，所以1到3的最短路应该是3，路径为$1-&gt;3$。发生串联的意思是，在查找最短路时，比如已经确定1号点到2号点的最短路为1，路径为$1-&gt;2$，那么在在查找1号点到3号点的最短路时，由于1号点到2号点的最短路已经确定，所以会以2号点为起点，查找到三号点的位置，则此时查找到1号点到3号点的最短路为2，路径为$1-&gt;2-&gt;3$，但并没有达到题目要求边数为1的限制，因为在查找最短路时，每查找到一个点（1号点）的邻近点（2号点）的最短路后，就会以该邻近点（2号点）作为起点，查找下一个邻近点（3号点）的最短路，而不是回到最初的那一个点（1号点），那么由于回不到最初的点，所以就打破了题目的限制，所以需要做一个备份，保证更新的时候只用上一次迭代的结果（保留了之前的所有点），这样就满足了题目的要求。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/bellman-ford%E7%AE%97%E6%B3%95%E5%8A%A0%E5%A4%87%E4%BB%BD%E4%B8%BE%E4%BE%8B.3nlt4b99b2g0.webp" alt="bellman-ford算法加备份举例"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加备份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//因为有可能存在负权边，所以在查找最短距离时dist[n]的值为0x3f3f3f3f减去某一个负权边的值，那么此时dist[n] == 0x3f3f3f3f就不能作为判断条件，所以改为dist[n] &gt; 0x3f3f3f3f / 2</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA算法是单源最短路径里限制最少的算法，只要图当中没有负环就可以用spfa算法，一般的最短路问题中没有负环。如果是正权图的话，建议使用Dijkstra算法，如果是负权图的话SPFA算法比较好用。</p>
<h3 id="队列优化的Bellman-ford算法"><a href="#队列优化的Bellman-ford算法" class="headerlink" title="队列优化的Bellman-ford算法"></a>队列优化的Bellman-ford算法</h3><p>SPFA算法其实是对bellman-ford算法做了一个优化，bellman-ford算法每次迭代时是遍历所有边来更新最短路，但是每一次迭代不一定每条边都会更新，即不一定通过$dist[b] &#x3D; min(dist[b], dist[a] + w)$来使$dist[b]$变小，如果$dist[b]$变小，则$dist[a]$一定是变小了，所以SPFA算法就是从这一点进行优化，这个优化用宽搜来优化，那么在迭代的时候用一个队列来做，队列里存放的是所有变小的节点。SPFA的写法与Dijkstra算法相似。</p>
<p>模板：</p>
<p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n表示点数，m 表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//st数组存的是当前这个点是不是在队列当中，防止队列当中存储重复的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//取出队头元素后，该点已不在队列当中，因此将该点设为false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断图中是否存在负环"><a href="#判断图中是否存在负环" class="headerlink" title="判断图中是否存在负环"></a>判断图中是否存在负环</h3><p>SPFA求负环的思路与bellman-ford算法的思路是一样的，都是用抽屉原理求负环。需要建立一个cnt数组用来存放路径所经过的边数，当遍历后cnt数组中有某一元素为n，那么说明这条路径有n + 1个点，但是图中总共有n个点，由抽屉原理可知这条路径必定存在一个环，且该环是负权环。</p>
<p>模板：</p>
<p>时间复杂度 平均情况下 O(m)，最坏情况下O(nm), n表示点数，m表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组，因为该算法求的不是距离的绝对值，而是求路径中是否存在负环</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);<span class="comment">//由于在图中可能存在一些点无法到达负环，所以要将图中的所有点放入队列中查找</span></span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;<span class="comment">//cnt数组存放的是最短路经过的边数</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>Floyd算法用来求解多源汇最短路，用邻接矩阵来存储图。它的原理是基于动态规划。</p>
<p>模板：</p>
<p>时间复杂度是 O($n^3$), n表示点数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<span class="comment">//该公式基于动态规划</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树定义：</p>
<p>​	对于一个带权连通无向图G&#x3D;(V,E)，生成树不同，每棵树的权（树中所有边上的权值和）也不同，设R为G的所有生成树的集合，若T为	R中权值和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree，MST）</p>
<p>​	注：</p>
<p>​	1、最小生成树可能有多个，但边的权值之和总是唯一且最小的</p>
<p>​	2、最小生成树的边数&#x3D;定点数-1，砍掉一条则不连通，增加一条则会出现回路</p>
<p>​	3、若一个连通图本身就是一颗树，则其最小生成树就是它本身</p>
<p>​	4、只有连通图才有生成树，非连通图只有生成森林</p>
<p>最小生成树问题对应的图都是无向图，有向图的最小生成树一般是不会用到。最小生成树问题有两个算法，即普利姆算法（Prim）和克鲁斯卡尔算法（Kruskal）。普利姆算法与Dijkstra算法相像，稠密图一般用朴素版普利姆算法（$O(n^2)$），稀疏图一般用堆优化版的普利姆算法($O(mlogn)$)。克鲁斯卡尔算法的时间复杂度是固定的（$O(mlogm)$），它的时间主要花费在排序上。最小生成树问题上算法模板的选择一般稠密图用朴素版普利姆算法，稀疏图用克鲁斯卡尔算法和堆优化版的普利姆算法，但是堆优化版的普利姆算法一般不常用，所以稀疏图常用克鲁斯卡尔算法解决。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84.2hcxmaye6fg0.webp" alt="最小生成树结构"></p>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>Prim算法的思路与Dijkstra算法的思路相似，首先初始化所有的距离为正无穷，接下来n次迭代，每次迭代找到不在集合当中距离最小的点，该集合所表示的是当前已经在连通块的所有点，在迭代中首先找到在集合外距离最近的点（在迭代中选择集合外的点步骤为：遍历集合外的所有点，然后在这些点中选择其中一个与集合中的点最短的一个距离的点，前提是这样的点与集合中的任意一个点相连接，那么这个点就是迭代中要选择的点），然后用该点更新其他点到集合的距离（其他点到集合的距离其实就是看其他点有没有一条边能够连向集合内部，如果有，则选择这个点到集合中的一些点的距离最短的边，比如集合当中现在有三个点，分别为一号点、二号点和三号点，此时选择一个不在集合的四号点，该四号点与集合当中的三个点都相连，那么就选择这个点与这三个点连接的最短的一条边，则这个最短的距离就被称为点到集合当中最短的距离，如果该点不与集合当中的任意一点相连，则距离定义为正无穷），最后将该点加入集合中。</p>
<p>模板：</p>
<p>时间复杂度是 O(n2+m), n表示点数，m表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//存储最小生成树中所有边的长度之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;<span class="comment">//如果除第一个点以外，不存在任何两个点相连（说明各点互不相连），那么t最终为正无穷，即符合下面if语句，返回正无穷</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;<span class="comment">//如果不是第一个点，并且该点为正无穷，则说明当前距离最近的点到集合的距离都是正无穷，那么就不存在最小生成树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];<span class="comment">//选中的t必然是距离最短的点，所以与结果累加</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);<span class="comment">//用t点更新到其他点的最小距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>克鲁斯卡尔算法第一步将所有边按权重从小到大排序（$O(mlogm)$），第二步枚举每一条边ab，权重为c，如果ab不连通，那么将这条边加入集合中。第二步是并查集的简单应用，第二步的时间复杂度是$O(m)$,整个克鲁斯卡尔算法的时间复杂度为$O(mlogm)$。</p>
<p>克鲁斯卡尔算法不需要用邻接表或邻接矩阵来存图只需要开一个结构体把每条边存下来即可。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;<span class="comment">//重载小于号，方便排序</span></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);<span class="comment">//按照边权重从小到大排序 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )<span class="comment">//从小到大枚举所有边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并，判断两个点是否连通其实就是判断他们的祖宗节点是不是一样的</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;<span class="comment">//并查集的合并</span></span><br><span class="line">            res += w;<span class="comment">//res存储最小生成树中所有边权重之和</span></span><br><span class="line">            cnt ++ ;<span class="comment">//cnt存的是当前加了多少条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;<span class="comment">//如果加的边数小于n - 1说明这个图是不连通的，见最小生成树的定义</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p><strong>二分图的概念：二分图通常针对 无向图 问题（有些题目虽然是有向图，但一样有二分图性质）</strong></p>
<p>​	<strong>在一张图中，如果能够把全部的点分到 两个集合 中，保证两个集合内部没有 任何边 ，图中的边 只存在于两个集合之间，这张图就是二分图，也就是说同一个集合当中的任意两个点是没有边的，只有一个集合中的点和另一个集合中的点存在边。</strong></p>
<p>二分图有两个部分，第一个部分为染色法（$O(n + m)$），它的原理是深度优先遍历，用于判别是否为二分图。第二部分为匈牙利算法（最坏为$O(mn)$，但一般实际运行时间远小于$O(mn)$），用于求二分图的最大匹配</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E6%9E%84.62fxxjuia9c0.webp" alt="二分图结构"></p>
<h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>二分图当且仅当图中不含奇数环（奇数环指环当中的边数是奇数，如果有奇数环，那么就不存在二分图）， 遍历图中的某一个点，假设遍历一号点，把它放入一号集合，那么所有与一号点相邻的点都要放在二号集合中，保证一条边的两个点是属于不同的集合的，此选择放入哪一个集合的过程称为染色，由于图当中是不含奇数环，所以该染色过程是不存在矛盾的。</p>
<p>模板：</p>
<p>时间复杂度是 O(n+m), n表示点数，m表示边数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//对当前点染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历当前点所有的邻点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)<span class="comment">//如果当前点的邻点j没有染色，那么递归到该j点染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//染成与当前节点不同的颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果当前j点已经染过颜色，那么需要判断它与当前点的颜色是否一样，如果一样，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果所有的点都被染色并且没有发生矛盾，那么就不会递归dfs函数，直至最后一步for循环结束并返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span><span class="comment">//判断是否染色成功，如果成功则为二分图，反之则不是</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//用来表示染色的过程中是不是有矛盾发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)<span class="comment">//如果该点没有染色，那么就需要染色</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))<span class="comment">//如果dfs返回的是false就说明有矛盾发生</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;<span class="comment">//染色发生矛盾</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果染色失败，说明发生矛盾，直接退出返回结果即可</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>给定一个二分图，用匈牙利算法来求出它的最大匹配（最大匹配是指两个点只共用一条边，并且在之后的匹配中这两个点不再参与匹配）的数量，<strong>举一个现实中的例子，把匹配问题转化为找对象问题，假设有两个男生和两个女生，一号男生可以选择一号女生和二号女生，而二号男生只可以选择一号女生，此时先选择一号男生看他可以和哪个女生处对象，选择之后，一号男生可以和一号女生处对象，匹配成功，接下来选择二号男生，看他可以和哪些女生处对象，此时查到二号男生只能和一号女生处对象，但是一号女生已经被一号男生选择了，由于要求最大的匹配数量，这时一号女生被两个人选择，那么一号女生就要查找一号男生除了选择自己以外还可以选择哪些女生，一号女生查到了一号男生还可以选择二号女生，为了尽可能的让所有男生都可以找到对象，一号女生就要放弃一号男生，让一号男生选择二号女生，这样二号男生就可以选择一号女生，最终两个男生都有对象，最大匹配问题解决。</strong>所以匈牙利算法一般用于求出二分图当中的这样的匹配的边的数量。</p>
<p>模板：</p>
<p>时间复杂度是 O(nm), n表示点数，m表示边数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//第一个集合每个点的邻接表连接的都是第二个集合中的点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">//j指的是第二个集合的点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))<span class="comment">//在第一个男生选择的情况下，如果一号女生还没有选择男生，那么就执行下列语句，让一号女生选择一号男生。如果一号男生已经选择完了，该让二号男生选择时，由于二号男生也可以选择一号女生，但是一号女生已经选择了一号男生，那么二号男生就会让一号女生询问一号男生是否还可以选择其他女生，此时一号女生发现一号男生还可以选择二号女生，那么就要递归让二号女生选择一号男生（此操作在递归中执行），递归出来之后，下列语句的意思就是由于一号男生选择了二号女生，那么一号女生就可以选择二号男生了</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//整体来讲，表面上看似是男生选择女生，实际在内部当中是女生选择男生，这样理解后，如果一个男生可以选择多个女生，那么永远是最后一个女生得手，前面的已经选择了男生的女生就要选择其他男生</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )<span class="comment">//分析第一个集合中每一个点可以选择第二个集合中的哪个点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);<span class="comment">//先对第二个集合初始化，表示第二个集合中每个点都没有被选择</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;<span class="comment">//如果第一个集合当中的点成功找到可以与第二个集合匹配的点，则加入结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-数学知识"><a href="#第四章-数学知识" class="headerlink" title="第四章 数学知识"></a>第四章 数学知识</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>质数：在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者叫素数。</p>
<h3 id="试除法——质数的判定"><a href="#试除法——质数的判定" class="headerlink" title="试除法——质数的判定"></a>试除法——质数的判定</h3><p>给定一个数字n，在$1 &lt; x &lt; n$之间如果有$n &#x2F; x$能够整除的话，则n不是质数，否则就是质数。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="试除法——分解质因数"><a href="#试除法——分解质因数" class="headerlink" title="试除法——分解质因数"></a>试除法——分解质因数</h3><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="comment">//因为x中最多只包含一个大于根号x的质因子，所以当x大于1时说明这个数就是那个大于根号x的质因子，单独处理</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><p>给定一个数n，遍历数组中的每一个数并把这个数之后的所有该数的倍数删去，每一个元素都执行完之后，那么这个数组中剩下的就都是质数。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素筛法</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性筛法：n只会被它的最小质因子筛掉</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;<span class="comment">//每次把质数和i的乘积筛掉，因为质数乘某一个数一定是合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//primes[j]一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);<span class="comment">//如果是平方数，则不放入结果，因为约数不能重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约数个数与约数之和"><a href="#约数个数与约数之和" class="headerlink" title="约数个数与约数之和"></a>约数个数与约数之和</h3><p>求约数个数的思路为：先通过对一个数分解质因数（分解质因数算法），得到底数和指数，然后通过下列模板中的公式求出约数的个数，求约数之和同理。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck<span class="comment">//分解质因数</span></span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure>

<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>欧几里得算法用于求两个数的最大公约数，也称辗转相除法。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;<span class="comment">//如果b不等于0，则返回a，否则返回gcd(b, a % b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="分解质因数法求欧拉函数"><a href="#分解质因数法求欧拉函数" class="headerlink" title="分解质因数法求欧拉函数"></a>分解质因数法求欧拉函数</h3><p>欧拉函数表示1到n中与n互质的个数，用$\varphi(n)$表示。在求某一个数的欧拉函数时要先对该数分解质因数，即分解为$N&#x3D;p_1^{\alpha_1}<em>p_2^{\alpha_2}</em>…<em>p_k^{\alpha_k}$（$p$表示分解的质因数，$\alpha$表示质因数$p$的个数，即$p$的指数），然后再求欧拉函数$\varphi(N)&#x3D;N</em>(1-\frac{1}{p_1})<em>(1-\frac{1}{p_2})</em>…*(1-\frac{1}{p_k})$,求出来的结果就是与N互质的个数。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套公式即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);<span class="comment">//因为是整除运算，所以欧拉函数需要化简，也就是将上面的欧拉函数的括号中的式子合并</span></span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>筛法求欧拉函数常用于求1到n当中的每一个数的欧拉函数。分解质因数法也可以求出每一个数的欧拉函数，但是该算法中需要把每一个数的都分解质因数，因此花费的大量的时间（$O(N\sqrt{N})$），而筛法求欧拉函数是线性的($O(N)$)，因此时间上是占优势的。</p>
<p>欧拉定理：若a与n互质，则$a^{\varphi(n)}\equiv1(mod\ n)$。</p>
<p>费马定理：若a与n互质且n为质数，则$a^{n - 1}\equiv1(mod\ n)$。</p>
<p><strong>质数n的欧拉函数为n - 1。</strong></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)<span class="comment">//当一个数i可以整除一个质数pj(primes[j],这里用pj表示)，那么说明i是pj的倍数，因此i和pj都可以被pj整除，所以当i*pj时，pj被乘了两次，所以在i*pj分解质因数中pj的指数为2，又因为欧拉函数的公式与分解质因数当中的指数无关，所以i*pj的欧拉函数就是i的欧拉函数乘以pj</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂用来快速的求出来$a^k\ mod\ p$的结果。将指数k转化为二进制数，然后将a拆解，如$4^5$,将5转化为二进制$(101)_2$，那么拆解后得$4^{2^0}*4^{2^2}$，然后求该拆解式中的每一项模p的结果，也就是预处理。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求 m^k mod p，时间复杂度 O(logk)。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>在学习扩展欧几里得算法之前先介绍一下裴蜀定理：裴蜀定理即对于任意一对正整数a，b，那么一定存在非零整数x，y，使得$ax+by&#x3D;(a,b)$（$(a,b)$表示a和b的最大公约数），因为a是$gcd(a,b)$的倍数，b也是$gcd(a,b)$的倍数(说明$a\ %\ gcd(a,b)$和$b\ %\ gcd(a,b)$都为0)，那么$a+b&#x3D;gcd(a,b)<em>(\frac{a}{gcd(a,b)}+\frac{b}{gcd(a,b)})$，所以当$ax+by&#x3D;d$时，它就等价于$gcd(a,b)</em>(\frac{ax}{gcd(a,b)}+\frac{bx}{gcd(a,b)})&#x3D;d$，所以$d$一定是$gcd(a,b)$的倍数，也就是说只有d是$gcd(a,b)$的倍数，该式才会有解，否则无解。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span><span class="comment">//将欧几里得算法展开写</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;<span class="comment">//当b为0时，那么就是求gcd(a, 0)，由于0和任意一个自然数的最大公约数是该自然数本身，所以gcd(a, 0) = a，求解方程ax + by = a得x为1，y为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);<span class="comment">//参数a，b发生翻转，所以x，y也要翻转</span></span><br><span class="line">    y -= (a/b) * x;<span class="comment">//y的推导公式如下图所示</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开后的欧几里得算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E5%85%AC%E5%BC%8F.4hfk4a36lyg0.webp" alt="扩展欧几里得算法推导公式"></p>
<p>$a\ mod\ b&#x3D;a-{\lfloor\frac{a}{b}\rfloor}b$的推导：</p>
<p>​	$a\div b&#x3D;{\lfloor \frac{a}{b}\rfloor …r} \longrightarrow a&#x3D;\lfloor \frac{a}{b} \rfloor b+r \longrightarrow r&#x3D;a-\lfloor \frac{a}{b}\rfloor b &#x3D; a\ mod\ b$。</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>给定一堆两两互质的数$m_1,m_2,m_3,…,m_k$，设$M&#x3D;m_1m_2m_3…m_k$，使得$M_i&#x3D;\frac{M}{m_i}$（$M_i$就是除了$m_i$其他所有$m$的乘积），由于$m$之间两两互质，所以$M_i$就与$m_i$互质，$M_i^{-1}$表示$M_i$模$m_i$的逆（因为$M_i$与$m_i$互质，所以一定存在一个逆元$M_i^{-1}$），有一个线性同余方程组$x\equiv a_1(mod\ m_1),x\equiv a_2(mod\ m_2),…,x\equiv a_k(mod\ m_k)$，使得$x&#x3D;a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}$，可以用扩展欧几里得算法求出逆元，之后带入此公式求出x即可。</p>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>高斯消元一般来说可以在$n^3$时间复杂度之内求解一个包含n个方程和n个未知数的多元线性方程组，可以求出每一个未知数，方程组如下：</p>
<p>$\begin{cases} a_{11}x_1+a_{12}x_2+…+a_{1n}x_n&#x3D;b_1 \ a_{21}x_1+a_{22}x_2+…+a_{2n}x_n&#x3D;b_2 \ …\…\…\a_{n1}x_1+a_{n2}x_2+…+a_{nn}x_n&#x3D;b_n \end{cases}$</p>
<p>该方程组有三种情况：无解、无穷多组解和唯一解。 </p>
<p>将方程组中的系数取出来组成一个n * (n + 1)的系数距阵（包括b），然后对这个矩阵做初等行列变换，操作如下：</p>
<pre><code>1. 把某一行乘一个非零的数（等价于对一个方程两边同时乘一个非零的数）
1. 交换某两行（等价于对方程组中的某两个方程交换位置）
1. 把某行的若干倍加到另一行上去（等价于把一个方程的若干倍加到另外一个方程上去）
</code></pre>
<p>上述三个操作可以把一个一般的方程组变成一个上三角的形式（也称阶梯型），如下所示：</p>
<p>$\left{ \begin{matrix}a_{11} &amp; a_{12} &amp; … &amp; a_{1n} &amp; b_1\ 0 &amp; a_{22} &amp; … &amp;  a_{2n} &amp; b_2 \ . &amp; . &amp; … &amp; . &amp; .\ . &amp; . &amp; … &amp; . &amp; .\ . &amp; . &amp; … &amp; . &amp; .\ 0 &amp; 0 &amp; … &amp; a_{nn} &amp; b_n\end{matrix}\right}$</p>
<p>已知最后一行只有一个未知数，那么就可以依次向上带入求出其他未知数。</p>
<p>如果最终得到的矩阵是一个完美的阶梯型，就会有唯一解，如果不是一个完美阶梯型，分为两种情况，第一种情况中，如果出现方程左边没有未知数右边是非零的情况，这样的情况为无解，第二种情况中，出现了许多零等于零的方程，则有无穷多个解。</p>
<p>高斯消元的算法思路：</p>
<p>枚举每一列c</p>
<pre><code>    1. 在该第c列中找到一个非零且绝对值最大的数所在的一行
    1. 将这行换到顶行，即交换两行，交换之后该行在当前迭代中为第一行，且这行在下一次迭代中不参与任何运算
    1. 将这一行的第一个非零数变成1，也就是该等式同时除以某一个数
    1. 将第c列除了第一行（当前迭代的第一行）的数的其他数全部消为零，也就是从第二行（当前迭代的第二行）开始的每一行等式减去第一行（当前迭代的第一行）等式乘以某一个数，使得该行的第c列为零
    1. 枚举下一列，回到第一步
</code></pre>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;<span class="comment">//c表示列，r表示行</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;<span class="comment">//因为矩阵为浮点类型存在误差，所以判断某一元素是否为0需要建立一个很小的数eps，如果小于eps则为0</span></span><br><span class="line"><span class="comment">//fabs是浮点数的绝对值，abs是整数的绝对值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端，也就是一行中的每一列都做交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1，从最后一列开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)<span class="comment">//如果r &lt; n说明矩阵中存在多行的方程左边全为0的情况，那么该矩阵就不是完美阶梯型，所以存在无解或无穷多个解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)<span class="comment">//因为已经存在多个方程左边没有未知数，所以在这样的情况下，如果该方程的右边不为零，那么就说明无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//由下到上将矩阵化为单位矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )<span class="comment">//j表示列，列比行多一</span></span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>举一个简单的容斥原理的例子，如下图所示的韦恩图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%9F%A6%E6%81%A9%E5%9B%BE.yhuedj9l2uo.webp" alt="韦恩图"></p>
<p>在上图中，要求出三个圆构成的总面积，由于4、5、6、7号区域的面积加了多次，因此需要想办法把这些多加的面积减掉，所以总面积为$S&#x3D;S_1+S_2+S_3-S_1 \cap S_2-S_1 \cap S_3-S_2 \cap S_3+S_1 \cap S_2 \cap S_3$。</p>
<p>当有两个圆的时候总面积为$S&#x3D;S_1+S_2-S_1 \cap S_2$，当有四个圆时总面积为$S&#x3D;S_1+S_2+S_3+S_4-S_1 \cap S_2-S_1 \cap S_3-S_1 \cap S_4-S_2 \cap S_3 - S_2 \cap S_4 - S_3 \cap S_4$</p>
<p>​		$+S_1 \cap S_2 \cap S_3+S_1 \cap S_2 \cap S_4+S_1 \cap S_3 \cap S_4+S_2 \cap S_3 \cap S_4-S_1 \cap S_2 \cap S_3 \cap S_4$。</p>
<p>由此可以观察出规律，每一个式子都是加减交替：第一个加法是一个圆相加，第二个减法是两个圆做交集相减，第三个加法是三个圆做交集相加，第四个减法是四个圆做交集相减…</p>
<p>以此类推，可以得到n个圆的总面积：$(一个圆的和)-(两个圆做交集的和)+(三个圆做交集的和)-(四个圆做交集的和)+…+(-1)^{n-1}*(n个圆的交集)$</p>
<p>由此可以总结出奇数圆的和前面是加号，偶数圆的和前面是减号，即$(-1)^{n-1}$，如上的式子就被称为容斥原理。</p>
<p>总结上述内容，将圆看作一个集合，最终得到容斥原理的公式为：$(-1)^{0}<em>(C_n^1)+(-1)^{1}</em>(C_n^2)+(-1)^{2}<em>(C_n^3)+…+(-1)^{n-1}</em>(C_n^n)$，其中$C_n^m$表示在n个集合中任意选取m个集合做交集的面积和。</p>
<p><strong>$C_n^0+C_n^1+C_n^2+…+C_n^n&#x3D;2^n$，所以上述容斥原理的公式中除了n个集合中都不选以外共有$2^n-1$项。</strong></p>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p>
<p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p>
<p>定理： NIM博弈先手必胜，当且仅当 <code>A1 ^ A2 ^ … ^ An != 0</code></p>
<p>游戏有两个状态，分别为必胜状态和必败状态：</p>
<p>​	先手必胜状态：可以走到某一个必败状态</p>
<p>​	先手必败状态：走不到任何一个必败状态，也就是走到必胜状态</p>
<h3 id="公平组合游戏ICG"><a href="#公平组合游戏ICG" class="headerlink" title="公平组合游戏ICG"></a>公平组合游戏ICG</h3><p>若一个游戏满足：</p>
<ol>
<li>由两名玩家交替行动；</li>
<li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li>
<li>不能行动的玩家判负；</li>
</ol>
<p>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p>
<h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h3><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p>
<h3 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h3><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) &#x3D; min{x}, x属于自然数，且x不属于S</p>
<h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边(也就是说从x出发能够出现k个局面)，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br><code>SG(x) = mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)</code><br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。</p>
<h3 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h3><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br><code>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</code></p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>
<h1 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h1><p>DP问题从两个角度来思考：状态表示和状态计算。</p>
<p>状态就是一个未知数，背包问题一般是两维的，用$f(i,j)$表示，在状态表示中，一般从集合和属性两个角度考虑，集合存的是所有选法的集合，该选法满足两个条件，第一个是只从前i个物品中选，第二个是选出来物品的总体积小于等于j，$f(i,j)$存的就是满足这两个条件所有选法的总价值的最大值，$f(i,j)$是一个数，他表示的是一个集合，这个数表示的是集合当中的某一种属性，属性有最大值、最小值和数量三种，在背包问题中属性是最大值。</p>
<p>状态计算就是考虑$f(i,j)$可以怎么被计算出来，一般来说状态计算表示的是集合的划分，就是对当前集合划分成若干个子集，在背包问题中会把一个集合分为两个集合，分为不含第i个物品的集合（也就是从1到i-1中选，并且总体积不超过j的最大值，可以用$f(i-1,j)$表示）和含第i个物品的集合（所有从1到i中选，并且总体积不超过j而且包含了第i个物品的选法的集合，用$f(i-1,j-v_i)+w_i$表示）,然后在这两个集合中选出一个最大的结果。划分子集的原则：不重复（两个集合中的元素不重复）。不漏（划分之后不能出现某一个元素不存在的情况）。必须要满足不漏的条件，但不重复原则不一定要满足。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/DP.683rgx39pv00.webp" alt="DP"></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1C7411K79w?p=2&vd_source=b5bbffe9121246ff5a92f72d41f859b1">背包问题视频详解</a></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>给定N个物品和一个容量是V的背包，每一个物品有两个属性$v_i$（体积）和$w_i$（价值）,每件物品最多只能用一次或者一次都不用，从这些物品中挑选一些物品，使得挑选的物品总体积小于等于V，让这些物品的总价值尽可能的最大，并求出最大价值。</p>
<p>01背包的特点：每件物品最多只能用一次。</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包的特点：每件物品可以用无限次。</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>每一个物品最多有$S_i$个，并且不同的物品数量不同。</p>
<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>物品有N组，每一组物品有若干个，且每一组最多只能选择一个物品，如在水果这一组，如果选择苹果，那么就不能选择其他水果，在这样的限制下求出能够获得的最大价值。</p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Lee 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Lee 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AF%BC%E8%88%AA/" rel="tag"># 导航</a>
              <a href="/tags/%E5%88%86%E4%BA%AB/" rel="tag"># 分享</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2023/02/15/C++%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" rel="next" title="C++语法基础课">
      C++语法基础课 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">第一章 基础算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.1.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.1.2.</span> <span class="nav-text">归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">1.2.</span> <span class="nav-text">整数二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86"><span class="nav-number">1.3.</span> <span class="nav-text">浮点数二分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6"><span class="nav-number">1.4.</span> <span class="nav-text">高精度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">高精度加法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">高精度减法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95"><span class="nav-number">1.4.3.</span> <span class="nav-text">高精度乘法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95"><span class="nav-number">1.4.4.</span> <span class="nav-text">高精度除法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86"><span class="nav-number">1.5.</span> <span class="nav-text">前缀和与差分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="nav-number">1.5.1.</span> <span class="nav-text">前缀和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%AE%E5%88%86"><span class="nav-number">1.5.2.</span> <span class="nav-text">差分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95"><span class="nav-number">1.6.</span> <span class="nav-text">双指针算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.7.</span> <span class="nav-text">位运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="nav-number">1.8.</span> <span class="nav-text">离散化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E5%90%88%E5%B9%B6"><span class="nav-number">1.9.</span> <span class="nav-text">区间合并</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E4%B9%A0%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">第一章习题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F-1"><span class="nav-number">2.1.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-1"><span class="nav-number">2.1.2.</span> <span class="nav-text">归并排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86-1"><span class="nav-number">2.2.</span> <span class="nav-text">整数二分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">第二章 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.1.</span> <span class="nav-text">单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-number">3.1.2.</span> <span class="nav-text">双链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.2.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="nav-number">3.4.</span> <span class="nav-text">单调栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="nav-number">3.5.</span> <span class="nav-text">单调队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#KMP"><span class="nav-number">3.6.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie%E6%A0%91"><span class="nav-number">3.7.</span> <span class="nav-text">Trie树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="nav-number">3.8.</span> <span class="nav-text">并查集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">3.9.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.10.</span> <span class="nav-text">哈希表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL%E5%AE%B9%E5%99%A8"><span class="nav-number">3.11.</span> <span class="nav-text">STL容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#vector"><span class="nav-number">3.11.1.</span> <span class="nav-text">vector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pair"><span class="nav-number">3.11.2.</span> <span class="nav-text">pair</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">3.11.3.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#queue"><span class="nav-number">3.11.4.</span> <span class="nav-text">queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#priority-queue"><span class="nav-number">3.11.5.</span> <span class="nav-text">priority_queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stack"><span class="nav-number">3.11.6.</span> <span class="nav-text">stack</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#deque"><span class="nav-number">3.11.7.</span> <span class="nav-text">deque</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E4%B8%8Emultiset"><span class="nav-number">3.11.8.</span> <span class="nav-text">set与multiset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map%E4%B8%8Emultimap"><span class="nav-number">3.11.9.</span> <span class="nav-text">map与multimap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bitset"><span class="nav-number">3.11.10.</span> <span class="nav-text">bitset</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA"><span class="nav-number">4.</span> <span class="nav-text">第三章 搜索与图论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">4.1.</span> <span class="nav-text">DFS(深度优先遍历)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS%EF%BC%88%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">4.2.</span> <span class="nav-text">BFS（宽度优先遍历）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E5%92%8C%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">树和图的存储方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-number">4.4.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">dijkstra算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%B4%E7%B4%A0Dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.1.</span> <span class="nav-text">朴素Dijkstra算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E4%BC%98%E5%8C%96%E7%89%88dijkstra%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.2.</span> <span class="nav-text">堆优化版dijkstra算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bellman-ford"><span class="nav-number">4.6.</span> <span class="nav-text">bellman-ford</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPFA"><span class="nav-number">4.7.</span> <span class="nav-text">SPFA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96%E7%9A%84Bellman-ford%E7%AE%97%E6%B3%95"><span class="nav-number">4.7.1.</span> <span class="nav-text">队列优化的Bellman-ford算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%9B%BE%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%B4%9F%E7%8E%AF"><span class="nav-number">4.7.2.</span> <span class="nav-text">判断图中是否存在负环</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Floyd"><span class="nav-number">4.8.</span> <span class="nav-text">Floyd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-number">4.9.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Prim"><span class="nav-number">4.9.1.</span> <span class="nav-text">Prim</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kruskal"><span class="nav-number">4.9.2.</span> <span class="nav-text">Kruskal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">4.10.</span> <span class="nav-text">二分图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E5%AE%9A%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="nav-number">4.10.1.</span> <span class="nav-text">染色法判定二分图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="nav-number">4.10.2.</span> <span class="nav-text">匈牙利算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86"><span class="nav-number">5.</span> <span class="nav-text">第四章 数学知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%A8%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">质数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E2%80%94%E2%80%94%E8%B4%A8%E6%95%B0%E7%9A%84%E5%88%A4%E5%AE%9A"><span class="nav-number">5.1.1.</span> <span class="nav-text">试除法——质数的判定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E2%80%94%E2%80%94%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0"><span class="nav-number">5.1.2.</span> <span class="nav-text">试除法——分解质因数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%9B%E6%B3%95%E6%B1%82%E7%B4%A0%E6%95%B0"><span class="nav-number">5.1.3.</span> <span class="nav-text">筛法求素数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">约数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%95%E9%99%A4%E6%B3%95%E6%B1%82%E7%BA%A6%E6%95%B0"><span class="nav-number">5.2.1.</span> <span class="nav-text">试除法求约数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E4%B8%8E%E7%BA%A6%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">5.2.2.</span> <span class="nav-text">约数个数与约数之和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.3.</span> <span class="nav-text">欧几里得算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.</span> <span class="nav-text">欧拉函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.1.</span> <span class="nav-text">分解质因数法求欧拉函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%9B%E6%B3%95%E6%B1%82%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0"><span class="nav-number">5.3.2.</span> <span class="nav-text">筛法求欧拉函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="nav-number">5.4.</span> <span class="nav-text">快速幂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="nav-number">5.5.</span> <span class="nav-text">扩展欧几里得算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86"><span class="nav-number">5.6.</span> <span class="nav-text">中国剩余定理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83"><span class="nav-number">5.7.</span> <span class="nav-text">高斯消元</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86"><span class="nav-number">5.8.</span> <span class="nav-text">容斥原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="nav-number">5.9.</span> <span class="nav-text">博弈论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NIM%E6%B8%B8%E6%88%8F"><span class="nav-number">5.9.1.</span> <span class="nav-text">NIM游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E7%BB%84%E5%90%88%E6%B8%B8%E6%88%8FICG"><span class="nav-number">5.9.2.</span> <span class="nav-text">公平组合游戏ICG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F"><span class="nav-number">5.9.3.</span> <span class="nav-text">有向图游戏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mex%E8%BF%90%E7%AE%97"><span class="nav-number">5.9.4.</span> <span class="nav-text">Mex运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SG%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.5.</span> <span class="nav-text">SG函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E6%B8%B8%E6%88%8F%E7%9A%84%E5%92%8C"><span class="nav-number">5.9.6.</span> <span class="nav-text">有向图游戏的和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E7%90%86"><span class="nav-number">5.9.7.</span> <span class="nav-text">定理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">6.</span> <span class="nav-text">第五章 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">6.1.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85"><span class="nav-number">6.1.1.</span> <span class="nav-text">01背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">6.1.2.</span> <span class="nav-text">完全背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="nav-number">6.1.3.</span> <span class="nav-text">多重背包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="nav-number">6.1.4.</span> <span class="nav-text">分组背包</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lee"
      src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fc-ssl.duitang.com%2Fuploads%2Fblog%2F202106%2F13%2F20210613235426_7a793.thumb.1000_0.jpeg&refer=http%3A%2F%2Fc-ssl.duitang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1678977005&t=93fbeaf5703aa746a965441eda08d9d0">
  <p class="site-author-name" itemprop="name">Lee</p>
  <div class="site-description" itemprop="description">欢迎来到我的个人网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lhfeiie" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lhfeiie" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/7480862276" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;7480862276" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/m0_60076931?spm=1018.2226.3001.5343" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_60076931?spm&#x3D;1018.2226.3001.5343" rel="noopener" target="_blank"><i class="fa fa-crosshairs fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.acwing.com/user/myspace/index/120932/" title="acwing → https:&#x2F;&#x2F;www.acwing.com&#x2F;user&#x2F;myspace&#x2F;index&#x2F;120932&#x2F;" rel="noopener" target="_blank"><i class="fa a fa-fw"></i>acwing</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">125k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:53</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>




<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/clicklove.js"></script>

</body>
</html>


