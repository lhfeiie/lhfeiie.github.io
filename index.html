<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://example.com">
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/tags/%E9%9A%8F%E7%AC%94/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-算法基础课" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>流程：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.3dxceqg1vy20.webp" alt="快速排序流程"></p>
<p>调整区间做法一（暴力做法）：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E4%B8%80.4vb9hmjtfns0.webp" alt="调整区间一"></p>
<p>建立两个数组a，b分别存储将要排序的数组q。随机取一个x，在q中遍历，小于等于x的值存放在a中，大于x的值存放在b中，然后更新数组q（将a，b两数组的元素存在q中，a在左，b在右）。</p>
<p>调整区间做法二（双指针做法）：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E8%B0%83%E6%95%B4%E5%8C%BA%E9%97%B4%E4%BA%8C.fvi1ths0saw.webp" alt="调整区间二"></p>
<p>在数组中定义两个指针i，j分别指向数组的最左边和最右边，i先开始遍历，当i指向的元素小于x，指针i继续往后遍历，直至遇到大于等于x的元素停下来，接下来遍历指针j，与i的遍历方式相反，遇到小于等于x的元素停下来，然后用swap函数将两个指针指向的元素交换，接下来继续上述操作，直到i和j相遇结束循环，排序成功。</p>
<p><strong>快速排序模板：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//进行递归遍历后，最终为一个元素为一个数组，此时l = r,所以停止递归</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//先将i和j指向空</span></span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];<span class="comment">//&gt;&gt;为位运算，表示二进制右移一位，等价于/2</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);<span class="comment">//每当i和j相遇后就会出现分界，调用递归函数进行下一步的遍历交换，此为左半部分</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);<span class="comment">//同理，此为右半部分,当以此为分界时，x的值还可以取q[l]</span></span><br><span class="line">    <span class="comment">//quick_sort(q, l, i - 1);//也可以用i来表示，但x的值为q[l + r + 1 &gt;&gt; 1]或q[r],防止进入死循环</span></span><br><span class="line">    <span class="comment">//quick_sort(q, i, r);</span></span><br><span class="line">&#125;<span class="comment">//面试考点</span></span><br></pre></td></tr></table></figure>

<p><strong>在上述模板中，如果x取值为q[l + r &gt;&gt; 1]或q[l]，那么递归方式为<code>quick_sort(q, l, j); quick_sort(q, j + 1, r);</code>，如果x取值为q[l + r + 1 &gt;&gt; 1]或q[r]，那么递归方式为<code>quick_sort(q, l, i - 1); quick_sort(q, i, r);</code>。</strong></p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B.57h4seis2sc0.webp" alt="归并排序流程"></p>
<p>与快速排序不同的是，归并排序的分界点是数组的中间值，而快排的分界点是数组中随机的一个点（也可以是中间值）。分界点的作用是将一个数组分为两个数组。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F.3k7f1su09xy0.webp" alt="归并排序方式"></p>
<p>两个指针分别指向两个数组的最小元素（每一个元素都是从小到大排好序的），比较两个指针所指向的元素的大小，把最小的一个元素存入res数组中，然后指向该最小元素的指针向后移动一位继续比较，以此类推，直至有一个指针指向其数组的最终位置，最后将指针未指向终点的数组的剩余元素补进res数组中。</p>
<p>归并排序模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//当数组中的元素为一个时，递归结束</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);<span class="comment">//与快排的递归思想一致，但是这里是将数组递归分为若干个数组，直到一个元素为一个数组为止，执行递归函数下面的语句</span></span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<span class="comment">//当左半边没有循环完，把剩余部分补进tmp数组中</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<span class="comment">//同理，但此为右半边</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<span class="comment">//复制回q数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>单调性与二分的关系：有单调性一定可以二分，可以二分的题目不一定非得有单调性。</p>
<p>二分的本质并不是单调性。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86.2t6ea7gq62e0.webp" alt="二分"></p>
<p>给定一个区间，定义某一种性质，使得区间的右半部分满足该性质，左半部分不满足，整个区间被一分为二，两个部分的边界不相交。二分就可以寻找该性质的边界，既可以寻找图中绿颜色的边界，也可以寻找红颜色的边界，此为二分的性质，二分有两个模板。</p>
<p>模板一：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%B8%80.2hjmnn6u8cs0.webp" alt="二分模板一"></p>
<p>在二分出红色点的情况下，在[l, r]区间确定中间值，判断该中间值是否满足红色区间的性质，若满足，则中间值mid在红色区间内，此时区间[mid, r]是可以取到边界点的，因此在该区间答案是存在的，接下来更新区间为[mid, r]（mid在红色区间内，因为要二分红色区间，所以mid有可能是答案，因此区间要包含mid）。若不满足，则mid在绿色区间内，此时答案一定在区间[l, mid -1],因此更新区间为[l, mid - 1]（因为mid本就不在红色区间内，所以mid本身就不用考虑）。<strong>最终得到的结果为右边界。</strong></p>
<p>模板二：   </p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF%E4%BA%8C.3o7gy9ypz9q0.webp" alt="二分模板二"></p>
<p>与模板一相反，此时二分出绿色点。<strong>最终得到的结果为左边界。</strong></p>
<p><strong>$mid&#x3D;\frac{l+r}{2}$与$mid&#x3D;\frac{l+r+1}{2}$的判断方式：</strong></p>
<p>​	<strong>如果$r &#x3D; mid -1 \quad l &#x3D; mid$时，$mid&#x3D;\frac{l+r+1}{2}$，如果$r &#x3D; mid \quad l &#x3D; mid + 1$时，$mid&#x3D;\frac{l+r}{2}$。红向上(右)取（mid取 $r$，所以 $l + r + 1$），绿向下（左）取（mid取 $l$，所以 $l + r$）。（当 $r$ 与 $l$ 相差为1时更好理解($r - l &#x3D; 1$)，如果不加1，$l$ 更新始终为 $l$，得到的新的区间始终为[l , r], 此时会进入死循环,如果加1，$l$ 会更新为 $r$,此时更新的区间为[r , r],因为左右区间相等，所以停止循环）</strong></p>
<p>整数二分模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)<span class="comment">//l和r在该循环中会时刻更新，因此当l大于等于r时作为循环终止条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;<span class="comment">//可以这样理解，这里的mid + 1相当于对l已经做了上取整操作，所以mid的值不需要再加1(mid = l + r &gt;&gt; 1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;<span class="comment">//此模板找到左边界</span></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;<span class="comment">//这里的l没有做上取整操作，因此在取mid的值时需要加1上取整(mid = l + r + 1 &gt;&gt; 1)</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;<span class="comment">//此模板找到右边界</span></span><br></pre></td></tr></table></figure>

<p>二分算法用于解决查找问题。</p>
<p>当mid满足存在于左半边时，最终二分出的结果为右边界，反之得到的结果为左边界。（<strong>分左得右，分右得左</strong>）</p>
<h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>浮点数二分不需要处理边界，因此不需要考虑 $l + r$ 要不要加1，并且此模板只有一个。</p>
<p>浮点数二分模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)<span class="comment">//当精度特别小的时候就可以停止循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此模板一般用于求浮点数的平方根，也属于查找问题。</p>
<h2 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h2><p>高精度常用于C++语言。</p>
<p><strong>高精度一般用于两个超过C++最长整数范围的加减乘除计算。加减法用于两个大整数之间的运算，乘除法一般用于一个大整数与一个小整数之间的运算，也会出现两个超大整数之间的运算，但用的次数不是很多。</strong></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97%E8%8C%83%E5%9B%B4.6ku0ipk963w0.webp" alt="高精度运算范围"></p>
<p>存取大整数的方法是将每一位存入一个数组当中， 从数组开头开始，将整数从个位开始依次存入，数组末尾元素是整数的最高位。</p>
<h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><p>高精度加法模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span><span class="comment">//返回值类型为vector数组类型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;<span class="comment">//进位 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>在高精度减法中，要考虑A和B谁比谁大，如果A &gt; B，则直接计算结果，如果A &lt; B，则要将AB颠倒过来计算，之后再输出的结果前加负号即可。判断AB的大小需要自己定义函数去判断。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )<span class="comment">//这里是保证A &gt; B，因此只需要遍历到两个数中长度最长的长度，也就是A.size()，t为借位</span></span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;<span class="comment">//减去上一位是否借位的情况，如果有借位，减去的t是1，如果没有借位，减去的t是0</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//这里包含了两种情况，如果t大于等于0，那么t加10余10就是t本身(t永远都是个位数，只不过会出现正负数两种情况，这里(t + 10) % 10既处理了负数的情况，还能解决正数加10的情况)，此时t就是A[i] - B[i]的结果，如果t小于0，那么就说明要向上一位借位，因此要加10，t + 10就是借位后得到的结果，再余10也还是t + 10本身</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;<span class="comment">//如果t小于0，则说明向高一位借位，在下一循环中计算的是高位的减法，由于当前循环中t小于0，因此当前循环的减法向高位借1，所以在下一循环的高位减法中要减去当前循环借的1位，所以t要赋值为1</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;<span class="comment">//t大于等于0，没有借位，因此t为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) 			C.<span class="built_in">pop_back</span>();<span class="comment">//如果A - B得到的是个位数，由于结果输出是在数组中倒着输出，因此高位的0会一起输出，所以要把高位等于0的元素pop出去，以确保输出的是个位数</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h3><p>在高精度乘法中，A是高精度，b是低精度（高精度乘高精度不常考），因此在实现该算法时A中的每一位要乘b的整体，然后计算进位，并不是每一位乘每一位，与我们人类的计算方式是不同的，由于b是低精度，因此b不需要进行字符串转换整型数组，直接将b存入整型变量中即可，这样也更方便实现A中的每一位数乘b的整体。</p>
<p>高精度乘低精度模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )<span class="comment">//从个位开始遍历，当A的长度遍历完之后，有可能会出现进位，因此还要判断超过A的长度之后，t是否为0，若不为0，则向A的最大长度后进位，也就是将t的值放入后一位数组位置中，若为0，则说明不需要进位，因此退出循环得出结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);<span class="comment">//1</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//2</span></span><br><span class="line">    &#125;<span class="comment">//1和2的代码与高精度加法相同，当t为个位数时，除以10为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//可有可无，但为了保险最好加上，有可能会出现多位数0相乘的情况，此时得到的结果只需输出一位0即可</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h3><p>与乘法一样，高精度除以高精度不常考，因此这里只需要考虑高精度除以低精度。</p>
<p>高精度除以低精度模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span><span class="comment">//在高精度除法中，还要返回余数r，因此r在函数参数中定义</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//除法是从最高位开始运算，与其他三种运算方式的起始位置是不同的，因此从高位开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];<span class="comment">//r是上一位除法计算得到的余数，因此在当前循环中r就是遍历到当前数的上一位，因此要乘10让r成为十位数再加上当前数</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);<span class="comment">//然后再将除数放入数组当中，商是b，因为A与b做除法</span></span><br><span class="line">        r %= b;<span class="comment">//保存当前位的余数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());<span class="comment">//除法中得到的结果C数组中数组首元素存放的是最高位，末尾元素存放的是第一位，为了与其他加减乘的存入方式统一，这里要将数组C反转，以便主函数能够正确输出结果，也方便下一语句代码判断末尾元素是否为0（在反转之前第一位存放的有可能是0，因此反转之后就成为了末尾元素）</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前导0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>给定长度为n的数组$a_1,a_2,a_3,…,a_n$，前缀和则表示为$S_i &#x3D; a_1 + a_2 + … + a_i$。前缀和下标一定要从1开始，这样例如当求区间[1, 10]之间的和时，只需求$S_{10} - S_0$即可($S_0 &#x3D; 0$)。前缀和相当于高中的数列求和。（$S_i &#x3D; S_{i - 1} + a_i$）</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维前缀和</span></span><br><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p><code>ios::sync_with_stdio(false);</code>可以提高cin的读取速度，但不能使用scanf读入。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.al9ojtpkbs8.webp" alt="二维前缀和"></p>
<p>二维前缀和中，如上图所示，$a_{ij}$表示中间的一点，$S_{ij}$表示图中阴影部分所有元素的和，也就是左上角所有元素的和。</p>
<p>如上图所示，要求出图中最小的正方形区域内的和，设小正方形左上角的坐标为($x_1$, $y_1$),右下角坐标为($x_2$, $y_2$)，那么小正方形区域内的和为：$S_{x_2y_2} - S_{x_2(y_1 - 1)} - S_{(x_1-1)y_2} + S_{(x_1 - 1)(y_1 - 1)}$（由于$S_{(x_1 - 1)(y_1 - 1)}$减了两次，因此还要加上多减的一次）。($S_{ij} &#x3D; S_{(i - 1)j} + S_{i(j - 1)} - S_{(i - 1)(j - 1)} + a_{ij}$)</p>
<h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>差分是前缀和的逆运算，给定长度为n的数组$a_1,a_2,…,a_n$，然后构造b数组$b_1,b_2,…,b_n$，使得$a_i&#x3D;b_1+b_2+…+b_i$，也就是a数组是b数组的前缀和，由此可得出$b_1&#x3D;a_1,b_2&#x3D;a_2-a_1,b_3&#x3D;a_3-a_2,…,b_n&#x3D;a_n-a_{n-1}$，此时b就称为a的差分，二维差分也是此思想。</p>
<p>假设要在[$a_l$,$a_r$]内统一加c，如果使用循环所花费的时间复杂度为O(n),若想让时间复杂度变为O(1)，此时就可以通过b数组来完成，因为$a_l&#x3D;b_1+…+b_l,a_r&#x3D;b_1+…+b_l+…+b_r$，如果要让区间[$a_l,a_r$]内每一个元素加c，只需给$b_l+c,b_{r+1}-c$即可，由于$b_l+c$导致$a_r$之后所有a数组元素加c，因此$b_{r+1}-c$将$a_r$之后的所有元素再减c（不包括$a_r$），这样就不会影响所求区间以外的值了，这样时间复杂度就变为了O(1)。 </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维差分</span></span><br><span class="line">给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="number">1</span>] -= c</span><br><span class="line">    </span><br><span class="line"><span class="comment">//二维差分</span></span><br><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c<span class="comment">//S[x1, y1] += c是对二维矩阵的右下部分所有元素加c，此时要将与所求区间内无关的元素多加的数值减去，使其成为最开始的值，有一片区域减了两次c，所以要加回来一次</span></span><br></pre></td></tr></table></figure>

<h2 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h2><p>第一类双指针：</p>
<p>​	有两个序列，每一个指针指向一个序列。</p>
<p>第二类双指针：</p>
<p>​	两个指针指向一个序列。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E7%B1%BB%E5%9E%8B.6u3evz6drks0.webp" alt="双指针算法类型"></p>
<p>双指针算法是O(n)的。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++ ;<span class="comment">//check(i, j)表示根据题目满足某一性质</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 具体问题的逻辑,依据题目要求，在这里还要加一些代码</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    (<span class="number">1</span>) 对于一个序列，用两个指针维护一段区间</span><br><span class="line">    (<span class="number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure>

<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算用于求n的二进制表示中第k位是几。首先将n右移k位(n &gt;&gt; k)，然后在求出右移后的值的个位(n &gt;&gt; k &amp; 1)，所得个位就是第k位。如$n&#x3D;15$时，二进制表示为$(1_31_21_11_0)_2$（1的下标表示当前的1处于第几(k)位），二进制中左边为最高位，右边为最低位,因此若要输出某一十进制的二进制表示，因从最高位开始循环输出<code>n &gt;&gt; k &amp; 1</code>。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字: n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n<span class="comment">//-n表示n的补码（取反加1）</span></span><br></pre></td></tr></table></figure>

<p><code>lowbit(n)</code>表示返回n的二进制表示最右边的1之后的表示，如某一二进制为$1010$,则lowbit返回$10$,二进制为$101000$,则返回$1000$。lowbit一般用于求二进制中出现1的次数。</p>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><p>这里特指整数的离散化。在$0-10^9$的范围内随机取出几个不连续的整数，然后将这些取出来的整数按从小到大的顺序映射到一个数组中。如在范围内取出五个整数1,3,100,2000,500000，然后把这五个数放在一个数组中，使得1对应的数组下标是0，3是1，100是2，2000是3，500000是4，也就是把这些值映射到下标。如果取出的数有重复的，那么需要去重。然后再算出某一x值在这部分数组中的下标是多少。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素，unique表示将数组中的所有重复元素去重，然后返回去重后的新数组的末尾，在新数组的末尾后面都是重复出现的元素，在unique中返回的是去重后新数组的末尾，在此末尾后还有一些之前重复出现的元素，那么erase中第二个参数就表示整个数组（去重后的新数组加重复出现的元素）的末尾，所以就表示删除重复出现的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>求离散化问题时要根据题意将前缀和结合起来。</p>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><p> 给定n个不同的区间，将这n个区间所有有交集的区间进行合并，然后输出合并之后的区间个数。如果两个区间只有端点相交（第一个区间的末尾元素和第二个区间的首元素相等），这样的区间也可以合并。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span><span class="comment">//PII为二元组，segs.first存放区间的左端点，segs.second存放区间的右端点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//二元组的排序是优先对二元组中的first排序，如果first都相等，那么就对second排序</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//初始区间，设置边界值，因为最开始还没有遍历区间，所以设置的左右边界都是同一值，只是将该左右边界放在数轴的最左边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)<span class="comment">//判断当前区间的右端点是否与下一个区间有交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//放入答案的区间不能是初始区间，因此需要判断将新的非初始区间放入答案</span></span><br><span class="line">            st = seg.first, ed = seg.second;<span class="comment">//更新区间的左右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);<span class="comment">//有交集，更新右端点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) <span class="comment">//防止区间为空</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//将最后一个区间加进去，这里指合并后的新区间</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第一章习题"><a href="#第一章习题" class="headerlink" title="第一章习题"></a>第一章习题</h1><h2 id="排序-1"><a href="#排序-1" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/activity/content/problem/content/819/">快速排序</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x = q[l];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/788/">第k个数</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; q[k - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/789/">归并排序</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l, j = <span class="number">0</span>; i &lt;= r; i ++ , j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/790/">逆序对的数量</a></p>
<p>解题思路：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%80%86%E5%BA%8F%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F.5mk2accbqks0.webp" alt="逆序对的数量"></p>
<p>出现逆序对总共有三种情况，第一种在左半边内部，第二种在右半边内部，第三种一个在左半边一个在右半边，第三种情况包含前两种情况，因为第三种情况中的两个数组是最后一次递归得到的结果，此时两个数组分别已排好顺序，当L数组中有一个元素是严格大于R数组中的某一个元素时，则L数组中的这个元素之后的元素都是大于R数组中的某一个元素，所以以上图R[j]元素为基准，L数组中大于R[j]的个数总共有$mid - i + 1$个。在R数组中还会出现与R[j]相同的情况，将这些情况的数量相加就是最终的答案。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> i = l, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res += mid - i + <span class="number">1</span>;</span><br><span class="line">            tmp[k ++ ] = q[j ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++ , j ++ ) q[i] = tmp[j];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整数二分-1"><a href="#整数二分-1" class="headerlink" title="整数二分"></a>整数二分</h2><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/791/">数的范围</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">做法一：</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= k) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[r] != k) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= k) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">做法二：</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    <span class="keyword">while</span> (k -- )&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; x) l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &gt; x) r = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> l = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第二章-数据结构"><a href="#第二章-数据结构" class="headerlink" title="第二章 数据结构"></a>第二章 数据结构</h1><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>在笔试中一般考察数组模拟链表，动态链表（结构体加指针）在创建节点时非常耗时，常在面试中考察。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;<span class="comment">//链表结点结构</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Node</span>();<span class="comment">//创建节点</span></span><br><span class="line"><span class="comment">//上述为动态链表</span></span><br></pre></td></tr></table></figure>

<p>单链表在笔试或算法题中用的最多的是邻接表。邻接表的应用是存储树和图。双链表用来优化某些问题。</p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表中，最开始有一个头节点，该头节点最开始指向空节点，每次会往里插入新元素，每一个节点都会存入节点的值和指向下一节点的next指针。</p>
<p>在数组模拟单链表中，需要定义e[N]存放某个节点的值，ne[N]表示next的指针，它存放的值是e数组某一节点元素的下一节点元素的下标，也就是将节点所处的位置作为ne数组的值，ne的下标表示当前节点的位置，存放的值表示指向下一节点的位置，最后一个节点所指向的节点为空节点，因此该空节点存放的值为-1，也就是说该空节点不指向任何下一个节点所以在此空节点中，ne存放的值为-1。e数组中存放的值是节点的值，下标表示当前节点所处的位置。这里的数组都是整型数组。 在链表中还需要定义一个整型变量head来指向头节点，与ne性质类似。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E7%94%A8%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E5%8D%95%E9%93%BE%E8%A1%A8%E5%9B%BE%E8%A7%A3.51vvew6d9rg0.webp" alt="用数组模拟单链表图解"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点，相当于一个指针</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;<span class="comment">//一开始创建n个节点，由于最开始这n个节点都没有用到，因此idx指向头节点，当要使用节点存放值的时候，idx就指向下一个没有用到的节点，上一个节点就分配出去</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;<span class="comment">//初始化链表中没有任何节点，因此头指针指向空</span></span><br><span class="line">    idx = <span class="number">0</span>;<span class="comment">//表示当前可以从创建好的未用到的n个节点的0号节点（头节点）开始用，可以理解为idx创建节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;<span class="comment">//将要插入的节点指向head指向的节点，然后将head指向要插入的节点，所有的插入操作结束之后，由于当前的idx被分配出去，因此idx指向下一个没有用到的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];<span class="comment">//直接将head指向当前节点的下一节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];<span class="comment">//ne[ne[k]]表示下标为k的节点的下一个节点的下一个节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将x插入下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>双链表每一个节点有两个指针，一个指针指向前一个节点，一个指针指向后一个节点。双链表没有指向的空节点，因为每一个节点都有指向的前后指针，因此初始链表是两个节点，并且这两个节点相互指向构成一个环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;<span class="comment">//0号节点和1号节点已经被分配了出去，因此idx指向第三个未使用的节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span><span class="comment">//如果想在a节点的左边插入节点，那么就相当于在a节点的左节点的右边插入节点，所以只需将参数a改为l[a]即可</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//先赋值</span></span><br><span class="line">    l[idx] = a, r[idx] = r[a];<span class="comment">//插入新节点的右指针指向节点a的下一节点，左指针指向节点a本身</span></span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;<span class="comment">//设置完新节点左右指针的指向后，由于要构成双链表，因此要更新新节点左右两边节点的指向，新节点左边的节点的右指针要指向新节点，右边的节点的左指针也要指向新节点</span></span><br><span class="line">    <span class="comment">//双链表的插入节点时先将新节点的左右指针赋值，在更改新节点的左右节点的指针指向</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];<span class="comment">//将要删除的节点的右节点的左指针指向要删除的节点的左指针指向的节点</span></span><br><span class="line">    r[l[a]] = r[a];<span class="comment">//将要删除的节点左节点的右指针指向要删除的节点的右指针指向的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是先进后出的数据结构。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;<span class="comment">//将所有元素插入栈中后，最先进入栈的元素在最栈底，最后进的元素在栈顶，因此弹出元素是在栈顶弹出，所以栈是先进后出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;<span class="comment">//从栈顶弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)<span class="comment">//如果大于0说明栈中有元素，不为空，否则为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是在队尾插入元素，队头弹出元素，先进先出。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">普通队列：</span><br><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;<span class="comment">//将队头指针向后移动一位，也就是将队头元素弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];<span class="comment">//取出队头元素 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)<span class="comment">//队头指针小于队尾指针说明队列不是空的，队头指针和队尾指针有可能相等，此时说明队列中还存在最后一个元素，当在此情况下hh ++ 之后弹出该元素，此时hh &gt; tt，则说明队列为空</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">循环队列：</span><br><span class="line"><span class="comment">// hh 表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>给定一个序列，求序列中的每一个数的左边或右边离它最近而且比它大或小的数在什么地方。这样的问题一般用单调栈来解决。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;<span class="comment">//删除不满足条件的栈顶元素</span></span><br><span class="line">    stk[ ++ tt] = i;<span class="comment">//在这里已经将不满足条件的栈顶中删除，因此i可以入栈</span></span><br><span class="line">&#125;<span class="comment">//与双指针类似</span></span><br></pre></td></tr></table></figure>

<p>在单调栈问题中，i每往右边移动一个数时，就给栈里面加入一个元素。也就是说当i指向$a_i$时，此时栈里的元素为$a_1, a_2, … ,a_{i - 1}$,每一次寻找从栈顶开始往后找，直到找到第一个结果为止。当然在栈里的所有元素都要保持严格的单调性，要么单调上升，要么单调下降（上升和下降指的是栈中的元素按大小排列方式），也就是说，根据题目要求，如果要查找i的左边第一个比它小的数，那么在栈中的一些满足条件的元素永远都不会作为结果输出，因为只查找离i最近的且满足条件的元素。举个例子，在栈中$a_3&gt;&#x3D; a_5$,由于要在栈中查找某一最近的元素小于$a_i$,已知$a_3 &lt; a_i$且$a_3&gt;&#x3D;a_5$，因为$a_5$在$a_3$的右边离$a_i$最近，所以只取$a_5$ 而不取$a_3$,因此在这样的情况下$a_3$是永远都不会作为结果输出，所以在这样的例子下，$a_3$就可以被删掉，把这样类似的情况的元素都删除掉之后，剩下的栈里的元素都形成一个严格单调上升的情形。</p>
<p>总结一下：在查找离i最近的且比它小的元素时，那么在插入栈的时候栈顶元素不能比i大，如果比i大那么就删除栈顶元素，直到有一个栈顶元素比i小，则这个栈顶元素就是离i最近且比它小的元素，然后i入栈，继续遍历数组中的下一个元素（i + 1）循环上述操作。如果要查找离i最近且比它大的元素，反过来即可。</p>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列与单调栈的思路相同。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口，也就是检查窗口里的第一个元素是否大于队头元素，如果成立，则需要将头指针向后移动一位以保证以头指针处于窗口的第一个位置（队列和窗口中存放的是数组下标，因此是有顺序的）</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单调栈的问题中，栈里存放的是输入的值，可以不需要建立辅助数组，而单调队列问题中队列里存放的是数组下标，因此要先建立数组把输入的值存进去，然后遍历数组入队。</strong></p>
<h2 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h2><p>KMP一般用来解决字符串匹配问题。 </p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：<span class="comment">//next数组中每一个元素存放的是以依次遍历模式串中的某一位i作为终点（next[i]），然后从模式串的开头到此终点查找最长的前缀和后缀相等（比如一个字符串&quot;ababa&quot;,它的最长前缀和后缀相等为3，因为前缀和后缀的&quot;aba&quot;是相等的且长度为3(将这样最大前缀后缀相等的长度存入next[i])，假设一个字符串长度为i，然后找到其前缀和后缀最长相等的子串，长度为j，那么前缀的长度为1到j,后缀的长度为i - j + 1到i，并且长缀后缀相等(next[i] = j)），然后将这个长度存入next数组中对应的位置i中,next数组存放的是以模式串某一位置为终点的最长前缀和后缀相等，与长文本没有关系</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )<span class="comment">//ne[1]可以不用考虑，因为当第一个字母失败了（查询最长长度），只能从0开始，所以ne[1]永远都为0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;<span class="comment">//查找模式串每一个位置（作为终点）的前面的最长前缀和后缀相等的长度，将这样的长度存入next数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )<span class="comment">//每一次匹配模式串要在长文本前面一位</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];<span class="comment">//当出现不匹配的时候，ne[j]存放的是以模式串当前j的位置为终点的最长前缀和后缀相等的长度，更新j并且保证这样长度的内容与长文本的内容是相等的，也就是说出现不匹配的情况，将模式串往后移动，然后继续判断下一个位置是否匹配，如果不匹配，继续移动，直到模式串的全部内容与长文本中的某一段内容匹配或者j退无可退的时候（j退到了起点，说明模式串的内容与长文本不匹配到），退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;<span class="comment">//如果该位置匹配，那么模式串移动到下一位置，等待在长文本的下一个位置（下一循环）继续匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j == m)<span class="comment">//m是模式串的长度，如果j和m相等，说明匹配成功</span></span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];<span class="comment">//匹配成功后，j往后退一步继续寻找长文本中下一个能够匹配的字符串片段</span></span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这里强调一下，每次判断是否匹配时，长文本的位置是i，模式串的位置是j + 1。</p>
<h2 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h2><p>trie树是用来高效地存储和查找字符串集合的数据结构。</p>
<p>trie树存储字符串的方式是从根节点开始，查找字符串中每一个字符是否在树结构中存在，若不存在则创建节点将字符存进去，若存在则直接利用不需要再次创建，第一个字符串存储成功之后，存储第二个字符串也是从根节点开始，遍历字符串字符，若树结构中存在，则不需创建直接利用，否则创建新节点。每一次存储下一个字符串时，都要从根节点开始查找存储。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/Trie%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.55lvr89ejrg0.webp" alt="Trie树存储结构"></p>
<p>所有字符串存储结束之后都要在每一个字符串结尾做一个标记来表明一个字符串，如果不标记则无法判断树结构中有哪些字符串。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/Trie%E6%A0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%87%E8%AE%B0.406xugkf9360.webp" alt="Trie树字符串标记"></p>
<p>以上是字符串的存储，接下来是字符串的查找，查找每一个字符串都要从树的根节点开始依次查找，每当查找到一个字符，就继续寻找下一个节点查找下一个字符，如果下一个字符不存在则说明查找失败，如果字符串中的每一个字符都查找到，当查找的最后一个字符在树结构中没有标记，也属于查找失败，因为在存储每一个字符串的时候都要在存储后的字符串结尾字符添加标记表示树结构中存在这样的字符串，因此就算在查找字符串中的每一个字符都成功的查找到，但这个字符串的结尾字符没有被标记，所以说明该树结构不存在这样的一个字符串，所以说明没有在树结构中查找到这样的字符串。<strong>成功查找到字符串需要满足两个条件：1. 字符串的每一个字符都能够在树结构中查找到。2. 该字符串的结尾字符在树结构中有标记。</strong></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点，该数组第一个中括号表示该节点的上一个节点的idx值，第二个中括号表示要存入的所有字符串当中，出现最多字符的个数（也就是存在某一个字符串，它的字符串中的每一个字符都不一样，比如要存入树结构的字符串都是小写字母，那么会有一种最长的字符串长度是26，因为有26个不同的小写字母）,son[p][u]表示p节点的第u个儿子节点，也就是说第一个中括号表示某一个节点，第二个中括号表示该节点的第几个子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量，相当于做标记</span></span><br><span class="line"><span class="comment">//idx与链表中的idx一样，表示可以用到的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;<span class="comment">//每次存入新的字符串都要从根节点开始遍历存储</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;<span class="comment">//将遍历到的字符映射成整型数字，为了表示数组下标</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;<span class="comment">//如果在树结构中没有这样的字符，则创建节点并存入字符，也就是在当前节点创建一个子结点</span></span><br><span class="line">        p = son[p][u];<span class="comment">//走到下一个节点 </span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;<span class="comment">//做标记，表示树结构中存在这样的字符串</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果要查找的字符串中的某一字符在树结构中的当前路径的下一节点不存在，则说明查找失败</span></span><br><span class="line">        p = son[p][u];<span class="comment">//否则走到下一节点，进入下一循环继续查找下一字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];<span class="comment">//返回以某一字符结尾的单词个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是面试中常考的算法，因为该算法比较考验考生的思维能力。</p>
<p>并查集用来快速的将两个集合合并或询问两个元素是否在一个集合当中。并查集可以在近乎O(1)的时间中完成这两个操作。</p>
<p>每一个集合通过一个树的形式来维护（不一定是二叉树）。树根节点的编号就是当前集合的编号，每一个点都存储它的父节点。当想求某一点是属于哪一个集合时，根据这个点的父节点是否属于树根，若不是树根继续往上找，直到找到树根为止，那么该某一点属于的集合编号就是这个树根的编号。</p>
<p>合并两个集合：在两个集合中选中任意一个集合，将其树根节点连接到另一棵树的根节点，使得其中一棵树是另一棵树的儿子或父亲，完成合并。</p>
<p>在查找某一节点属于哪一个集合的操作时，一旦找到它的根节点，那么将该某一结点的查找到根节点的路径当中经过的所有结点（包括该某一节点）都指向根节点，这样在第二次要查找这些指向根节点的其中一个节点时只需走一步即可查找到集合的编号，大大缩减了查找的时间（O(1)），也就是对查找操作做出的优化。此优化操作称为路径压缩。</p>
<p>并查集还有另外一个优化是按秩合并，但此优化效果并不明显，一般常使用路径优化。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：<span class="comment">//常用于集合的合并</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点（）根节点，这里同时存在路径压缩</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);<span class="comment">//如果x不是根节点，那么就让它的父节点指向祖宗节点，这里的递归可以理解为先找到每一个x的根节点，然后将每一个x的父节点指向根节点，即路径压缩</span></span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;<span class="comment">//查找根节点，也就是集合编号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;<span class="comment">//一开始每一个节点都指向自己</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);<span class="comment">//找到a节点和b节点的根节点，然后将任意一个根节点作为另一个节点的父节点或子节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：<span class="comment">//常用于查询某一集合的节点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量，也就是说如果要查找某一集合中某一节点所在的集合的点的数量，那么需要找到该节点的根节点，因为集合的数量只存储在根节点中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;<span class="comment">//最开始每一个集合只有一个点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];<span class="comment">//两个集合合并之后，他们的集合的点的数量要相加</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], d[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">            d[x] += d[p[x]];</span><br><span class="line">            p[x] = u;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        d[i] = <span class="number">0</span>;<span class="comment">//最开始是一个节点为一个集合，所以距离都为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">    d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure>

<p><strong>并查集的核心就是find()函数。</strong></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆的基本操作：</p>
<ol>
<li>插入一个数</li>
<li>求集合当中的最小值</li>
<li>删除最小值</li>
<li><strong>删除任意一个元素</strong></li>
<li><strong>修改任意一个元素</strong></li>
</ol>
<p>4和5在STL容器中的堆是没法直接实现的。而在手写堆的数据结构中是可以直接实现的。</p>
<p>堆是一个二叉树或完全二叉树结构。存储方式是用一个一维数组来存储，一号点是根节点，每一个节点x（数组下标）的左儿子是2x，右儿子是2x加一，依次存入一维数组当中。这里的x指的是节点存入数组的下标，并不是存入的具体的值。</p>
<p>小根堆：每一个节点都是小于等于左右儿子的，则根节点是整个堆结构中的最小值。最下面的一层是整个小根堆中的每一层的最大值。</p>
<p>堆的两个操作：</p>
<pre><code>1. down(x)：把某一个节点往下调整
1. up(x)：把某一个节点往上调整
</code></pre>
<p>堆的五个操作完全可以用down()和up()两个函数组合起来。</p>
<p>以小根堆为例，down()函数表示，如果某一个节点的值变大了，那么需要把这个节点下沉，也就是依次对它的两个儿子的最小值交换，直到还原为小根堆的结构为止。up()函数则与之相反，但在小根堆的结构当中只需要依次对它的父节点进行交换即可，它的兄弟节点不需要参与进来。</p>
<p>上述描述见下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%A0%86%E5%9B%BE%E8%A7%A3.10htkpyc4af4.webp" alt="堆图解"></p>
<p>插入元素是在整个堆的最后一个元素插入，然后把该插入的值不断往上移动（up()函数）以保持小根堆或大根堆的状态。求堆的最小值（小根堆）或最大值（大根堆）只需要找到根节点即可。</p>
<p>如果想删除一个最小值，在删除该最小值后用整个堆里的最后一个元素覆盖到堆顶（根节点），然后让堆的总个数减一，最后将该覆盖后的节点值不断往下移动（down()函数）以保持堆的状态。不直接删除最小值的原因是因为整个堆是通过一维数组来维护的，因此根节点很难删除，所以通过删除最后一个节点来间接的删除根节点，删除之后只需要将数组的长度减一即可。</p>
<p>删除任意元素k与删除最小值类似，但是需要判断它变化的值是变大还是变小来决定需要调用down()函数还是up()函数，因此在删除元素后，同时输入down()和up()两个函数让系统来判断，两个函数只有其中一个会被调用。</p>
<p>修改任意元素与删除任意元素类似，在修改一个元素后，同样输入两个函数。</p>
<p>堆的操作代码详解见下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%A0%86%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3.5bvyeatn0k00.webp" alt="堆操作详解"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);<span class="comment">//交换两个元素插入的位置</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);<span class="comment">//两个元素在第几个点插入的位置交换后，还要将它们是第几个插入的进行交换</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);<span class="comment">//交换堆中两个元素</span></span><br><span class="line">&#125;<span class="comment">//总结，在堆的交换操作中，不仅要把两个节点的值交换，还要把他们所处的位置进行交换，将他们所处的位置交换后，它们是第几个插入的元素也要进行交换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span><span class="comment">//这里的参数u并不是节点里存放的值，而是一维数组存储每一个节点的数组下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;<span class="comment">//u * 2表示左儿子，然后找到两个节点的最小值</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;<span class="comment">//u * 2 + 1表示右儿子，与上同理</span></span><br><span class="line">    <span class="comment">//上面两个if语句表示找寻某一位置的节点和它的左右两个儿子节点中的最小值</span></span><br><span class="line">    <span class="keyword">if</span> (u != t)<span class="comment">//如果u不等于t，说明在查找三个节点的最小值之前，根节点不是最小值</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);<span class="comment">//交换两个值</span></span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//这里的t指的是位置，不是存储的值，上面的交换操作也只是交换了值，并没有交换位置，此时u成为了最小值，t存储的最大值，然后递归将此最大值继续下移</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])<span class="comment">//u / 2表示u节点的父节点并且该点存在（大于0），同样是找到最小值并赋值给父节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;<span class="comment">//相当于除以2，交换操作已经结束，因此位置需要移动到父节点的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);<span class="comment">//在一开始已经将输入的各个元素存入一维数组中，此时的一维数组可以理解为已经属于一个堆的结构，只不过还没有进行排序</span></span><br></pre></td></tr></table></figure>

<p><strong>存储堆元素的一维数组下标从1开始。</strong></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表：</p>
<pre><code> 1. 存储结构
  	1. 开放寻址法
  	1. 拉链法
 1. 字符串哈希方式
</code></pre>
<p>哈希表用来把一个特别大的空间映射到一个小空间中，例如大空间的大小为$10^9$，哈希表的数组长度大小为$10^5$，要将大空间的数映射到哈希表中，只需要将大空间中的每一个数与$10^5$取模（$x % 10^5$）存入哈希表相应的位置中即可,哈希表的数组长度一般取为质数，因为这样出现的冲突概率是最小的，因此最接近并且大于$10^5$的质数是$10^5 + 3$，因此哈希表的数组长度取为$10^5 + 3$。哈希表在存储的过程中会出现多个不一样的数映射到哈希表中的同一个数，这就出现了冲突，因此需要处理这样的冲突。</p>
<p>处理冲突的方式有两种，第一种为拉链法，首先开一个一维数组用来存储所有的哈希值，在哈希的过程中会出现两个不同的数放在一维数组中的同一个元素中，所以要处理这样的冲突，也就是将一维数组中的每一个元素看作一个槽，用来存放哈希之后的数字，在每一个槽中都拉一条链，用来存储这个槽上当前有的所有数，当出现冲突时，只需在这条链的后面加入这个数即可，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8B%89%E9%93%BE%E6%B3%95%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E6%96%B9%E5%BC%8F.35nzeivguik0.webp" alt="哈希表拉链法处理冲突方式"></p>
<p>在每一个槽后面拉的一个链就是单链表。</p>
<p>在算法题中，哈希表只有插入和查找操作，一般没有删除操作。如果必须要实现删除操作，一般不会真的把某一数删除，而是开一个布尔数组，将哈希表中要删除的数做一个标记即可。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line">	<span class="comment">//e[N], ne[N], idx都是单链表中的内容，因为每一个槽都要连接一条链用来存放出现冲突的数，所以会用到单链表结构，h[N]是哈希表数组长度，h[N]中每一个元素相当于单链表的头节点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h)<span class="comment">//在一开始建立哈希表数组时要使用memset()将每一个数组的值改为-1，因为哈希表中的每一个元素相当于不同的单链表的头指针，因此在初始化时每一个头指针都要指向空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;<span class="comment">//x有可能是负数，需要将其转换为正数 </span></span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;<span class="comment">//单链表的插入方式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历单链表，查询要找的值</span></span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<span class="comment">//null是定义的一个值，一般是超过int型数据范围之外的一个值，比如const int null = 0x3f3f3f3f（一般设置最大值就是这个值）.该循环一定是可以停止的，因为哈希表的数组长度是题目数据范围的两倍，所以哈希表中一定会有没有存放的位置用来结束循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;<span class="comment">//如果t之后的所有元素都不是空位，那么循环从头开始继续查找空位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;<span class="comment">//开放寻址法中的find函数表示如果该数在哈希表中存在，那么返回该数在哈希表中所在的位置，如果该数不存在，则返回该数应该存放在哈希表中的位置</span></span><br></pre></td></tr></table></figure>

<p>开放寻址法只开了一个一维数组，不存在单链表，但是数组的长度一般要开到题目数据范围的2-3倍，这样的范围出现冲突的概率更小，同样是质数。如题目的数据范围是$10^5$,那么哈希表的数组长度为$2*10^5$,因为要取质数，所以最近的质数为$2 * 10^5 + 3$。</p>
<p>开放寻址法处理冲突的方式是从一维数组的第k位开始找空位，如果第k位没有空位，那么继续往后查找，直到找到第一个有空位的位置插入，查找操作也是如此。在查找到某一数时，如果想删除它，和拉链法的做标记相同。</p>
<p>字符串哈希：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];<span class="comment">//处理前缀字符串的哈希值</span></span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;<span class="comment">//计算P的i次方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串哈希又称字符串前缀哈希法。例如有一串字符串str的内容为”ABCABCDEFYXCACWING”，那么哈希之后在哈希表h中存储的方式为，h[0] &#x3D; 0, h[1] &#x3D; “A”, h[2] &#x3D; “AB”, h[3] &#x3D; “ABC”, h[4] &#x3D; “ABCA”,以此类推，也就是在哈希表数组中，数组下标为几，那么该数组位置所存放的内容就为字符串str中的前几个字符，所以称为字符串前缀哈希法。注意哈希表h数组每一个元素存放的不是字符串，而是对应前缀字符串的哈希值，因此在存放之前要对该前缀字符串求哈希值。</p>
<p>定义某一前缀的哈希值：</p>
<p>​	首先把一个字符串看成是一个p进制的数。举例：加入要求一个前缀字符串”ABCD”的哈希值，那么先把这个字符串看作p进制的数，该字符串一共有四个字母，那么看成四位（前缀字符串有几个字母，就看做几位），第一位数是A，第二位数是B，第三位数是C，第四位数是D。接下来对每一个字母赋值，按照A到Z（1到26）的顺序来赋值，那么A为1，B为2，C为3，以此类推。那么字符串”ABCD”就可以看作$(1_32_23_14_0)_p$,所以它对应的十进制的数就是$1<em>p^3 + 2</em>p^2 + 3<em>p^1 + 4</em>p^0$（这就是预处理前缀字符串的哈希值，就是<code>h[i] = h[i - 1] * P + str[i]</code>），那么就可以通过这样一个方式将字符串转换为数字。由于字符串的长度有可能会非常长，那么转换的数字也会非常大，这样非常大的数是不好存储的，所以还要对求得的每一个哈希值模一个比较小的数Q，然后就可以通过取模把整个数字映射到从0到Q-1的一个数。</p>
<p>​	总结：定义前缀哈希值时，首先把字符串看作p进制的数，然后根据字符串字母的个数定义位数，之后将该p进制的数转换为十进制数，最后对该十进制数取模，通过这样一个方式就可以把任何一个字符串映射到从0到Q-1之间的数。</p>
<p>​	注意：</p>
<pre><code>      1. 在一般情况下不能把某一个字母映射成0
      2. 当$p=131或p=13331$,$Q = 2^&#123;64&#125;$时，有99.99%的概率是不会发生冲突的。在数字哈希的问题中是可以容忍冲突的，但在字符串哈希中是假定哈希的情况是最好的，不存在冲突的问题。
</code></pre>
<p>字符串哈希数字的方式如下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%B9%E5%BC%8F.7bxlg7916qw0.webp" alt="字符串哈希数字的方式"></p>
<p>求字符串子串的哈希值(如下图所示)：</p>
<p>​	假设要求str字符串L到R之间的子串的哈希值，那么h[L - 1]为前缀为1到L - 1的字符串，h[R]为前缀为1到R的字符串。先将字符串转换为p进制的数，那么在str字符串这一段中左边为高位，右边为低位（这里指的是p进制的高位和低位）。然后分别找到h[L - 1]和h[R]的高位和低位，在h[R]中，前缀为R的字符串最左边为第$R-1$位（$p^{R - 1}$），最右边为第0位($p^0$)。在h[L - 1]中，前缀位L - 1的字符串最左边为第$L - 2$位($p^{L - 2}$)，最右边为第0位($p^0$)。然后将L - 1这一段与R这一段的最右边对其，也就是对L - 1这一段乘$p^{R - L + 1}$,最后再用R这一段减去移动后的L - 1段的字符串值即可得到子串的哈希值，公式为$h[R] - h[L  - 1]*p^{R-L+1}$。图中的公式写错了，应该是h[L - 1]。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%B1%82%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%90%E4%B8%B2%E7%9A%84%E5%93%88%E5%B8%8C%E5%80%BC.5s1vlkzittc0.webp" alt="求字符串子串的哈希值"></p>
<p>字符串哈希一般用于处理快速判断两个字符串是否相等的问题。</p>
<h2 id="STL容器"><a href="#STL容器" class="headerlink" title="STL容器"></a>STL容器</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector为变长数组，是可以动态变化的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()  返回第一个数</span><br><span class="line">    <span class="built_in">back</span>()   返回最后一个数</span><br><span class="line">    <span class="built_in">push_back</span>()  在最后插入一个数</span><br><span class="line">    <span class="built_in">pop_back</span>()   删除最后一个数</span><br><span class="line">    <span class="built_in">begin</span>()  第一个数</span><br><span class="line">    <span class="built_in">end</span>()    最后一个数的下一个位置</span><br><span class="line">    [] <span class="comment">//支持随机寻址</span></span><br><span class="line">    支持比较运算，按字典序<span class="comment">//例如两个vector数组之间的比较</span></span><br></pre></td></tr></table></figure>

<p>vector数组a初始化：<code>vector&lt;int&gt; a;</code></p>
<p>定义长度为n的数组a：<code>vector&lt;int&gt; a(n);</code></p>
<p>将数组a中的每一个元素初始化为特定的数m：<code>vector&lt;int&gt; a(n, m);</code></p>
<p>也可以定义数组：<code>vector&lt;int&gt; a[n];</code></p>
<p>vector遍历方式：</p>
<pre><code>1. `for (int i = 0; i &lt; a.size(); i ++ ) cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;`
1. 迭代器遍历，`for (vector&lt;int&gt;::iterator i = a.begin(); i != a.end(); i ++ ) cout &lt;&lt; *i &lt;&lt; &#39; &#39;;`(`vector&lt;int&gt;::iterator`可以用auto代替)
1. 范围遍历，`for (auto x : a) cout &lt;&lt; x &lt;&lt; &#39; &#39;;`
</code></pre>
<h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br></pre></td></tr></table></figure>

<p>pair初始化方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="type">int</span>, string&gt; p;</span><br><span class="line">p = <span class="built_in">make_pair</span>(<span class="number">10</span>, <span class="string">&quot;yxc&quot;</span>);</span><br><span class="line">p = &#123;<span class="number">20</span>, <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;p;<span class="comment">//这样可以存储三元组</span></span><br></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br></pre></td></tr></table></figure>

<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br></pre></td></tr></table></figure>

<p>定义队列：<code>queue&lt;int&gt; q;</code></p>
<p>如果已经定义了队列，<code>q = queue&lt;int&gt;();</code>可以重新构造队列</p>
<h3 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure>

<p>定义堆：<code>priority_queue&lt;int&gt; heap;</code></p>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    [] <span class="comment">//支持随机寻址</span></span><br></pre></td></tr></table></figure>

<p>deque的缺点是速度慢。</p>
<h3 id="set与multiset"><a href="#set与multiset" class="headerlink" title="set与multiset"></a>set与multiset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> <span class="title">erase</span><span class="params">()</span>输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span><span class="comment">//k是x的个数</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> <span class="title">erase</span><span class="params">()</span>输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span><span class="comment">//set的核心操作</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br></pre></td></tr></table></figure>

<p>set定义：<code>set&lt;int&gt; s</code></p>
<p>multiset定义：<code>multiset&lt;int&gt; MS</code></p>
<p>set是不能有重复元素，如果插入重复的元素，该操作是自动被忽略掉，而multiset是可以有重复元素的。</p>
<h3 id="map与multimap"><a href="#map与multimap" class="headerlink" title="map与multimap"></a>map与multimap</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map/<span class="function">multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br></pre></td></tr></table></figure>

<p>定义：</p>
<p>​	<code>map&lt;string, int&gt; a;</code></p>
<p>​	<code>a[&quot;yxc&quot;] = 1;</code></p>
<p>​	<code>cout &lt;&lt; a[&quot;yxc&quot;] &lt;&lt; endl</code>输出1</p>
<h3 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bitset, 圧位</span><br><span class="line">    bitset&lt;10000&gt; s;<span class="comment">//中括号中写的是bitset的个数</span></span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~（取反）</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure>

<p>bitset可以省8倍空间，这是bitset最主要的特点。</p>
<h1 id="第三章-搜索与图论"><a href="#第三章-搜索与图论" class="headerlink" title="第三章 搜索与图论"></a>第三章 搜索与图论</h1><h2 id="DFS-深度优先遍历"><a href="#DFS-深度优先遍历" class="headerlink" title="DFS(深度优先遍历)"></a>DFS(深度优先遍历)</h2><p>DFS对整个空间进行遍历，搜索的结构是一棵树，DFS的搜索方式是一搜到底，并且搜索到底后会返回上一节点并判断该节点是否还能继续往下搜，如果不能则返回上一节点继续判断，直到返回到根节点为止，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/DFS%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.es7pqrwojuw.webp" alt="DFS搜索方式"></p>
<p>DFS使用的数据结构是栈，由于他是一搜到底，所以空间与它的深度成正比，所以空间是O(h)。DFS不具有最短路性。空间上DFS比较占优势。</p>
<p>图的深度优先遍历模板（dfs没有固定模板）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过，u表示第几层的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//这里是使用链表的遍历方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DFS搜到最深一层后要回溯继续搜索其他节点，因此遍历完一条路径后需要恢复现场。</p>
<p>DFS的剪枝是提前判断，也就是遍历某一条路径时还没有遍历到最深一层就发现这条路径不符合题意，那么这条路径之后的节点不再遍历，直接回溯遍历其他路径。</p>
<h2 id="BFS（宽度优先遍历）"><a href="#BFS（宽度优先遍历）" class="headerlink" title="BFS（宽度优先遍历）"></a>BFS（宽度优先遍历）</h2><p>BFS同样对整个空间进行遍历，搜索的结构也是一棵树，它与DFS不同的是BFS是一层一层的搜索而不是一搜到底，BFS的搜索方式比较像眼观六路耳听八方，它同时可以搜索很多条路，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/BFS%E6%90%9C%E7%B4%A2%E6%96%B9%E5%BC%8F.o5jvdhxxxa8.webp" alt="BFS搜索方式"></p>
<p>BFS使用的数据结构是队列，由于它每次会把整个一层的数据都存起来，所以BFS的空间是指数级别，所以空间是O($2^h$)。由于BFS是一层一层的扩展，所以它第一次搜到的点一定是最近的点，因此它有一个最短路的概念。空间上BFS占劣势。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树和图的存储方式"><a href="#树和图的存储方式" class="headerlink" title="树和图的存储方式"></a>树和图的存储方式</h2><p>树是一种特殊的图，图分为有向图和无向图。有向图就是有方向的图，比如a到b，而无向图可以理解为双向图，a可以到b，b也可以到a，因此无向图可以看作一种特殊的有向图。</p>
<p>有向图分为邻接矩阵和邻接表。邻接表用的最多，邻接表与哈希表中的拉链法类似，每一个点都是单链表，就是存图中的每个点的下一个点都有哪些，这些下一个到达的点的存储是没有顺序的，也就是这样存储的每一个点能够到达的下一个所有的点是无序的，怎么排列都可以，例如节点1的链表既可以$1-&gt;3-&gt;4-&gt;\varnothing$这样存储，也可以$1-&gt;4-&gt;3-&gt;\varnothing$这样存储，如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%82%BB%E6%8E%A5%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.1lzgbf605hts.webp" alt="邻接表存储方式"></p>
<p>邻接表某一点的插入或删除与链表的方式一样。  </p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>有向图的拓扑序列就是图的宽度优先遍历的一个应用，拓扑序列一定是针对有向图，有向图才会有拓扑序列。</p>
<p>如果一个点的序列满足对于每条有向边（x,y），x都出现在y的前面，那就称这个序列是这个图的一个拓扑序列。  环是不可能存在拓扑序。</p>
<p>有向无环图一定存在一个拓扑序列，有向无环图也被称为拓扑图。</p>
<p>有向图的每个点都有入度和出度，也就是一个点有几条边进来就有几个入度，有几条边出去就有几个出度。如下图所示：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%89%E5%90%91%E5%9B%BE%E5%85%A5%E5%BA%A6%E4%B8%8E%E5%87%BA%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5.ph0f34a1tq8.webp" alt="有向图入度与出度的概念"></p>
<p>在有向图中入度为0意味着没有任何一条边指向该点，所以该点可以排在当前最前面的位置，因此将所有入度为0的点入队。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;<span class="comment">//队尾为-1是因为此时队列为空，在遍历一遍所有点之后，如果有一个点的入度为0则入队，如果所有点的入度都不为0，则没有点入队，因此队列始终为空，就不会执行下面的while循环语句，此时就说明不存在拓扑序列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])<span class="comment">//队列中存放的是所有入度为0的节点</span></span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)<span class="comment">//每取出队头元素，该节点的下一个节点的入度就会减1，如果减去一个入度后为0，则入队尾</span></span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;<span class="comment">//队尾是从-1开始的，因此当所有点都入队后，队尾的长度为n - 1,如果队尾的长度最终不为n - 1，则说明不存在拓扑序列，因此返回-1</span></span><br><span class="line">&#125;<span class="comment">//入队之后的所有点的次序就是拓扑序</span></span><br></pre></td></tr></table></figure>

<h2 id="dijkstra算法"><a href="#dijkstra算法" class="headerlink" title="dijkstra算法"></a>dijkstra算法</h2><p>最短路分为单源最短路和多源汇最短路，单源最短路一般求从一个点到其他所有点的最短距离，多源汇最短路就是起点和终点都是不确定的。源点就是起点，汇点就是终点。单源最短路又分两种情况，第一种是所有边权都是正数，它包含的算法有朴素Dijkstra算法（O($n^2$) (n表示点的数量)）和堆优化版的Dijkstra算法（O(m$logn$) (m表示边的数量)），第二种是存在负权边，也就是存在某些边权重是负数，它包含的算法有Bellman-Ford算法（O(nm)）和SPFA算法（Bellman-Ford算法的优化，一般情况下O(m)，最坏O(nm)）。多源汇最短路的算法是Floyd算法（O($n^3$)）。其分支介绍如下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D.33xr5ga43h80.webp" alt="最短路算法介绍"></p>
<p>最短路问题的难点在建图。</p>
<h3 id="朴素Dijkstra算法"><a href="#朴素Dijkstra算法" class="headerlink" title="朴素Dijkstra算法"></a>朴素Dijkstra算法</h3><ol>
<li>先初始化距离，一号点到起点的距离为0，其余所有点都为正无穷。</li>
<li>i从1到n循环，建立一个集合S用来存放当前已经确定最短距离的点。在循环中，第一步找到不在S中的距离最近的点，第二步将这样的点加到S中，第三步用这样的点更新其他点的距离。整个循环之后就可以确定每个点的最短路径的距离了。</li>
</ol>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边的长度，存储边的时候，如果存在重边，只需保留最短的那一条边即可，g[a][b]可以理解为a到b的距离</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//第一步初始化距离</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//只有第一个点的距离是确定的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )<span class="comment">//该循环为外层循环，它的意思表示每一次循环都会找出一个已经确定最短路径的点，总共有n个点，所以会循环n或n - 1次</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )<span class="comment">//当循环到哪一个点时，这个点到起点的距离一定是最短的距离，只需要查找该点的下一个点到起点的距离即可</span></span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;<span class="comment">//选择已经确定出最短路径的点（该点已为true）的下一个距离此点最近的一个点，因为这个已经确定好的点可能会直接指向多个不同的点，而指向多个不同的点（出度大于1）的距离有长也有短，比如一号点的距离为0且已经确定（一号点为true），此时一号点分别指向二号点和三号点，一号点到二号点的距离为4，一号点到三号点的距离为2，如果通过二号点（此时二号点为4）来查找到其他点的最短路，则有可能查找完之后所有的点到源点的距离都不是最短路，因为一号点到二号点虽然是距离为4，但是有可能会出现一号点到三号点再到二号点的距离为3，这个距离比一号点直接到二号点的距离更短，因此，在一号点的最短距离确定的情况下（一号点为true），并且一号点的出度大于1时，选择与一号点直接连接的所有点（选择下一个合适的点）中距离最短的那一个点是最好的选择，因此在上例中应该选择三号点，这也就是对if语句中dist[t] &gt; dist[j]的解释，同样，这个解释也可以理解下面的for循环语句。那么t = j语句就可以理解为选择一个更为合适的点作为查找其他最短路径的点的操作。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点到起点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);<span class="comment">//更新当前点的最短路径，t点是上一循环已经确定好的最短路径，j点是t点的下一个点（t点与j点直接连接的距离已经记录在邻接矩阵g中，t点与j点间接连接则为正无穷），因此只需要将t点的最短路径加t点到j点的路径，得到的就是j点到起点的最短路径</span></span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//整个循环会遍历到所有的点，如果有一个点的值还是正无穷，那么说明该点与起点是不连通的</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>边数很多的图是稠密图，它用邻接矩阵来存储，稀疏图用邻接表存储。</p>
<h3 id="堆优化版dijkstra算法"><a href="#堆优化版dijkstra算法" class="headerlink" title="堆优化版dijkstra算法"></a>堆优化版dijkstra算法</h3><p>当点数远大于边数时（稀疏图），需要进行优化。对图的存储方式也要改为邻接表的形式，需要用到的容器为优先队列，它可以实现堆结构。堆优化版的dijkstra算法不需要对重边做处理，因为此算法保证一定会选最短路的边。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;<span class="comment">//小根堆中每一个节点都是pair，存放点的距离和点的编号</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边，w表示权重，也就是边的长度</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="comment">//定义小根堆，因为要存放每一个点的最短距离，所以用小根堆来实现</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号，已知第一个点的距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();<span class="comment">//每次找到堆中在距离最小的点，因为是小根堆，所以堆的顶点，也就是根，一定是最距离小的</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();<span class="comment">//弹出堆顶元素，每取出一个堆顶元素（说明该点已经是最短的距离了），那么就要把这个节点从堆中取出来，保证堆中的节点都是未确认最短距离的点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;<span class="comment">//取出该堆顶元素的距离和编号</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;<span class="comment">//如果这个点之前已经取出来过了，那么说明该点是冗余备份。可以这样理解，堆中的顶点永远都是最短距离的点，当取出该点后，如果在后面的取顶操作再次遇到该点，说明这个点的距离是比最初取出来的点的距离大的（两个点的编号一样，距离不一样，第一个出去的点的距离永远都是最短的），它不是最短距离，因此这个点就没必要做处理了</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//每一个点都以邻接表的形式存储了他的下一个点都是谁。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];<span class="comment">//e中存放的是图中点的编号</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])<span class="comment">//distance表示此邻接表中的头元素的距离，也就是取出来的堆顶元素，然后通过遍历此堆顶元素的邻接表，更新当前已经确定最短路径的堆顶元素到它的下一个点的距离，i表示分配（idx）出去的节点编号，所以w[i]表示该分配节点（idx）的编号中所存放的图中的点的编号的权重</span></span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);<span class="comment">//虽然更新了距离，但还不是最短的距离，所以将其放入堆中继续更新距离，直至其更新至堆顶元素，那么它一定就是最短距离</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度 O(mlogn), n表示点数，m表示边数</span></span><br></pre></td></tr></table></figure>

<h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><p>bellman-ford算法中边的存储方式用结构体存储。bellman-ford算法循环结束后对于所有的边都满足$dist[b] &lt;&#x3D; dist[a] + w$，即三角不等式。bellman-ford算法可以处理有负权边的图。</p>
<p>在求最短路的时候，如果有负权回路，最短路是不一定存在的，如下图所示的负权回路中，在遍历选择最短路的时候的时候，2，3，4节点构成一个环，要查找1号节点到5号节点的最短路，由于存在负权边，因此在查找最短路时，中间的一个环会一直循环查找下去，查找到的最短路会无限减小，也就是负无穷，因此1号节点到5号节点的最短路也会为负无穷，那么这样1号节点到5号节点的最短路是不存在的。所以如果能够求出最短路，那么图中一般是不会存在负权回路的。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/bellman-ford%E7%AE%97%E6%B3%95%E8%B4%9F%E6%9D%83%E5%9B%9E%E8%B7%AF.3o3c2ryta120.webp" alt="bellman-ford算法负权回路"></p>
<p>bellman-ford算法可以用来查找负权环，假设一个图中有n - 1条边，n个节点，那么外层循环应该循环n次，当第n次循环还有路径更新的话（如果有n - 1条边的话，在第n次循环应该没有路径更新），那么说明存在一条路径有n条边，有n + 1个节点，由于总共有n个节点，但在循环后有n + 1个节点，那么说明存在两个相同的节点，则该路径上必然构成一个环，假设这条环是正权环，由于是要找最短路径，那么这个正权环是一定会抛弃的，因此不存在正权环的情况，所以当出现环时，该环一定是负权环。由于bellman-ford算法求负环的时间复杂度较高，一般不会用此算法查找负环。</p>
<p>bellman-ford算法的时间复杂度 O(nm), n 表示点数，m 表示边数。</p>
<p>注意在模板题中需要对下面的模板稍作修改，加上备份数组，如果不加备份，在更新的时候可能发生串联， 以下图为例，当题目要求对求最短路径的边数有限制时，假设边数限制为一条边，那么观察图中可发现最短路本应该是2，即$1-&gt;2-&gt;3$，但因为限制了边数，即使这条路径是最短路径，但它的边数为二，所以1到3的最短路应该是3，路径为$1-&gt;3$。发生串联的意思是，在查找最短路时，比如已经确定1号点到2号点的最短路为1，路径为$1-&gt;2$，那么在在查找1号点到3号点的最短路时，由于1号点到2号点的最短路已经确定，所以会以2号点为起点，查找到三号点的位置，则此时查找到1号点到3号点的最短路为2，路径为$1-&gt;2-&gt;3$，但并没有达到题目要求边数为1的限制，因为在查找最短路时，每查找到一个点（1号点）的邻近点（2号点）的最短路后，就会以该邻近点（2号点）作为起点，查找下一个邻近点（3号点）的最短路，而不是回到最初的那一个点（1号点），那么由于回不到最初的点，所以就打破了题目的限制，所以需要做一个备份，保证更新的时候只用上一次迭代的结果（保留了之前的所有点），这样就满足了题目的要求。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/bellman-ford%E7%AE%97%E6%B3%95%E5%8A%A0%E5%A4%87%E4%BB%BD%E4%B8%BE%E4%BE%8B.3nlt4b99b2g0.webp" alt="bellman-ford算法加备份举例"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//加备份</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//因为有可能存在负权边，所以在查找最短距离时dist[n]的值为0x3f3f3f3f减去某一个负权边的值，那么此时dist[n] == 0x3f3f3f3f就不能作为判断条件，所以改为dist[n] &gt; 0x3f3f3f3f / 2</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><p>SPFA算法是单源最短路径里限制最少的算法，只要图当中没有负环就可以用spfa算法，一般的最短路问题中没有负环。如果是正权图的话，建议使用Dijkstra算法，如果是负权图的话SPFA算法比较好用。</p>
<h3 id="队列优化的Bellman-ford算法"><a href="#队列优化的Bellman-ford算法" class="headerlink" title="队列优化的Bellman-ford算法"></a>队列优化的Bellman-ford算法</h3><p>SPFA算法其实是对bellman-ford算法做了一个优化，bellman-ford算法每次迭代时是遍历所有边来更新最短路，但是每一次迭代不一定每条边都会更新，即不一定通过$dist[b] &#x3D; min(dist[b], dist[a] + w)$来使$dist[b]$变小，如果$dist[b]$变小，则$dist[a]$一定是变小了，所以SPFA算法就是从这一点进行优化，这个优化用宽搜来优化，那么在迭代的时候用一个队列来做，队列里存放的是所有变小的节点。SPFA的写法与Dijkstra算法相似。</p>
<p>模板：</p>
<p>时间复杂度 平均情况下 O(m)，最坏情况下 O(nm), n表示点数，m 表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;<span class="comment">//st数组存的是当前这个点是不是在队列当中，防止队列当中存储重复的点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//取出队头元素后，该点已不在队列当中，因此将该点设为false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断图中是否存在负环"><a href="#判断图中是否存在负环" class="headerlink" title="判断图中是否存在负环"></a>判断图中是否存在负环</h3><p>SPFA求负环的思路与bellman-ford算法的思路是一样的，都是用抽屉原理求负环。需要建立一个cnt数组用来存放路径所经过的边数，当遍历后cnt数组中有某一元素为n，那么说明这条路径有n + 1个点，但是图中总共有n个点，由抽屉原理可知这条路径必定存在一个环，且该环是负权环。</p>
<p>模板：</p>
<p>时间复杂度 平均情况下 O(m)，最坏情况下O(nm), n表示点数，m表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组，因为该算法求的不是距离的绝对值，而是求路径中是否存在负环</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);<span class="comment">//由于在图中可能存在一些点无法到达负环，所以要将图中的所有点放入队列中查找</span></span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;<span class="comment">//cnt数组存放的是最短路经过的边数</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>Floyd算法用来求解多源汇最短路，用邻接矩阵来存储图。它的原理是基于动态规划。</p>
<p>模板：</p>
<p>时间复杂度是 O($n^3$), n表示点数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);<span class="comment">//该公式基于动态规划</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树定义：</p>
<p>​	对于一个带权连通无向图G&#x3D;(V,E)，生成树不同，每棵树的权（树中所有边上的权值和）也不同，设R为G的所有生成树的集合，若T为	R中权值和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree，MST）</p>
<p>​	注：</p>
<p>​	1、最小生成树可能有多个，但边的权值之和总是唯一且最小的</p>
<p>​	2、最小生成树的边数&#x3D;定点数-1，砍掉一条则不连通，增加一条则会出现回路</p>
<p>​	3、若一个连通图本身就是一颗树，则其最小生成树就是它本身</p>
<p>​	4、只有连通图才有生成树，非连通图只有生成森林</p>
<p>最小生成树问题对应的图都是无向图，有向图的最小生成树一般是不会用到。最小生成树问题有两个算法，即普利姆算法（Prim）和克鲁斯卡尔算法（Kruskal）。普利姆算法与Dijkstra算法相像，稠密图一般用朴素版普利姆算法（$O(n^2)$），稀疏图一般用堆优化版的普利姆算法($O(mlogn)$)。克鲁斯卡尔算法的时间复杂度是固定的（$O(mlogm)$），它的时间主要花费在排序上。最小生成树问题上算法模板的选择一般稠密图用朴素版普利姆算法，稀疏图用克鲁斯卡尔算法和堆优化版的普利姆算法，但是堆优化版的普利姆算法一般不常用，所以稀疏图常用克鲁斯卡尔算法解决。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84.2hcxmaye6fg0.webp" alt="最小生成树结构"></p>
<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>Prim算法的思路与Dijkstra算法的思路相似，首先初始化所有的距离为正无穷，接下来n次迭代，每次迭代找到不在集合当中距离最小的点，该集合所表示的是当前已经在连通块的所有点，在迭代中首先找到在集合外距离最近的点（在迭代中选择集合外的点步骤为：遍历集合外的所有点，然后在这些点中选择其中一个与集合中的点最短的一个距离的点，前提是这样的点与集合中的任意一个点相连接，那么这个点就是迭代中要选择的点），然后用该点更新其他点到集合的距离（其他点到集合的距离其实就是看其他点有没有一条边能够连向集合内部，如果有，则选择这个点到集合中的一些点的距离最短的边，比如集合当中现在有三个点，分别为一号点、二号点和三号点，此时选择一个不在集合的四号点，该四号点与集合当中的三个点都相连，那么就选择这个点与这三个点连接的最短的一条边，则这个最短的距离就被称为点到集合当中最短的距离，如果该点不与集合当中的任意一点相连，则距离定义为正无穷），最后将该点加入集合中。</p>
<p>模板：</p>
<p>时间复杂度是 O(n2+m), n表示点数，m表示边数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//存储最小生成树中所有边的长度之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;<span class="comment">//如果除第一个点以外，不存在任何两个点相连（说明各点互不相连），那么t最终为正无穷，即符合下面if语句，返回正无穷</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;<span class="comment">//如果不是第一个点，并且该点为正无穷，则说明当前距离最近的点到集合的距离都是正无穷，那么就不存在最小生成树</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];<span class="comment">//选中的t必然是距离最短的点，所以与结果累加</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);<span class="comment">//用t点更新到其他点的最小距离</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><p>克鲁斯卡尔算法第一步将所有边按权重从小到大排序（$O(mlogm)$），第二步枚举每一条边ab，权重为c，如果ab不连通，那么将这条边加入集合中。第二步是并查集的简单应用，第二步的时间复杂度是$O(m)$,整个克鲁斯卡尔算法的时间复杂度为$O(mlogm)$。</p>
<p>克鲁斯卡尔算法不需要用邻接表或邻接矩阵来存图只需要开一个结构体把每条边存下来即可。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;<span class="comment">//重载小于号，方便排序</span></span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);<span class="comment">//按照边权重从小到大排序 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )<span class="comment">//从小到大枚举所有边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并，判断两个点是否连通其实就是判断他们的祖宗节点是不是一样的</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;<span class="comment">//并查集的合并</span></span><br><span class="line">            res += w;<span class="comment">//res存储最小生成树中所有边权重之和</span></span><br><span class="line">            cnt ++ ;<span class="comment">//cnt存的是当前加了多少条边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;<span class="comment">//如果加的边数小于n - 1说明这个图是不连通的，见最小生成树的定义</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p><strong>二分图的概念：二分图通常针对 无向图 问题（有些题目虽然是有向图，但一样有二分图性质）</strong></p>
<p>​	<strong>在一张图中，如果能够把全部的点分到 两个集合 中，保证两个集合内部没有 任何边 ，图中的边 只存在于两个集合之间，这张图就是二分图，也就是说同一个集合当中的任意两个点是没有边的，只有一个集合中的点和另一个集合中的点存在边。</strong></p>
<p>二分图有两个部分，第一个部分为染色法（$O(n + m)$），它的原理是深度优先遍历，用于判别是否为二分图。第二部分为匈牙利算法（最坏为$O(mn)$，但一般实际运行时间远小于$O(mn)$），用于求二分图的最大匹配</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%BB%93%E6%9E%84.62fxxjuia9c0.webp" alt="二分图结构"></p>
<h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h3><p>二分图当且仅当图中不含奇数环（奇数环指环当中的边数是奇数，如果有奇数环，那么就不存在二分图）， 遍历图中的某一个点，假设遍历一号点，把它放入一号集合，那么所有与一号点相邻的点都要放在二号集合中，保证一条边的两个点是属于不同的集合的，此选择放入哪一个集合的过程称为染色，由于图当中是不含奇数环，所以该染色过程是不存在矛盾的。</p>
<p>模板：</p>
<p>时间复杂度是 O(n+m), n表示点数，m表示边数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//对当前点染色</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//遍历当前点所有的邻点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)<span class="comment">//如果当前点的邻点j没有染色，那么递归到该j点染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//染成与当前节点不同的颜色</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果当前j点已经染过颜色，那么需要判断它与当前点的颜色是否一样，如果一样，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//如果所有的点都被染色并且没有发生矛盾，那么就不会递归dfs函数，直至最后一步for循环结束并返回true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span><span class="comment">//判断是否染色成功，如果成功则为二分图，反之则不是</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;<span class="comment">//用来表示染色的过程中是不是有矛盾发生</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)<span class="comment">//如果该点没有染色，那么就需要染色</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))<span class="comment">//如果dfs返回的是false就说明有矛盾发生</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;<span class="comment">//染色发生矛盾</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果染色失败，说明发生矛盾，直接退出返回结果即可</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><p>给定一个二分图，用匈牙利算法来求出它的最大匹配（最大匹配是指两个点只共用一条边，并且在之后的匹配中这两个点不再参与匹配）的数量，<strong>举一个现实中的例子，把匹配问题转化为找对象问题，假设有两个男生和两个女生，一号男生可以选择一号女生和二号女生，而二号男生只可以选择一号女生，此时先选择一号男生看他可以和哪个女生处对象，选择之后，一号男生可以和一号女生处对象，匹配成功，接下来选择二号男生，看他可以和哪些女生处对象，此时查到二号男生只能和一号女生处对象，但是一号女生已经被一号男生选择了，由于要求最大的匹配数量，这时一号女生被两个人选择，那么一号女生就要查找一号男生除了选择自己以外还可以选择哪些女生，一号女生查到了一号男生还可以选择二号女生，为了尽可能的让所有男生都可以找到对象，一号女生就要放弃一号男生，让一号男生选择二号女生，这样二号男生就可以选择一号女生，最终两个男生都有对象，最大匹配问题解决。</strong>所以匈牙利算法一般用于求出二分图当中的这样的匹配的边的数量。</p>
<p>模板：</p>
<p>时间复杂度是 O(nm), n表示点数，m表示边数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//第一个集合每个点的邻接表连接的都是第二个集合中的点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];<span class="comment">//j指的是第二个集合的点</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))<span class="comment">//在第一个男生选择的情况下，如果一号女生还没有选择男生，那么就执行下列语句，让一号女生选择一号男生。如果一号男生已经选择完了，该让二号男生选择时，由于二号男生也可以选择一号女生，但是一号女生已经选择了一号男生，那么二号男生就会让一号女生询问一号男生是否还可以选择其他女生，此时一号女生发现一号男生还可以选择二号女生，那么就要递归让二号女生选择一号男生（此操作在递归中执行），递归出来之后，下列语句的意思就是由于一号男生选择了二号女生，那么一号女生就可以选择二号男生了</span></span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//整体来讲，表面上看似是男生选择女生，实际在内部当中是女生选择男生，这样理解后，如果一个男生可以选择多个女生，那么永远是最后一个女生得手，前面的已经选择了男生的女生就要选择其他男生</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )<span class="comment">//分析第一个集合中每一个点可以选择第二个集合中的哪个点</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);<span class="comment">//先对第二个集合初始化，表示第二个集合中每个点都没有被选择</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;<span class="comment">//如果第一个集合当中的点成功找到可以与第二个集合匹配的点，则加入结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-数学知识"><a href="#第四章-数学知识" class="headerlink" title="第四章 数学知识"></a>第四章 数学知识</h1><h2 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h2><p>质数：在大于1的整数中，如果只包含1和本身这两个约数，就被称为质数，或者叫素数。</p>
<h3 id="试除法——质数的判定"><a href="#试除法——质数的判定" class="headerlink" title="试除法——质数的判定"></a>试除法——质数的判定</h3><p>给定一个数字n，在$1 &lt; x &lt; n$之间如果有$n &#x2F; x$能够整除的话，则n不是质数，否则就是质数。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="试除法——分解质因数"><a href="#试除法——分解质因数" class="headerlink" title="试除法——分解质因数"></a>试除法——分解质因数</h3><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;<span class="comment">//因为x中最多只包含一个大于根号x的质因子，所以当x大于1时说明这个数就是那个大于根号x的质因子，单独处理</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="筛法求素数"><a href="#筛法求素数" class="headerlink" title="筛法求素数"></a>筛法求素数</h3><p>给定一个数n，遍历数组中的每一个数并把这个数之后的所有该数的倍数删去，每一个元素都执行完之后，那么这个数组中剩下的就都是质数。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素筛法</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线性筛法：n只会被它的最小质因子筛掉</span></span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;<span class="comment">//每次把质数和i的乘积筛掉，因为质数乘某一个数一定是合数</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//primes[j]一定是i的最小质因子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);<span class="comment">//如果是平方数，则不放入结果，因为约数不能重复</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约数个数与约数之和"><a href="#约数个数与约数之和" class="headerlink" title="约数个数与约数之和"></a>约数个数与约数之和</h3><p>求约数个数的思路为：先通过对一个数分解质因数（分解质因数算法），得到底数和指数，然后通过下列模板中的公式求出约数的个数，求约数之和同理。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck<span class="comment">//分解质因数</span></span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure>

<h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>欧几里得算法用于求两个数的最大公约数，也称辗转相除法。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;<span class="comment">//如果b不等于0，则返回a，否则返回gcd(b, a % b)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><h3 id="分解质因数法求欧拉函数"><a href="#分解质因数法求欧拉函数" class="headerlink" title="分解质因数法求欧拉函数"></a>分解质因数法求欧拉函数</h3><p>欧拉函数表示1到n中与n互质的个数，用$\varphi(n)$表示。在求某一个数的欧拉函数时要先对该数分解质因数，即分解为$N&#x3D;p_1^{\alpha_1}<em>p_2^{\alpha_2}</em>…<em>p_k^{\alpha_k}$（$p$表示分解的质因数，$\alpha$表示质因数$p$的个数，即$p$的指数），然后再求欧拉函数$\varphi(N)&#x3D;N</em>(1-\frac{1}{p_1})<em>(1-\frac{1}{p_2})</em>…*(1-\frac{1}{p_k})$,求出来的结果就是与N互质的个数。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//套公式即可</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);<span class="comment">//因为是整除运算，所以欧拉函数需要化简，也就是将上面的欧拉函数的括号中的式子合并</span></span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="筛法求欧拉函数"><a href="#筛法求欧拉函数" class="headerlink" title="筛法求欧拉函数"></a>筛法求欧拉函数</h3><p>筛法求欧拉函数常用于求1到n当中的每一个数的欧拉函数。分解质因数法也可以求出每一个数的欧拉函数，但是该算法中需要把每一个数的都分解质因数，因此花费的大量的时间（$O(N\sqrt{N})$），而筛法求欧拉函数是线性的($O(N)$)，因此时间上是占优势的。</p>
<p>欧拉定理：若a与n互质，则$a^{\varphi(n)}\equiv1(mod\ n)$。</p>
<p>费马定理：若a与n互质且n为质数，则$a^{n - 1}\equiv1(mod\ n)$。</p>
<p><strong>质数n的欧拉函数为n - 1。</strong></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N];           <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])</span><br><span class="line">        &#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)<span class="comment">//当一个数i可以整除一个质数pj(primes[j],这里用pj表示)，那么说明i是pj的倍数，因此i和pj都可以被pj整除，所以当i*pj时，pj被乘了两次，所以在i*pj分解质因数中pj的指数为2，又因为欧拉函数的公式与分解质因数当中的指数无关，所以i*pj的欧拉函数就是i的欧拉函数乘以pj</span></span><br><span class="line">            &#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>快速幂用来快速的求出来$a^k\ mod\ p$的结果。将指数k转化为二进制数，然后将a拆解，如$4^5$,将5转化为二进制$(101)_2$，那么拆解后得$4^{2^0}*4^{2^2}$，然后求该拆解式中的每一项模p的结果，也就是预处理。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求 m^k mod p，时间复杂度 O(logk)。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h2><p>在学习扩展欧几里得算法之前先介绍一下裴蜀定理：裴蜀定理即对于任意一对正整数a，b，那么一定存在非零整数x，y，使得$ax+by&#x3D;(a,b)$（$(a,b)$表示a和b的最大公约数），因为a是$gcd(a,b)$的倍数，b也是$gcd(a,b)$的倍数(说明$a\ %\ gcd(a,b)$和$b\ %\ gcd(a,b)$都为0)，那么$a+b&#x3D;gcd(a,b)<em>(\frac{a}{gcd(a,b)}+\frac{b}{gcd(a,b)})$，所以当$ax+by&#x3D;d$时，它就等价于$gcd(a,b)</em>(\frac{ax}{gcd(a,b)}+\frac{bx}{gcd(a,b)})&#x3D;d$，所以$d$一定是$gcd(a,b)$的倍数，也就是说只有d是$gcd(a,b)$的倍数，该式才会有解，否则无解。</p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求x, y，使得ax + by = gcd(a, b)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span><span class="comment">//将欧几里得算法展开写</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>; y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;<span class="comment">//当b为0时，那么就是求gcd(a, 0)，由于0和任意一个自然数的最大公约数是该自然数本身，所以gcd(a, 0) = a，求解方程ax + by = a得x为1，y为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);<span class="comment">//参数a，b发生翻转，所以x，y也要翻转</span></span><br><span class="line">    y -= (a/b) * x;<span class="comment">//y的推导公式如下图所示</span></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开后的欧几里得算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%E6%8E%A8%E5%AF%BC%E5%85%AC%E5%BC%8F.4hfk4a36lyg0.webp" alt="扩展欧几里得算法推导公式"></p>
<p>$a\ mod\ b&#x3D;a-{\lfloor\frac{a}{b}\rfloor}b$的推导：</p>
<p>​	$a\div b&#x3D;{\lfloor \frac{a}{b}\rfloor …r} \longrightarrow a&#x3D;\lfloor \frac{a}{b} \rfloor b+r \longrightarrow r&#x3D;a-\lfloor \frac{a}{b}\rfloor b &#x3D; a\ mod\ b$。</p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>给定一堆两两互质的数$m_1,m_2,m_3,…,m_k$，设$M&#x3D;m_1m_2m_3…m_k$，使得$M_i&#x3D;\frac{M}{m_i}$（$M_i$就是除了$m_i$其他所有$m$的乘积），由于$m$之间两两互质，所以$M_i$就与$m_i$互质，$M_i^{-1}$表示$M_i$模$m_i$的逆（因为$M_i$与$m_i$互质，所以一定存在一个逆元$M_i^{-1}$），有一个线性同余方程组$x\equiv a_1(mod\ m_1),x\equiv a_2(mod\ m_2),…,x\equiv a_k(mod\ m_k)$，使得$x&#x3D;a_1M_1M_1^{-1}+a_2M_2M_2^{-1}+…+a_kM_kM_k^{-1}$，可以用扩展欧几里得算法求出逆元，之后带入此公式求出x即可。</p>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><p>高斯消元一般来说可以在$n^3$时间复杂度之内求解一个包含n个方程和n个未知数的多元线性方程组，可以求出每一个未知数，方程组如下：</p>
<p>$\begin{cases} a_{11}x_1+a_{12}x_2+…+a_{1n}x_n&#x3D;b_1 \ a_{21}x_1+a_{22}x_2+…+a_{2n}x_n&#x3D;b_2 \ …\…\…\a_{n1}x_1+a_{n2}x_2+…+a_{nn}x_n&#x3D;b_n \end{cases}$</p>
<p>该方程组有三种情况：无解、无穷多组解和唯一解。 </p>
<p>将方程组中的系数取出来组成一个n * (n + 1)的系数距阵（包括b），然后对这个矩阵做初等行列变换，操作如下：</p>
<pre><code>1. 把某一行乘一个非零的数（等价于对一个方程两边同时乘一个非零的数）
1. 交换某两行（等价于对方程组中的某两个方程交换位置）
1. 把某行的若干倍加到另一行上去（等价于把一个方程的若干倍加到另外一个方程上去）
</code></pre>
<p>上述三个操作可以把一个一般的方程组变成一个上三角的形式（也称阶梯型），如下所示：</p>
<p>$\left{ \begin{matrix}a_{11} &amp; a_{12} &amp; … &amp; a_{1n} &amp; b_1\ 0 &amp; a_{22} &amp; … &amp;  a_{2n} &amp; b_2 \ . &amp; . &amp; … &amp; . &amp; .\ . &amp; . &amp; … &amp; . &amp; .\ . &amp; . &amp; … &amp; . &amp; .\ 0 &amp; 0 &amp; … &amp; a_{nn} &amp; b_n\end{matrix}\right}$</p>
<p>已知最后一行只有一个未知数，那么就可以依次向上带入求出其他未知数。</p>
<p>如果最终得到的矩阵是一个完美的阶梯型，就会有唯一解，如果不是一个完美阶梯型，分为两种情况，第一种情况中，如果出现方程左边没有未知数右边是非零的情况，这样的情况为无解，第二种情况中，出现了许多零等于零的方程，则有无穷多个解。</p>
<p>高斯消元的算法思路：</p>
<p>枚举每一列c</p>
<pre><code>    1. 在该第c列中找到一个非零且绝对值最大的数所在的一行
    1. 将这行换到顶行，即交换两行，交换之后该行在当前迭代中为第一行，且这行在下一次迭代中不参与任何运算
    1. 将这一行的第一个非零数变成1，也就是该等式同时除以某一个数
    1. 将第c列除了第一行（当前迭代的第一行）的数的其他数全部消为零，也就是从第二行（当前迭代的第二行）开始的每一行等式减去第一行（当前迭代的第一行）等式乘以某一个数，使得该行的第c列为零
    1. 枚举下一列，回到第一步
</code></pre>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[N][N]是增广矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gauss</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> c, r;<span class="comment">//c表示列，r表示行</span></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">0</span>, r = <span class="number">0</span>; c &lt; n; c ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )   <span class="comment">// 找到绝对值最大的行</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; <span class="built_in">fabs</span>(a[t][c]))</span><br><span class="line">                t = i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[t][c]) &lt; eps) <span class="keyword">continue</span>;<span class="comment">//因为矩阵为浮点类型存在误差，所以判断某一元素是否为0需要建立一个很小的数eps，如果小于eps则为0</span></span><br><span class="line"><span class="comment">//fabs是浮点数的绝对值，abs是整数的绝对值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = c; i &lt;= n; i ++ ) <span class="built_in">swap</span>(a[t][i], a[r][i]);      <span class="comment">// 将绝对值最大的行换到最顶端，也就是一行中的每一列都做交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= c; i -- ) a[r][i] /= a[r][c];      <span class="comment">// 将当前行的首位变成1，从最后一列开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r + <span class="number">1</span>; i &lt; n; i ++ )       <span class="comment">// 用当前行将下面所有的列消成0</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][c]) &gt; eps)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= c; j -- )</span><br><span class="line">                    a[i][j] -= a[r][j] * a[i][c];</span><br><span class="line"></span><br><span class="line">        r ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r &lt; n)<span class="comment">//如果r &lt; n说明矩阵中存在多行的方程左边全为0的情况，那么该矩阵就不是完美阶梯型，所以存在无解或无穷多个解</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = r; i &lt; n; i ++ )</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[i][n]) &gt; eps)<span class="comment">//因为已经存在多个方程左边没有未知数，所以在这样的情况下，如果该方程的右边不为零，那么就说明无解</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">// 无解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 有无穷多组解</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )<span class="comment">//由下到上将矩阵化为单位矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j ++ )<span class="comment">//j表示列，列比行多一</span></span><br><span class="line">            a[i][n] -= a[i][j] * a[j][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 有唯一解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p>举一个简单的容斥原理的例子，如下图所示的韦恩图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/%E9%9F%A6%E6%81%A9%E5%9B%BE.yhuedj9l2uo.webp" alt="韦恩图"></p>
<p>在上图中，要求出三个圆构成的总面积，由于4、5、6、7号区域的面积加了多次，因此需要想办法把这些多加的面积减掉，所以总面积为$S&#x3D;S_1+S_2+S_3-S_1 \cap S_2-S_1 \cap S_3-S_2 \cap S_3+S_1 \cap S_2 \cap S_3$。</p>
<p>当有两个圆的时候总面积为$S&#x3D;S_1+S_2-S_1 \cap S_2$，当有四个圆时总面积为$S&#x3D;S_1+S_2+S_3+S_4-S_1 \cap S_2-S_1 \cap S_3-S_1 \cap S_4-S_2 \cap S_3 - S_2 \cap S_4 - S_3 \cap S_4$</p>
<p>​		$+S_1 \cap S_2 \cap S_3+S_1 \cap S_2 \cap S_4+S_1 \cap S_3 \cap S_4+S_2 \cap S_3 \cap S_4-S_1 \cap S_2 \cap S_3 \cap S_4$。</p>
<p>由此可以观察出规律，每一个式子都是加减交替：第一个加法是一个圆相加，第二个减法是两个圆做交集相减，第三个加法是三个圆做交集相加，第四个减法是四个圆做交集相减…</p>
<p>以此类推，可以得到n个圆的总面积：$(一个圆的和)-(两个圆做交集的和)+(三个圆做交集的和)-(四个圆做交集的和)+…+(-1)^{n-1}*(n个圆的交集)$</p>
<p>由此可以总结出奇数圆的和前面是加号，偶数圆的和前面是减号，即$(-1)^{n-1}$，如上的式子就被称为容斥原理。</p>
<p>总结上述内容，将圆看作一个集合，最终得到容斥原理的公式为：$(-1)^{0}<em>(C_n^1)+(-1)^{1}</em>(C_n^2)+(-1)^{2}<em>(C_n^3)+…+(-1)^{n-1}</em>(C_n^n)$，其中$C_n^m$表示在n个集合中任意选取m个集合做交集的面积和。</p>
<p><strong>$C_n^0+C_n^1+C_n^2+…+C_n^n&#x3D;2^n$，所以上述容斥原理的公式中除了n个集合中都不选以外共有$2^n-1$项。</strong></p>
<h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><h3 id="NIM游戏"><a href="#NIM游戏" class="headerlink" title="NIM游戏"></a>NIM游戏</h3><p>给定N堆物品，第i堆物品有Ai个。两名玩家轮流行动，每次可以任选一堆，取走任意多个物品，可把一堆取光，但不能不取。取走最后一件物品者获胜。两人都采取最优策略，问先手是否必胜。</p>
<p>我们把这种游戏称为NIM博弈。把游戏过程中面临的状态称为局面。整局游戏第一个行动的称为先手，第二个行动的称为后手。若在某一局面下无论采取何种行动，都会输掉游戏，则称该局面必败。<br>所谓采取最优策略是指，若在某一局面下存在某种行动，使得行动后对面面临必败局面，则优先采取该行动。同时，这样的局面被称为必胜。我们讨论的博弈问题一般都只考虑理想情况，即两人均无失误，都采取最优策略行动时游戏的结果。<br>NIM博弈不存在平局，只有先手必胜和先手必败两种情况。</p>
<p>定理： NIM博弈先手必胜，当且仅当 <code>A1 ^ A2 ^ … ^ An != 0</code></p>
<p>游戏有两个状态，分别为必胜状态和必败状态：</p>
<p>​	先手必胜状态：可以走到某一个必败状态</p>
<p>​	先手必败状态：走不到任何一个必败状态，也就是走到必胜状态</p>
<h3 id="公平组合游戏ICG"><a href="#公平组合游戏ICG" class="headerlink" title="公平组合游戏ICG"></a>公平组合游戏ICG</h3><p>若一个游戏满足：</p>
<ol>
<li>由两名玩家交替行动；</li>
<li>在游戏进程的任意时刻，可以执行的合法行动与轮到哪名玩家无关；</li>
<li>不能行动的玩家判负；</li>
</ol>
<p>则称该游戏为一个公平组合游戏。<br>NIM博弈属于公平组合游戏，但城建的棋类游戏，比如围棋，就不是公平组合游戏。因为围棋交战双方分别只能落黑子和白子，胜负判定也比较复杂，不满足条件2和条件3。</p>
<h3 id="有向图游戏"><a href="#有向图游戏" class="headerlink" title="有向图游戏"></a>有向图游戏</h3><p>给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。<br>任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。</p>
<h3 id="Mex运算"><a href="#Mex运算" class="headerlink" title="Mex运算"></a>Mex运算</h3><p>设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：<br>mex(S) &#x3D; min{x}, x属于自然数，且x不属于S</p>
<h3 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h3><p>在有向图游戏中，对于每个节点x，设从x出发共有k条有向边(也就是说从x出发能够出现k个局面)，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：<br><code>SG(x) = mex(&#123;SG(y1), SG(y2), …, SG(yk)&#125;)</code><br>特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) &#x3D; SG(s)。</p>
<h3 id="有向图游戏的和"><a href="#有向图游戏的和" class="headerlink" title="有向图游戏的和"></a>有向图游戏的和</h3><p>设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。<br>有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：<br><code>SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)</code></p>
<h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><p>有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。<br>有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。</p>
<h1 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h1><p>DP问题从两个角度来思考：状态表示和状态计算。</p>
<p>状态就是一个未知数，背包问题一般是两维的，用$f(i,j)$表示，在状态表示中，一般从集合和属性两个角度考虑，集合存的是所有选法的集合，该选法满足两个条件，第一个是只从前i个物品中选，第二个是选出来物品的总体积小于等于j，$f(i,j)$存的就是满足这两个条件所有选法的总价值的最大值，$f(i,j)$是一个数，他表示的是一个集合，这个数表示的是集合当中的某一种属性，属性有最大值、最小值和数量三种，在背包问题中属性是最大值。</p>
<p>状态计算就是考虑$f(i,j)$可以怎么被计算出来，一般来说状态计算表示的是集合的划分，就是对当前集合划分成若干个子集，在背包问题中会把一个集合分为两个集合，分为不含第i个物品的集合（也就是从1到i-1中选，并且总体积不超过j的最大值，可以用$f(i-1,j)$表示）和含第i个物品的集合（所有从1到i中选，并且总体积不超过j而且包含了第i个物品的选法的集合，用$f(i-1,j-v_i)+w_i$表示）,然后在这两个集合中选出一个最大的结果。划分子集的原则：不重复（两个集合中的元素不重复）。不漏（划分之后不能出现某一个元素不存在的情况）。必须要满足不漏的条件，但不重复原则不一定要满足。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%AE%97%E6%B3%95/DP.683rgx39pv00.webp" alt="DP"></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1C7411K79w?p=2&vd_source=b5bbffe9121246ff5a92f72d41f859b1">背包问题视频详解</a></p>
<h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>给定N个物品和一个容量是V的背包，每一个物品有两个属性$v_i$（体积）和$w_i$（价值）,每件物品最多只能用一次或者一次都不用，从这些物品中挑选一些物品，使得挑选的物品总体积小于等于V，让这些物品的总价值尽可能的最大，并求出最大价值。</p>
<p>01背包的特点：每件物品最多只能用一次。</p>
<h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>完全背包的特点：每件物品可以用无限次。</p>
<h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>每一个物品最多有$S_i$个，并且不同的物品数量不同。</p>
<h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>物品有N组，每一组物品有若干个，且每一组最多只能选择一个物品，如在水果这一组，如果选择苹果，那么就不能选择其他水果，在这样的限制下求出能够获得的最大价值。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-数据结构" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>表尾端称为栈顶，表头端称为栈底。</p>
<p>栈又称为后进先出的线性表（LIFO）。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-计算机组成原理" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第三章-总线"><a href="#第三章-总线" class="headerlink" title="第三章 总线"></a>第三章 总线</h1><h2 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h2><h3 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h3><p>​	<strong>总线</strong>是连接各个部件的信息传输线，是各个部件共享的传输介质。</p>
<h3 id="总线上信息的传输"><a href="#总线上信息的传输" class="headerlink" title="总线上信息的传输"></a>总线上信息的传输</h3><p>​	串行和并行（并行需要多条数据线），通常情况下并行支持的距离较短，串行支持的距离较远，串行能够传输一位数据，并行能够传输多位数据。</p>
<h3 id="单总线结构框图"><a href="#单总线结构框图" class="headerlink" title="单总线结构框图"></a>单总线结构框图</h3><p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.77ap6g8x6n80.webp" alt="单总线结构框图"></p>
<p>单总线中在任何一个时刻只能有一个部件在运行。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-计算机网络" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="1-1-什么是因特网"><a href="#1-1-什么是因特网" class="headerlink" title="1.1 什么是因特网"></a>1.1 什么是因特网</h2><h3 id="1-1-1-具体构成描述"><a href="#1-1-1-具体构成描述" class="headerlink" title="1.1.1 具体构成描述"></a>1.1.1 具体构成描述</h3><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接到一起。</p>
<p>分组交换机：路由器（通常用于网络核心中）、链路层交换机（通常用于接入网中）。</p>
<p>端系统、分组交换机和其他因特网部件都要运行一系列协议，这些协议控制因特网中信息的接受和发送。TCP和IP是因特网中最为重要的协议。</p>
<p>IP协议定义了在路由器和端系统之间发送和接收的分组格式。因特网的主要协议统称为TCP&#x2F;IP。</p>
<h3 id="1-1-2-服务描述"><a href="#1-1-2-服务描述" class="headerlink" title="1.1.2 服务描述"></a>1.1.2 服务描述</h3><p>与因特网相连的端系统提供了一个套接字接口，该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式。英特网套接字接口是一套发送程序必须遵循的规则集合，因此因特网能够将数据交付给目的地。</p>
<h3 id="1-1-3-什么是协议"><a href="#1-1-3-什么是协议" class="headerlink" title="1.1.3 什么是协议"></a>1.1.3 什么是协议</h3><p><strong>1. 人类活动的类比</strong></p>
<p>为了完成一项工作，要求两个（或多个）通信实体运行相同的协议。</p>
<p><strong>2. 网络协议</strong></p>
<p><strong>协议</strong> 定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和&#x2F;或接受一条报文或其他事件所采取的动作。</p>
<h2 id="1-2-网络边缘"><a href="#1-2-网络边缘" class="headerlink" title="1.2 网络边缘"></a>1.2 网络边缘</h2><p>端系统处于因特网的边缘。</p>
<p>主机 &#x3D; 端系统。</p>
<p>主机分为<strong>客户（通常是桌面PC、移动PC和智能手机等）</strong>和<strong>服务器（通常是更为强大的机器，用于存储和发布Web页面、流视频、中继电子邮件等）</strong>。</p>
<h3 id="1-2-1-接入网"><a href="#1-2-1-接入网" class="headerlink" title="1.2.1 接入网"></a>1.2.1 接入网</h3><p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E6%8E%A5%E5%85%A5%E7%BD%91.59bats2rgwg0.webp" alt="接入网"></p>
<p><strong>接入网：</strong>指将端系统物理连接到其<strong>边缘路由器（端系统到任何其他远程端系统的路径上的第一台路由器）</strong>的网络。</p>
<p>宽带住宅接入有两种最流行的类型：<strong>数字用户线（DSL）</strong>和电缆。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/DSL%E5%9B%A0%E7%89%B9%E7%BD%91%E6%8E%A5%E5%85%A5.57jlej3xx5s0.webp" alt="DSL因特网接入"></p>
<p><strong>光纤到户（FTTH）</strong>是一种提供更高速率的新兴技术。</p>
<p>两种有竞争性的光纤分布体系结构：<strong>有源光纤网络（AON）和无源光纤网络（PON）。</strong></p>
<p><strong>无源光纤网络（PON）</strong>：每个家庭具有一个<strong>光纤网络端接器（ONT）</strong>，它把一些家庭集结到一根共享的光纤，该光纤再连接到本地电话和公司的中心局中的<strong>光纤线路端接器（OLT）</strong>。</p>
<h3 id="1-2-2-物理媒体"><a href="#1-2-2-物理媒体" class="headerlink" title="1.2.2 物理媒体"></a>1.2.2 物理媒体</h3><p><strong>物理媒体：</strong>两种类型：引导型媒体和非引导型媒体。</p>
<p>​	<strong>引导型媒体：</strong>电波沿着固体媒体前行。如光缆、双绞铜线或同轴电缆。</p>
<p>​	<strong>非引导型媒体：</strong>电波在空气或外层空间传播。如在无线局域网或数字卫星频道中。</p>
<h4 id="双绞铜线"><a href="#双绞铜线" class="headerlink" title="双绞铜线"></a>双绞铜线</h4><p>最便宜且最常用的导引型传输媒体，它一直用于电话网。</p>
<p><strong>无屏蔽双绞线（UTP）</strong>常用在建筑物内的计算机网络中。</p>
<h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><p>能够达到较高的数据传输速率，在电视系统中相当普遍，它能被用作导引型<strong>共享媒体</strong>。</p>
<h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p>一种细而柔软的、能够导引光脉冲的媒体，每个脉冲表示一个比特。一根光纤能够支持极高的比特速率，它们不受电磁干扰，光缆信号衰减极低，且很难窃听。光纤广泛用于因特网的主干。</p>
<h4 id="陆地无线电信道"><a href="#陆地无线电信道" class="headerlink" title="陆地无线电信道"></a>陆地无线电信道</h4><p>承载电磁频谱中的信号。它不需要安装物理线路，并且具有穿透墙壁、提供移动用户的连接以及长距离承载信号的能力。其特性极大的依赖于传播环境和信号传输的距离。</p>
<h4 id="卫星无线电信道"><a href="#卫星无线电信道" class="headerlink" title="卫星无线电信道"></a>卫星无线电信道</h4><p>通信中常使用两类卫星：<strong>同步卫星</strong>和<strong>近地轨道卫星</strong>。</p>
<h2 id="1-3-网络核心"><a href="#1-3-网络核心" class="headerlink" title="1.3 网络核心"></a>1.3 网络核心</h2><h3 id="1-3-1-分组交换"><a href="#1-3-1-分组交换" class="headerlink" title="1.3.1 分组交换"></a>1.3.1 分组交换</h3><p>在源和目的地之间，每个分组都通过通信链路和分组交换机传送。</p>
<p>交换机主要有两类：<strong>路由器</strong>和<strong>链路层交换机</strong>。</p>
<p><strong>1. 存储转发传输</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%BD%91%E7%BB%9C%E6%A0%B8%E5%BF%83.2sxmsvn9z0c0.webp" alt="网络核心"></p>
<p>多数分组交换机在链路的输入端使用存储转发传输机制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%AD%98%E5%82%A8%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.6j52cfr3z1w0.webp" alt="存储转发分组交换"></p>
<p><strong>2. 排队时延和分组丢失</strong></p>
<p>分组交换机具有一个<strong>输出缓存</strong>，它产生了转发时延，除此之外，分组还要承受输出缓存的<strong>排队时延</strong>。</p>
<p>当缓存中的分组完全充满，下一个到达的分组会出现<strong>分组丢失（丢包）</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.2qxupnvoosy0.webp" alt="分组交换"></p>
<p><strong>3. 转发表和路由选择协议</strong></p>
<p>每一个分组包含了一个目的地的IP地址，路由器通过检查其IP地址决定发送哪一个链路。</p>
<p>每台路由器具有一个<strong>转发表</strong>，路由器扫描到达的分组目的地址并在转发表中查找适合的输出链路，将目的地址映射成为输出链路。</p>
<p>因特网具有一些特殊的<strong>路由选择协议</strong>，用于自动地设置这些转发表。</p>
<h3 id="1-3-2-电路交换"><a href="#1-3-2-电路交换" class="headerlink" title="1.3.2 电路交换"></a>1.3.2 电路交换</h3><p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>和<strong>分组交换</strong>。</p>
<p>在分组交换网络中，资源（缓存，链路传输速率）不是预留的，而在电路交换网络中，预留了端系统间沿路径通信所需要的资源（电路交换相当于在到达餐馆之前向餐馆预定位置，即开辟了一条专属电路）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C.2bmctp3hbytc.webp" alt="电路交换网络"></p>
<p><strong>1. 电路交换网络中的复用</strong></p>
<p>链路中的电路交换是通过<strong>频分复用（FDM）</strong>和<strong>时分复用（TDM）</strong>来实现的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%94%B5%E8%B7%AF%E4%BA%A4%E6%8D%A2%E7%BD%91%E7%BB%9C%E7%9A%84%E5%A4%8D%E7%94%A8.1je3xlnlgn9c.webp" alt="电路交换网络的复用"></p>
<p><strong>分组交换的性能优于电路交换的性能。</strong></p>
<h3 id="1-3-3-网络的网络"><a href="#1-3-3-网络的网络" class="headerlink" title="1.3.3 网络的网络"></a>1.3.3 网络的网络</h3><p>网络结构一：所有接入ISP连接独一无二的全球传输ISP。</p>
<p>网络结构二：接入ISP连接不同的多个全球传输ISP，全球传输ISP之间相互连接。</p>
<p>网络结构三：接入ISP连接其所在区域ISP，每个区域ISP连接第一层ISP，在这样关系中每一层都是客户-提供商关系（接入ISP可以直接跳过区域ISP与第一层ISP连接）。</p>
<p><strong>存在点（POP）：</strong>存在于等级结构（网络结构三）的所有层次，底层（接入ISP）等级除外（低等级可以连接高等级中的POP的一台路由器，接入ISP为最底层，没有客户，所以它除外）。</p>
<p><strong>多宿：</strong>任何ISP（除了第一层ISP）可以选择多宿，即可以与两个或多个提供商ISP连接（指低等级可以同时连接多个高等级ISP，第一层ISP是最高层，所以它除外）。</p>
<p><strong>对等：</strong>位于相同等级结构层次的邻近一对的ISP。</p>
<p><strong>因特网交换点（IXP）：</strong>IXP是一个汇合点，多个ISP能够在这里一起对等。</p>
<p>网络结构四：由接入ISP、区域ISP、第一层ISP、POP、多宿、对等和IXP组成。</p>
<p>网络结构五：在网络结构四的顶部增加了<strong>内容提供商网络</strong>。如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/ISP%E7%9A%84%E4%BA%92%E8%81%94.78a59ksyrug0.webp" alt="ISP的互联"></p>
<h2 id="1-4-分组交换网中的时延、丢包和吞吐量"><a href="#1-4-分组交换网中的时延、丢包和吞吐量" class="headerlink" title="1.4 分组交换网中的时延、丢包和吞吐量"></a>1.4 分组交换网中的时延、丢包和吞吐量</h2><h3 id="1-4-1-分组交换网中的时延概述"><a href="#1-4-1-分组交换网中的时延概述" class="headerlink" title="1.4.1 分组交换网中的时延概述"></a>1.4.1 分组交换网中的时延概述</h3><p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E8%8A%82%E7%82%B9%E6%97%B6%E5%BB%B6.1g06tb91b38.webp" alt="节点时延"></p>
<p><strong>节点总时延：</strong>节点处理时延、排队时延、传输时延、传播时延。</p>
<p><strong>处理时延：</strong>检查分组首部和决定将该分组导向何处所需要的时间。</p>
<p><strong>排队时延：</strong>在队列中，分组在链路上等待传输。若该队列是空的，并且当前没有其他分组正在传输，则该分组的排队时延是0。如果流量很大，并且许多其他分组也在等待传输，该排队时延将很长。</p>
<p><strong>传输时延：</strong>将所有分组的比特推向链路所需要的时间。</p>
<p><strong>传播时延：</strong>一旦一个比特被推向链路，该比特需要向下一个路由器传播。从该链路的起点到路由器B传播所需要的时间是传播时延。该比特以该链路的传播速率传播。</p>
<p><strong>传输时延和传播时延的比较：</strong> <strong>传输时延</strong>是路由器推出分组所需要的时间，它是分组长度和链路传输速率的函数，与两台路由器之间的距离无关。<strong>传播时延</strong>是一个比特从一台路由器传播到另一台路由器所需要的时间，它是两台路由器之间距离的函数，与分组长度或链路传输速率无关。</p>
<h3 id="1-4-2-排队时延和丢包"><a href="#1-4-2-排队时延和丢包" class="headerlink" title="1.4.2 排队时延和丢包"></a>1.4.2 排队时延和丢包</h3><p><strong>流量强度：</strong>在估计排队时延的范围方面经常起着重要的作用。<strong>设计系统时流量强度不能大于1。</strong> </p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E5%B9%B3%E5%9D%87%E6%8E%92%E9%98%9F%E6%97%B6%E5%BB%B6%E4%B8%8E%E6%B5%81%E9%87%8F%E5%BC%BA%E5%BA%A6%E7%9A%84%E5%85%B3%E7%B3%BB.43lq389uosc0.webp" alt="平均排队时延与流量强度的关系"></p>
<p><strong>丢包</strong></p>
<p>随着流量强度接近1，排队时延并不真正趋向无穷大。相反，到达的分组将发现一个满的队列。由于没有地方存储这个分组，路由器将<strong>丢弃</strong>该分组，即该分组将会<strong>丢失</strong>。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-第一章 概述" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><p><strong>边缘部分</strong> 由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传达数据、音频或视频）和资源共享。</p>
<p>处在互联网边缘的部分就是连接在互联网上的所有主机。这些主机又称为端系统。ISP不仅仅是向端系统提供服务，它也可以拥有一些端系统。</p>
<p>主机A和主机B进行通信就是指“主机A的某个进程和主机B上的另一个进程进行通信”，“进程”就是“运行着的程序”，也可以简称为“计算机之间通信”。</p>
<p>再网络边缘的端系统之间的通信方式通常可划分为两大类：客户-服务器方式（C&#x2F;S方式）和对等方式（P2P方式）。</p>
<h4 id="客户-服务方式"><a href="#客户-服务方式" class="headerlink" title="客户-服务方式"></a>客户-服务方式</h4><p>互联网最常用的也是最传统的方式。</p>
<p>客户和服务器都是指通信中所涉及的两个应用进程。最主要的特征是：<strong>客户是服务请求方，服务器是服务提供方</strong>。</p>
<p>客户程序和服务器程序通常还具有以下一些特点》</p>
<p><strong>客户程序</strong></p>
<p>1.被用户调用后运行，在通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。</p>
<p>2.不需要特殊的硬件和很复杂的操作系统。</p>
<p><strong>服务器程序</strong></p>
<p>1.是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</p>
<p>2.系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。</p>
<p>3.一般需要有强大的硬件和高级的操作系统支持。</p>
<p>客户和服务器都可发送和接收数据。（客户发送请求，接收服务。服务器接收请求，发送服务）。</p>
<p><strong>客户和服务器本来都指的是计算机进程（软件）。</strong></p>
<h4 id="对等连接方式"><a href="#对等连接方式" class="headerlink" title="对等连接方式"></a>对等连接方式</h4><p><strong>对等连接</strong>，简写为P2P。</p>
<p>对等连接工作方式可支持大量对等用户（如上百万个）同时工作。</p>
<p><strong>核心部分</strong> 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</p>
<p>网络核心部分是互联网中最复杂地部分，因为网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一台主机都能够向其他主机通信。</p>
<p>在网络核心部分起特殊作用的是路由器。路由器是实现分组交换的关键组件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p>
<h4 id="电路交换的主要特点"><a href="#电路交换的主要特点" class="headerlink" title="电路交换的主要特点"></a>电路交换的主要特点</h4><p>若N部电话要两两相连，就需要N（N - 1）&#x2F; 2 对电线。</p>
<p>电话交换机交换的方式一直都是电路交换。</p>
<p><strong>电路交换的方式：</strong>建立连接（占用通信资源）</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-操作系统" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h1><h2 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h2><h2 id="1-2-操作系统的历史"><a href="#1-2-操作系统的历史" class="headerlink" title="1.2 操作系统的历史"></a>1.2 操作系统的历史</h2><h3 id="1-2-1-第一代（1945-1955）：真空管和穿孔卡片"><a href="#1-2-1-第一代（1945-1955）：真空管和穿孔卡片" class="headerlink" title="1.2.1 第一代（1945~1955）：真空管和穿孔卡片"></a>1.2.1 第一代（1945~1955）：真空管和穿孔卡片</h3><p>最早的计算机只是用来做一些简单的数学运算。</p>
<p><strong>穿孔卡片：</strong>将程序写在卡片上，然后读入计算机而不用插件版。</p>
<h3 id="1-2-2-第二代（1955-1965）：晶体管和批处理系统"><a href="#1-2-2-第二代（1955-1965）：晶体管和批处理系统" class="headerlink" title="1.2.2 第二代（1955~1965）：晶体管和批处理系统"></a>1.2.2 第二代（1955~1965）：晶体管和批处理系统</h3><p><strong>晶体管</strong>的发明是计算机变得可靠，可以长时间的运行，完成一些有用的工作，各个人员有了明确的分工，这是的机器被称为<strong>大型机</strong>。</p>
<p>程序员将作业程序写在纸上，然后穿孔成卡片，再将卡片盒带到输入室，交给操作员，直到输出完成。</p>
<p><strong>批处理系统：</strong>减少机时的浪费。</p>
<p>批处理系统的操作步骤如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4.35m41tbnb8y0.webp" alt="批处理系统操作步骤"></p>
<p>每个作业结束后，操作系统自动地从磁带上读入下一个作业并运行。当一批作业完全结束后，操作员取下输入和输出磁带，将输入磁带换成下一批作业，并把输出磁带拿到1401机器上进行<strong>脱机</strong>打印。</p>
<p>典型的输入作业结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%85%B8%E5%9E%8B%E7%9A%84%E8%BE%93%E5%85%A5%E4%BD%9C%E4%B8%9A%E7%BB%93%E6%9E%84.pjdhjkplu8w.webp" alt="典型的输入作业结构"></p>
<p>FMS是第二代大型计算机典型的操作系统。</p>
<h3 id="1-2-3-第三代（1965-1980）：集成电路和多道程序设计"><a href="#1-2-3-第三代（1965-1980）：集成电路和多道程序设计" class="headerlink" title="1.2.3 第三代（1965~1980）：集成电路和多道程序设计"></a>1.2.3 第三代（1965~1980）：集成电路和多道程序设计</h3><p><strong>集成电路：</strong>采用集成电路的机型的价格和性能有很大的提高。</p>
<p><strong>多道程序设计：</strong>将内存分为几个部分，每一部分存放不同的作业，当一个作业等待I&#x2F;O操作完成时，另一个作业可以使用CPU，减少了CPU空闲时间的浪费，在内存中驻留多个作业需要特殊的硬件对其保护，避免作业的信息被窃取或受到攻击。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.1mqj3ts79igw.webp" alt="多道程序设计"></p>
<p><strong>同时的外部设备联机操作（SPOOLing）：</strong>任何时刻当一个作业运行结束时，操作系统就能将一个新作业从磁盘读出，装进空出来的内存区域运行，同时也用于输出，该技术不必再将磁带搬来搬去了。</p>
<p>第三代操作系统实质上仍旧是批处理系统。</p>
<p><strong>分时系统：</strong>对于第三代计算机而言，从一个作业提交到运算结果取出往往长达数小时，当程序中出现错误时无法及时的调试程序，必须等到一个完整的运行周期后才能够更改，这浪费了很多时间，分时系统解决了这样的问题。</p>
<h3 id="1-2-4-第四代（1980年至今）：个人计算机"><a href="#1-2-4-第四代（1980年至今）：个人计算机" class="headerlink" title="1.2.4 第四代（1980年至今）：个人计算机"></a>1.2.4 第四代（1980年至今）：个人计算机</h3><h3 id="1-2-5-第五代（1990年至今）：移动计算机"><a href="#1-2-5-第五代（1990年至今）：移动计算机" class="headerlink" title="1.2.5 第五代（1990年至今）：移动计算机"></a>1.2.5 第五代（1990年至今）：移动计算机</h3><h2 id="1-3-计算机硬件简介"><a href="#1-3-计算机硬件简介" class="headerlink" title="1.3 计算机硬件简介"></a>1.3 计算机硬件简介</h2><p>简单个人计算机中的一些部件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%AE%80%E5%8D%95%E4%B8%AA%E4%BA%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%83%A8%E4%BB%B6.72il126fyq40.webp" alt="简单个人计算机中的一些部件"></p>
<h3 id="1-3-1-处理器"><a href="#1-3-1-处理器" class="headerlink" title="1.3.1 处理器"></a>1.3.1 处理器</h3><p><strong>CPU：</strong>也叫处理器，是计算机的“大脑”。它从内存中取出指令并执行。</p>
<p><strong>CPU基本周期：</strong>从内存中取出指令，解码以确定其类型和操作数，接着执行之，然后取指、解码并执行下一条指令。</p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>​	<strong>程序计数器：</strong>它保存了将要取出的下一条指令的地址。在指令取出后，程序计数器就被更新以便指向后继的指令。</p>
<p>​	<strong>堆栈指针：</strong>它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。</p>
<p>​	<strong>程序状态字寄存器（PSW）：</strong>它包含了条件码位（由比较指令设置）、CPU优先级、模式（用户态或内核态），以及各种其他控制位。在系统调用和I&#x2F;O中，PSW的作用很重要。</p>
<p>操作系统必须知晓所有的寄存器。</p>
<p><strong>流水线：</strong>许多现代的CPU具有同时取出多条指令的机制。</p>
<p><strong>超标量CPU：</strong>比流水线更先进。在这种设计中有许多执行单元，它存在一种隐含的作用，即程序的指令经常不按顺序执行。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E6%B5%81%E6%B0%B4%E7%BA%BF.5tkpzu8fqmg0.webp" alt="流水线"></p>
<p>多数CPU都有两种模式：内核态和用户态，通常在PSW中有一个二进制位控制这两种模式。</p>
<p>​	<strong>内核态：</strong>CPU可以执行指令集中的每一条命令，并且使用硬件的每种功能。操作系统在内核态下运行，从而可以访问整个硬件。</p>
<p>​	<strong>用户态：</strong>用户程序在用户态下运行，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。一般在用户态中有关I&#x2F;O和内存保护的所有指令是禁止的。</p>
<p><strong>系统调用：</strong>为了从系统中获得服务，用户程序必须使用系统调用以陷入内核并调用操作系统。</p>
<h4 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h4><p><strong>线程：</strong>线程是一种轻量级进程，即一个运行中的程序。</p>
<p><strong>多线程或超线程的特性：</strong>多线程允许CPU保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。多线程CPU则可以切换至另一个线程。多线程不能并行处理，在一个时刻只有一个进程在进行，但可以在纳秒数量级的时间内切换线程。</p>
<p>每个线程在操作系统看来就像是单个的CPU。</p>
<p><strong>多核芯片</strong></p>
<p>四核CPU芯片（每一核小芯片都是独立的CPU）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%9B%9B%E6%A0%B8CPU%E8%8A%AF%E7%89%87.5dss541ih2o0.webp" alt="四核CPU芯片"></p>
<p><strong>GPU：</strong>由成千上万个微核组成的处理器。它们更擅长处理大量并行的简单计算。</p>
<h3 id="1-3-2-存储器"><a href="#1-3-2-存储器" class="headerlink" title="1.3.2 存储器"></a>1.3.2 存储器</h3><p>在任何一种计算机中，第二种主要部件都是存储器。</p>
<p>存储器系统采用一种分层次的结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.ww5731ilw34.webp" alt="存储器分层次结构"></p>
<p><strong>寄存器：</strong>CPU中存储器系统的顶层。</p>
<p><strong>高速缓存：</strong>多数由硬件控制。主存被分割为<strong>高速缓存行</strong>。</p>
<p><strong>高速缓存命中：</strong>高速缓存行如果在高速缓存硬件中，称为高速缓存命中，不需要通过总线把访问请求送往主存。高速缓存未命中就必须访问内存，这要付出大量的时间代价。</p>
<p>操作系统一直在使用缓存，以避免重复寻找频繁使用文件的地址。</p>
<p>现代CPU设计了两个缓存：</p>
<p>​	<strong>L1缓存：</strong>称为一级缓存，它总是在CPU中，通常用来解码的指令调入CPU的执行引擎。</p>
<p>​	<strong>L2缓存：</strong>二级缓存，用来存放近来使用过的若干兆字节的内存字。</p>
<p>​	<strong>L1缓存和L2缓存的差别：</strong>差别在于时序。L1缓存的访问不存在任何时延；L2缓存的访问会延时1或2个时钟周期。</p>
<p><strong>主存：</strong>存储器系统的主力。主存通常称为<strong>随机访问存储器（RAM）</strong>。过去有时称为<strong>磁芯存储器</strong>。所有不能在高速缓存中得到满足的访问请求都会转往主存。</p>
<p><strong>非易失性随机访问存储器：</strong>与RAM不同，在电源切断后，非易失性随机访问存储器并丢失其内容。</p>
<p><strong>只读存储器（ROM）：</strong>在工厂就被编程完成，再也不能被修改。ROM速度快且便宜，在一些计算机中用于启动计算机的引导加载模块就存放在ROM中。</p>
<p><strong>EEPROM和闪存：</strong>非易失性的，它们可以擦除和重写，但重写它们需要比写入RAM更高数量级的时间，与ROM的使用方式相同。</p>
<p><strong>闪存：</strong>通常作为便携式电子设备中的存储媒介。其速度介于RAM和磁盘之间。如果闪存的擦除次数过多，就被磨损了。</p>
<p><strong>CMOS：</strong>易失性的。在计算机中用来保持当前时间和日期，即使计算机没有通电，时间也仍然可以正确的更新。</p>
<h3 id="1-3-3-磁盘（硬盘）"><a href="#1-3-3-磁盘（硬盘）" class="headerlink" title="1.3.3 磁盘（硬盘）"></a>1.3.3 磁盘（硬盘）</h3><p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8%E7%9A%84%E6%9E%84%E9%80%A0.6xi3l4gispg0.webp" alt="磁盘驱动器的构造"></p>
<p>磁盘是一种机械装置，所以它是低速的。</p>
<p><strong>固态硬盘：</strong>与磁盘唯一的相似之处在于它也存储了大量即使在关闭电源时也不会丢失的数据。</p>
<p>**存储器管理单元（MMU）:**在CPU中，如图1-6中所示。缓存和MMU的出现对系统的性能有着重要的影响。</p>
<h3 id="1-3-4-I-x2F-O设备"><a href="#1-3-4-I-x2F-O设备" class="headerlink" title="1.3.4 I&#x2F;O设备"></a>1.3.4 I&#x2F;O设备</h3><p>I&#x2F;O设备与操作系统有密切的相互影响。</p>
<p>包括两个部分：设备控制器和设备本身。</p>
<p>​	控制器：插在电路板上的一块芯片或一组芯片，这块电路板物理地控制设备，它从操作系统接收命令，如：从设备读数据，并且完成数据的处理。</p>
<p>​	设备本身：有相对简单的接口，它既不能做很多工作，又已经被标准化了。</p>
<p><strong>串行高级技术附件（SATA）：</strong>计算机的标准硬盘接口。（<strong>高级技术附件（ATA）</strong>）</p>
<p><strong>设备驱动程序：</strong>每类设备控制器都是不同的，为了对不同的软件进行控制，它专门与控制器对话，发出命令并接收响应的软件。</p>
<p><strong>设备驱动程序装入操作系统的三个途径：</strong></p>
<p>​	一：将内核与设备驱动程序重新链接，然后重启系统。如：UNIX系统。</p>
<p>​	二：在操作系统文件中设置一个入口，并通知该文件需要一个设备程序，然后重启系统。在系统启动时，操作系统去寻找所需的设备驱动程序并装载。如：Windows系统。</p>
<p>​	三：操作系统在运行时接受新的设备驱动程序并且立即将其安装好，无需重启系统。该方式采用较少。</p>
<p><strong>中断：</strong>当设备控制器传送完毕被告知要进行读写的字节数量后，会使用特定的总线发信号给中断控制器芯片（如果正忙于一个更高级的中断，也可能不接收）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E4%B8%AD%E6%96%AD%E8%BF%87%E7%A8%8B.35vrfj57onm0.webp" alt="中断过程"></p>
<h3 id="1-3-5-总线"><a href="#1-3-5-总线" class="headerlink" title="1.3.5 总线"></a>1.3.5 总线</h3><p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E6%80%BB%E7%BA%BF.42yhje7g30m0.webp" alt="总线"></p>
<h2 id="1-4-操作系统大观园"><a href="#1-4-操作系统大观园" class="headerlink" title="1.4 操作系统大观园"></a>1.4 操作系统大观园</h2><h3 id="1-4-1-大型机操作系统"><a href="#1-4-1-大型机操作系统" class="headerlink" title="1.4.1 大型机操作系统"></a>1.4.1 大型机操作系统</h3><p>强大的I&#x2F;O处理能力。</p>
<p>系统主要提供三类服务：</p>
<p>​	<strong>批处理：</strong>处理不需要交互式用户干预的周期性作业。如保险公司的索赔处理或连锁商店的销售报告。</p>
<p>​	<strong>事务处理：</strong>负责大量小的请求。如银行的支票处理或航班预订。每个业务量都很小，但是系统必须每秒处理成百上千个业务。</p>
<p>​	<strong>分时：</strong>允许多个远程用户同时在计算机上运行作业，如在大型数据库上的查询。</p>
<h3 id="1-4-2-服务器操作系统"><a href="#1-4-2-服务器操作系统" class="headerlink" title="1.4.2 服务器操作系统"></a>1.4.2 服务器操作系统</h3><p>在服务器上运行，通过网络同时为若干个用户服务，并允许用户共享硬件和软件资源。</p>
<h3 id="1-4-3-多处理器操作系统"><a href="#1-4-3-多处理器操作系统" class="headerlink" title="1.4.3 多处理器操作系统"></a>1.4.3 多处理器操作系统</h3><p>将多个CPU连接成单个系统以获得大量联合计算能力。依据连接和共享方式不同，这些系统称为并行计算机、多计算机或多处理器。</p>
<h3 id="1-4-4-个人计算机操作系统"><a href="#1-4-4-个人计算机操作系统" class="headerlink" title="1.4.4 个人计算机操作系统"></a>1.4.4 个人计算机操作系统</h3><p>现代个人计算机操作系统都支持多道程序处理，在启动时，通常有几十个程序开始运行。它们的功能是为单个用户提供良好的支持。这类系统广泛用于字处理、电子表格、游戏和Internet访问。</p>
<h3 id="1-4-5-掌上计算机操作系统"><a href="#1-4-5-掌上计算机操作系统" class="headerlink" title="1.4.5 掌上计算机操作系统"></a>1.4.5 掌上计算机操作系统</h3><p>如Android系统和iOS系统。</p>
<h3 id="1-4-6-嵌入式操作系统"><a href="#1-4-6-嵌入式操作系统" class="headerlink" title="1.4.6 嵌入式操作系统"></a>1.4.6 嵌入式操作系统</h3><p>在计算机中运行用来控制设备，这种设备不是一般意义上的计算机，并且不允许用户安装软件。如微波炉、电视机、汽车、DVD刻录机、移动电话以及MP3播放器一类的设备。</p>
<h3 id="1-4-7-传感器节点操作系统"><a href="#1-4-7-传感器节点操作系统" class="headerlink" title="1.4.7 传感器节点操作系统"></a>1.4.7 传感器节点操作系统</h3><p>用于建筑物周边保护、国土边界保卫、森林火灾探测、气象预测用的温度和降水测量、战场上敌方运动的信息收集等。如TinyOS操作系统。</p>
<h3 id="1-4-8-实时操作系统"><a href="#1-4-8-实时操作系统" class="headerlink" title="1.4.8 实时操作系统"></a>1.4.8 实时操作系统</h3><p>其特征时将时间作为关键参数。</p>
<p><strong>硬实时系统：</strong>某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。</p>
<p><strong>软实时系统：</strong>可以接受偶尔的违反最终时限，并且不会引起任何永久性的损害。</p>
<h3 id="1-4-9-智能卡操作系统"><a href="#1-4-9-智能卡操作系统" class="headerlink" title="1.4.9 智能卡操作系统"></a>1.4.9 智能卡操作系统</h3><p>一种包含一块CPU芯片的信用卡。</p>
<h2 id="1-5-操作系统概念"><a href="#1-5-操作系统概念" class="headerlink" title="1.5 操作系统概念"></a>1.5 操作系统概念</h2><h3 id="1-5-1-进程"><a href="#1-5-1-进程" class="headerlink" title="1.5.1 进程"></a>1.5.1 进程</h3><p>在所有操作系统中一个重要的概念。与每个进程相关的是<strong>地址空间</strong>。</p>
<p>进程基本上是容纳运行一个程序所需要所有信息的容器。</p>
<p><strong>进程表：</strong>存放每一个进程的所有信息（除了该进程自身地址空间的内容以外）。进程表是数组（或链表）结构，当前存在的每一个进程都要占用其中一项。</p>
<p>一个挂起的进程包括：进程的地址空间和对应的进程表项。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E8%BF%9B%E7%A8%8B%E6%A0%91.f226in1ih1k.webp" alt="进程树"></p>
<p><strong>UID：</strong>系统管理器授权每个进程使用一个给定的UID。每个被启动的进程都有一个启动该进程的用户UID。子进程拥有与父进程一样的UID。</p>
<h3 id="1-5-2-地址空间"><a href="#1-5-2-地址空间" class="headerlink" title="1.5.2 地址空间"></a>1.5.2 地址空间</h3><h3 id="1-5-3-文件"><a href="#1-5-3-文件" class="headerlink" title="1.5.3 文件"></a>1.5.3 文件</h3><p>支持操作系统的另一个关键概念。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.7bs6hjcmqos0.webp" alt="文件系统"></p>
<p>绝对路径从根目录开始描述。</p>
<h4 id="特殊文件"><a href="#特殊文件" class="headerlink" title="特殊文件"></a>特殊文件</h4><p>分为两类：<strong>块特殊文件</strong>和<strong>字符特殊文件</strong>。</p>
<p>特殊文件一般保存在&#x2F;dev目录中。</p>
<h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>既与进程有关也与文件有关。一种虚文件，它连接两个进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%AE%A1%E9%81%93%E8%BF%9E%E6%8E%A5%E4%B8%A4%E4%B8%AA%E8%BF%9B%E7%A8%8B.6rogwthl6v00.webp" alt="管道连接两个进程"></p>
<h3 id="1-5-4-输入-x2F-输出"><a href="#1-5-4-输入-x2F-输出" class="headerlink" title="1.5.4 输入&#x2F;输出"></a>1.5.4 输入&#x2F;输出</h3><p>所有的计算机都有输入输出设备。</p>
<h3 id="1-5-5-保护"><a href="#1-5-5-保护" class="headerlink" title="1.5.5 保护"></a>1.5.5 保护</h3><p>保护代码有三个三位字段：一个用于所有者，一个用于与所有者同组的其他成员，一个用于其他人。每个字段有一位读访问，一位写访问，一位执行访问。就是<strong>rwx位</strong>。</p>
<h3 id="1-5-6-shell"><a href="#1-5-6-shell" class="headerlink" title="1.5.6 shell"></a>1.5.6 shell</h3><p>终端用户与操作系统之间的接口。</p>
<h2 id="1-6-系统调用"><a href="#1-6-系统调用" class="headerlink" title="1.6 系统调用"></a>1.6 系统调用</h2><p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8read.3fthcb1ywlm0.webp" alt="系统调用read"></p>
<p><strong>内核态：</strong>也称管态、核心态。软件最基础的部分是操作系统，它运行在内核态。</p>
<p><strong>用户态：</strong>软件其余部分的运行场所。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/POSIX%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.1clx2ez9jo80.webp" alt="POSIX系统调用"></p>
<p>上图各项管理的详解见书P31.</p>
<h2 id="1-7-操作系统结构"><a href="#1-7-操作系统结构" class="headerlink" title="1.7 操作系统结构"></a>1.7 操作系统结构</h2><h3 id="1-7-1-单体系统"><a href="#1-7-1-单体系统" class="headerlink" title="1.7.1 单体系统"></a>1.7.1 单体系统</h3><p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E5%8D%95%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B.3osn279iao80.webp" alt="单体系统结构模型"></p>
<p><strong>单体系统基本结构：</strong></p>
<p>​	1. 主程序，用来处理服务过程请求。</p>
<p>​	2. 服务过程，用来执行系统调用。</p>
<p>​	3. 实用过程，用来辅助服务过程。</p>
<p>操作系统支持可装载的扩展，如I&#x2F;O设备驱动和文件系统。这些部件可以按照需要载入。在UNIX中被称为<strong>共享库</strong>，在Windows中被称为<strong>动态链接库（DLL）</strong>。他们的扩展类型为.dll，在C:\Windows\system32目录下存在1000多个DLL文件。</p>
<p><strong>单体系统中每一个过程都相互关联，当一个过程崩溃会连累整个系统。</strong></p>
<h3 id="1-7-2-层次式系统"><a href="#1-7-2-层次式系统" class="headerlink" title="1.7.2 层次式系统"></a>1.7.2 层次式系统</h3><p>THE系统是一个层次式系统：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/THE%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.4d5xl7r1zkq.webp" alt="THE操作系统结构"></p>
<h3 id="1-7-3-微内核"><a href="#1-7-3-微内核" class="headerlink" title="1.7.3 微内核"></a>1.7.3 微内核</h3><p>为了实现高可靠性，将操作系统划分成小的、良好定义的模块，只有其中一个模块——微内核——运行在内核态，其余的模块由于功能相对弱些，则作为普通用户进程运行。这样当计算机某个设备出现错误不会导致整个计算机垮掉，这与单体系统相反。</p>
<p><strong>微内核体现了操作系统中模块化的思想，MINIX3就是采用的微内核思想。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/MINIX3%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.6lhuc3jos180.webp" alt="MINIX3系统结构"></p>
<h3 id="1-7-4-客户端-服务器模式"><a href="#1-7-4-客户端-服务器模式" class="headerlink" title="1.7.4 客户端-服务器模式"></a>1.7.4 客户端-服务器模式</h3><p>微内核思想的略微变体：<strong>服务器</strong>，每个服务器提供某种服务；<strong>客户端</strong>，使用这些服务。这个模式就是所谓的<strong>客户端-服务器</strong>模式。该模式的本质是存在客户端进程和服务器进程。</p>
<p>客户端-服务器模式是一种可以应用在单机或者网络机器上的抽象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B.6u8515431zo0.webp" alt="客户端-服务器模型"></p>
<h3 id="1-7-5-虚拟机"><a href="#1-7-5-虚拟机" class="headerlink" title="1.7.5 虚拟机"></a>1.7.5 虚拟机</h3><p>裸机硬件的精确复制品，就是一台虚拟的计算机。不同的虚拟机可以运行不同的操作系统。</p>
<h1 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h1><h2 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1 进程"></a>2.1 进程</h2><p>进程的运行由CPU来管理，严格的来说，在某一瞬间，一个CPU只能运行一个进程，但在一秒钟内可能运行多个进程，也就是说，CPU会有一个进程快速的切换至另一个进程，使每个进程各运行几十或几百毫秒，将这些时间合并为一秒后，CPU就运行了多个进程，但CPU一次只能运行一个进程，只是CPU在运行程序到切换程序的时间极小，人是无法察觉到的，因此就产生并行的错觉。这种快速的切换称为<strong>多道程序设计</strong>。</p>
<h3 id="2-1-1-进程模型"><a href="#2-1-1-进程模型" class="headerlink" title="2.1.1 进程模型"></a>2.1.1 进程模型</h3><p>在进程模型中，计算机上所有可运行的软件，通常也包括操作系统，被组织成若干<strong>顺序进程</strong>，简称<strong>进程</strong>。一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。</p>
<p><strong>一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另一个进程提供服务。</strong></p>
<p><strong>如果一个进程运行了两遍，则算作两个进程。两个不同的进程可以运行相同的程序，但这算作两个进程。</strong></p>
<h3 id="2-1-2-进程的创建"><a href="#2-1-2-进程的创建" class="headerlink" title="2.1.2 进程的创建"></a>2.1.2 进程的创建</h3><p>四种主要事件会导致进程的创建：</p>
<pre><code> 1. 系统初始化（如电脑的开机）
 2. 正在运行的程序执行了创建进程的系统调用
 3. 用户请求创建一个新进程（如打开电脑桌面的一个程序）
 4. 一个批处理作业的初始化（在大型机的批处理系统中应用）
</code></pre>
<p>启动操作系统时通常会创建若干个进程，有些是前台进程，有些是后台进程。</p>
<p>停留在后台处理诸如电子邮件、Web页面、新闻、打印之类活动的进程称为<strong>守护进程</strong>。</p>
<p><strong>进程创建之后，父进程和子进程有各自不同的地址空间。不可写的内存区是共享的，可写的内存是不可以共享的。</strong></p>
<h3 id="2-1-3进程的终止"><a href="#2-1-3进程的终止" class="headerlink" title="2.1.3进程的终止"></a>2.1.3进程的终止</h3><p>进程终止通常由下列条件引起：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.正常退出（自愿）</span><br><span class="line">2.出错退出（自愿）</span><br><span class="line">3.严重错误（非自愿）</span><br><span class="line">4.被其他进程杀死（非自愿）</span><br></pre></td></tr></table></figure>

<h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><p>进程只有一个父进程，但是可以有零个或多个子进程。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程的三种状态：</p>
<p>1.运行态（该时刻进程实际占用CPU）</p>
<p>2.就绪态（可运行，但因为其他进程正在运行而暂时停止）</p>
<p>3.阻塞态（除非某种外部事件发生，否则进程不能运行）</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.py1nfjlqttc.webp" alt="进程的状态之间的转换"></p>
<p>如上图：</p>
<p>​	1.操作系统发现进程不能继续运行下去或等待有效的输入，进入阻塞。</p>
<p>​	2.由进程调度程序引起，当系统认为进程占用处理器时间过长，决定让其他进程使用CPU时间，此时该占用时间过长的进程进入就绪状态。</p>
<p>​	3.由进程调度程序引起，经过一个轮转时间片正在就绪的第一个进程再次占用CPU，进入运行状态。</p>
<p>​	4.当进程等待的一个外部事件发生时（如一些有效输入到达），如果此时没有其他进程运行（占用CPU），该进程便开始运行，否则处于就绪态（等待CPU空闲并轮到它运行）。</p>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p>每个进程占用一个进程表（进程控制块）项，该表项包含了进程状态的重要信息，包括计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他进程由运行态转换到就绪态或阻塞态时必须保存的信息，从而保证该进程随后能再次启动。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E8%BF%9B%E7%A8%8B%E8%A1%A8%E8%A1%A8%E9%A1%B9%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5.3dwuoobrk3e0.webp" alt="进程表表项中的一些字段"></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E4%B8%AD%E6%96%AD%E5%8F%91%E7%94%9F%E5%90%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%80%E5%BA%95%E5%B1%82%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%AD%A5%E9%AA%A4.3anyeq5lt24.webp" alt="中断发生后操作系统最底层的工作步骤"></p>
<p>每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>
<h3 id="多道程序设计模型"><a href="#多道程序设计模型" class="headerlink" title="多道程序设计模型"></a>多道程序设计模型</h3><p>$CPU利用率 &#x3D; 1 - p^n$</p>
<p>p为一个进程等待I&#x2F;O操作的时间与其停留在内存中的时间比</p>
<p>n为内存中同时存在的进程个数</p>
<p>$p^n$为所有n个进程都在等待I&#x2F;O（此时CPU空转）的概率</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>进程有一个地址空间和一个控制线程，经常存在在同一个地址空间准并行运行多个控制线程的情形，这些线程就像分离的进程（共享地址空间除外）。</p>
<h3 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h3><p>线程（轻量级）的创建速度要比进程的创建速度快很多，线程可以提高性能。</p>
<p>一个进程可包括输入线程、处理线程和输出线程三个线程构造。输入线程把数据读入到输入缓冲区中；处理线程从输入缓冲区中取出数据，处理数据，并把结果放到输出缓冲区中；输出线程把这些结果写到磁盘上。按照这种工作方式，输入、处理和输出可以全部同时进行。</p>
<h3 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h3><p>进程用于把资源集中到一起，线程则是在CPU上被调用执行的实体。</p>
<p>线程又称轻量级进程，多线程用来描述在同一个进程中允许多个线程的情形。</p>
<p>一个进程中的多个线程共享同一个地址空间（指进程所在的地址空间）和进程中的资源。</p>
<p>有了线程之后，在单CPU中同一进程中的多线程在CPU中的运行方式和没有线程概念的情况下多个进程在CPU中的运行方式类似，线程在CPU中快速的切换运行。</p>
<p>不同的线程不像不同的进程之间那样存在很大的独立性。进程中的不同线程是为了实际完成同一个作业，不同进程完成的是各自独立的作业。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E5%86%85%E5%AE%B9.4zx2rrctq1k0.webp" alt="进程中所有线程共享的内容"></p>
<p>线程与进程拥有同样的状态：运行、阻塞、就绪、终止。进程中的不同线程可以处于其中状态的任何一个。</p>
<p>​	正在运行的线程拥有CPU并且是活跃的。被阻塞的线程正在等待某个释放它的事件（如键入有效输入）。线程可以被阻塞，以便等待某个外部事件的发生或等待其他线程来释放它。就绪线程可被调度运行，并且只要轮到它就很快可以运行。线程状态之间的转换和进程是一样的。</p>
<h3 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h3><p>用户级线程就是把整个线程包放在用户空间中，内核对线程包一无所知。用户级线程包可以在不支持现成的操作系统上实现。</p>
<p>在用户空间管理线程时，每个进程需要有其专用的线程表，用来跟踪该进程中的线程。该线程表由运行时系统管理。用户级线程允许每个进程有自己定制的调度算法。</p>
<p>用户级线程中如果一个线程开始运行，那么在该进程中的其他线程就不能运行，除非第一个线程自动放弃CPU。</p>
<p>用户级线程的线程表处于进程中。</p>
<h3 id="在内核中实现线程"><a href="#在内核中实现线程" class="headerlink" title="在内核中实现线程"></a>在内核中实现线程</h3><p>内核线程不需要运行时系统。内核线程中的线程表处于内核中。</p>
<p>内核线程中一个进程中的线程被阻塞，内核可以根据其选择运行同一个进程中的其他线程或运行另一个进程中的线程。而用户级线程中，运行时系统始终运行自己进程中的线程，直到内核剥夺它的CPU为止。</p>
<p>在内核中创建或撤销线程的代价比较大，因此在某个线程被撤销时，把它标志为不可运行的，但是内核数据结构没有受到影响。之后在创建新的线程时，就重新启动某个旧线程，从而节省开销。</p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>将用户级线程与内核线程结合，进程中的多个用户级线程多路复用一个内核线程。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-oop" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        
      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/oop/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Linux基础课" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一讲（常用文件管理命令）"><a href="#第一讲（常用文件管理命令）" class="headerlink" title="第一讲（常用文件管理命令）"></a>第一讲（常用文件管理命令）</h1><p><strong>根目录：</strong> &#x2F; 。</p>
<p>根目录中常见的文件：</p>
<p>bin：存放一些常用的可执行文件命令。</p>
<p>etc：存放配置文件。</p>
<p>var：存放日志（log）。</p>
<p>lib：存一些安装包或头文件。</p>
<p>home：所有用户的家目录。</p>
<p>proc：存放进程相关的信息。</p>
<p>root：根用户的目录。</p>
<p><strong>根目录中有许多文件夹，每个文件夹又有许多分支，以上只是常用的文件夹举例。</strong></p>
<h2 id="linux文件结构"><a href="#linux文件结构" class="headerlink" title="linux文件结构"></a>linux文件结构</h2><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="linux:文件结构"></p>
<h2 id="Linux描述路径"><a href="#Linux描述路径" class="headerlink" title="Linux描述路径"></a>Linux描述路径</h2><p><strong>绝对路径（从根目录开始描述的路径）：</strong></p>
<p>&#x2F;home&#x2F;acs&#x2F;main.cpp</p>
<p>第一个 &#x2F; 表示根目录。</p>
<p><strong>相对路径（从当前路径开始去描述路径）：</strong></p>
<p>tmp&#x2F;main.cpp</p>
<p><strong>判断绝对路径与相对路径：看开头是否有 &#x2F; 。</strong></p>
<p><strong>相对路径开头一定不是 &#x2F; 。</strong></p>
<p><strong>‘.’ 表示当前目录，’..’表示上一个目录。</strong></p>
<p>如：</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%B7%AF%E5%BE%84%E6%8F%8F%E8%BF%B0.png" alt="Linux:路径描述"></p>
<p>从tmp文件开始，..&#x2F;tmp&#x2F;.&#x2F;..&#x2F;tmp&#x2F;main.cpp</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%B7%AF%E5%BE%84%E6%8F%8F%E8%BF%B01.png" alt="路径描述1"></p>
<p>最终还是在tmp文件中。</p>
<p>‘~&#x2F;’ 表示家目录。</p>
<p>如：</p>
<p>从bin文件开始，~&#x2F;tmp&#x2F;main.cpp，bin文件不在加目录中，使用’ ~&#x2F; ‘ 返回家目录找到tmp文件中main.cpp。</p>
<p><strong>一个Linux服务器上可以有很多用户。</strong></p>
<p>~&#x2F; 等价于 &#x2F;home&#x2F;acs&#x2F;</p>
<h2 id="常用命令介绍"><a href="#常用命令介绍" class="headerlink" title="常用命令介绍"></a>常用命令介绍</h2><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D.png" alt="常用命令介绍"></p>
<h3 id="ls指令"><a href="#ls指令" class="headerlink" title="ls指令"></a>ls指令</h3><p>ls -l:显示文件的详细信息（第一部分为文件权限，d表示文件夹，-表示普通文件，r表示读，w表示写，x表示执行，这些表示不同的权限，4096和0表示文件大小Aug 17 21:19为创建时间或修改时间，最后面表示文件名）。</p>
<p>![ls–l命令](C:\Users\李浩飞\Desktop\学习文件\Linux截图\ls -l命令.png)</p>
<p>ls -h:表示人性化输出，时用户更好的理解信息（如下图的文件大小信息，任何命令都可以加h）。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/ls%20-h.png" alt="ls-h"></p>
<p><strong>所有以 . 开头的文件都是隐藏文件，若想改为可见文件可输入 mv .(文件名) （文件名） 即可。</strong></p>
<p><strong>将可见文件改为隐藏文件可输入 mv (文件名) .(文件名)。</strong></p>
<p><strong>. 表示当前目录， .. 表示上层目录，它们都表示文件。</strong></p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%8F%AF%E8%A7%81%E6%96%87%E4%BB%B6%E4%B8%8E%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="可见文件与隐藏文件之间的转换"></p>
<p>ls -a:显示所有文件（包括隐藏文件）。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/ls%20--a.png" alt="ls-a"></p>
<p>ls -A:显示所有文件（不显示当前目录和上层目录）。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/ls%20--A%E5%91%BD%E4%BB%A4.png" alt="ls-A命令"></p>
<h3 id="cd指令"><a href="#cd指令" class="headerlink" title="cd指令"></a>cd指令</h3><p>cd:进或返回想要的路径，不加任何参数就会返回家目录，cd可以加任何路径（相对路径和绝对路径都可以）。</p>
<p>cd ..:返回上一层。</p>
<p>cd -：返回上一个呆过的文件。</p>
<h3 id="cp指令"><a href="#cp指令" class="headerlink" title="cp指令"></a>cp指令</h3><p>cp：复制文件命令。</p>
<p>​	cp a&#x2F;tmp.txt b (将a路径中的tmp.txt文件复制到b路径中)。</p>
<p>​	cp a&#x2F;tmp.txt b&#x2F;(将a文件夹中的文件复制到b文件夹中)。</p>
<p>cp 有重命名的效果：cp a&#x2F;tmp.txt b&#x2F;tmp2.txt</p>
<p><strong>cp &#x3D; 复制 + 粘贴 + 重命名。</strong></p>
<p>cp a b -r: 将a目录复制到b目录中。（目录包括所有文件）</p>
<p>复制文件夹一定要加 -r 。</p>
<h3 id="mkdir指令"><a href="#mkdir指令" class="headerlink" title="mkdir指令"></a>mkdir指令</h3><p>mkdir:创建文件夹。</p>
<p>mkdir a:创建文件夹a。</p>
<p><strong>mkdir可以使用绝对路径。</strong></p>
<p><strong>创建的文件夹含有空格时，加转义字符\即可。</strong></p>
<p>mkdir y\ c:创建文件夹’y c’。</p>
<p>对’y c’文件的其它操作方法相同。</p>
<p>mkdir可以创建一串文件夹，mkdir a&#x2F;b&#x2F;c -p。</p>
<h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><p>rm: 删除文件。</p>
<p>rm + 文件名（可以同时删除多个文件）。</p>
<p>若文件的后缀名相同，可以使用 rm *.后缀名删除所有后缀名相同的文件。</p>
<p>如：</p>
<p>​	rm *.txt:删除所有后缀名为txt的文件。</p>
<p>rm . * :删除文件夹内所有的文件</p>
<p>文件夹无法删除，可在删除命令后加 -r 即可。</p>
<p>rm c -r:删除文件夹c。</p>
<h3 id="touch指令"><a href="#touch指令" class="headerlink" title="touch指令"></a>touch指令</h3><p>touch:创建一个文件。</p>
<p><strong>touch与mkdir不同：touch创建一个文件，mkdir创建一个文件夹，文件夹与文件不一样。</strong></p>
<p>rm：删除普通文件。</p>
<p>rm -f:删除被保护的文件。</p>
<p>rm -r: 删除文件夹。</p>
<p>rm -rf:删除文件夹（包括没有删除权限的文件）。</p>
<p>rm a&#x2F;*:删除文件夹a中的所有文件，保留文件夹a。</p>
<h3 id="mv指令"><a href="#mv指令" class="headerlink" title="mv指令"></a>mv指令</h3><p>mv:剪切 + 粘贴（可重命名）。</p>
<p>mv a&#x2F;tmp.txt b&#x2F;:将a中的tmp.txt文件移到b文件夹中。</p>
<p>mv b&#x2F;tmp.txt a&#x2F;tmp2.txt:将b文件夹中的tmp.txt文件移到a文件夹中并重命名为tmp2.txt。</p>
<p>mv tmp2.txt tmp.txt:将文件重命名，但不移动位置。</p>
<p><strong>cp为复制命令，mv为剪切命令。</strong></p>
<h3 id="cat指令"><a href="#cat指令" class="headerlink" title="cat指令"></a>cat指令</h3><p>cat + 文件名：展示文件的内容，文件夹无法cat。</p>
<h1 id="第二讲（tmux和vim"><a href="#第二讲（tmux和vim" class="headerlink" title="第二讲（tmux和vim)"></a>第二讲（tmux和vim)</h1><h2 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h2><h3 id="tmux使用教程"><a href="#tmux使用教程" class="headerlink" title="tmux使用教程"></a>tmux使用教程</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/tumx%E6%95%99%E7%A8%8B1.png" alt="tumx教程1"></p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/tumx%E6%95%99%E7%A8%8B2.png" alt="tumx教程2"></p>
<p><strong>功能：</strong>1. 分屏</p>
<p>​			2.允许断开Terminal连接后，继续运行进程（当电脑断网或关机后，使用tmux不会结束terminal的进程，重新进入terminal，输入tmux a即可进入进程）。</p>
<p>tmux可以开许多session（会话），每一个session可以开很多的window（窗口），每一个window又可以开很多的pane（小窗口），以此类推，如下图：</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/tmux%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="tmux结构图"></p>
<p>每一个pane都是一个最小单位，每一个pane都可以打开一个shell交互（对话框）</p>
<h3 id="tmux操作"><a href="#tmux操作" class="headerlink" title="tmux操作"></a>tmux操作</h3><p><strong>进入tmux</strong></p>
<p>输入tmux后会新建一个session，该session中包含一个window，window又包含一个pane，如下图所示，能看到的窗口就是window页面，window窗口内包含一个pane（如下的对话框）。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/tmux%20window%E9%A1%B5%E9%9D%A2.png" alt="tmux-window页面"></p>
<p><strong>分屏</strong></p>
<p>进入tmux后，按下Ctrl + a后松开，然后按%：将当前pane分为左右两个pane。</p>
<p>按下Ctrl + a后松开，然后按 “ ：将当前pane分为上下两个pane。</p>
<p><strong>关闭分屏</strong></p>
<p>用鼠标选中要关闭的分屏，按下Ctrl + d，就可以关闭选中的pane（分屏）。</p>
<p>如果当前只有一个pane，按下Ctrl + d，pane就会关闭，接下来会关闭window，再接下来会关闭session，就会自动退出terminal。</p>
<p><strong>选中pane</strong></p>
<p>鼠标点击就可以选中pane，使用键盘按下Ctrl + a后松开，然后按方向键，选择相邻的pane。</p>
<p><strong>调整分割线</strong></p>
<p>鼠标拖动分割线调整，使用键盘按住Ctrl + a，同时按下方向键即可调整分割线。</p>
<p><strong>全屏&#x2F;取消全屏</strong></p>
<p>选中当前pane，按下Ctrl + a后松开，按下z即可将选中的pane全屏或取消全屏。</p>
<p><strong>挂起session</strong></p>
<p>按下Ctrl + a后松开，然后按d，挂起session，退出tmux，但tmux中的所有窗口不会关闭。</p>
<p>挂起session并退出tmux后，会出现如下提示，表示将session已挂起。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%8C%82%E8%B5%B7session.png" alt="挂起session"></p>
<p>若想回到之前的session，输入tmux a或tmux attach即可返回挂起的session页面。</p>
<p><strong>选择session</strong></p>
<p>挂起session后输入tmux即可建立另一个session。</p>
<p>当建立多个session后，需要选择session，操作如下：</p>
<p>​	按住Ctrl + a后松开，然后按下s，选择其他session：</p>
<p>​		接下来按住上下方向键选择session</p>
<p>​		按住左右键选择某一个session中的pane</p>
<p><strong>在session中创建和选择window</strong></p>
<p>选中某一个session，按下Ctrl + a后松开，然后按c，在当前session中创建一个新的window。</p>
<p>当创建多个window后，按下Ctrl + a后松开，按下w，即可选择其他window，选择方法与选择session方法相同</p>
<p><strong>阅读内容</strong></p>
<p>按下Ctrl + a后松开，然后按下PageUp或PageDown上下翻阅当前pane的内容。</p>
<p><strong>tmux选中文本并复制</strong></p>
<p>按住shift的同时，按住鼠标选中要复制的文本，选中后按Ctrl + insert复制 ，shift + insert粘贴。</p>
<h2 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h2><h3 id="vim使用教程"><a href="#vim使用教程" class="headerlink" title="vim使用教程"></a>vim使用教程</h3><p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/vim%E6%95%99%E7%A8%8B1.1sq9jwigj2io.webp" alt="vim教程1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/vim%E6%95%99%E7%A8%8B2.7jrskfqs4b80.webp" alt="vim教程2"></p>
<p><strong>功能：</strong></p>
<pre><code>1. 命令行模式下的文本编辑器（可以编辑任何东西，包括C++代码，JAVA等编程语言）。
2. 根据文件扩展名自动判别编程语言（如*.cpp, *.java这样的编程语言扩展名)。支持代码缩进、代码高亮等功能。
3. 使用方式： vim filename
  	1. 如果已有该文件，则会打开它
  	2. 如果没有该文件，则打开一个新的文件，并命名filename。（相当于一个记事本，但该记事本支持各种功能）
</code></pre>
<p><strong>模式</strong></p>
<p>1.一般命令模式</p>
<p>​	默认模式（进到页面后的模式）。命令输入方式：类似于打游戏，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等，但不能进行编辑。</p>
<p>2.编辑模式</p>
<p>在一般命令模式里按下i，进入编辑模式。</p>
<p>按下Esc退出编辑模式，返回一般命令模式。</p>
<p>3.命令行模式</p>
<p>在一般命令模式里按 : &#x2F; ? 三个字母中的任意一个，会进入命令行模式。命令行在最下面。</p>
<p>可以查找、替换、保存、退出、配置编辑器等。</p>
<h3 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h3><p><strong>移动光标</strong></p>
<p>h或左箭头键：光标向左移动一个字符</p>
<p>j或向下箭头：光标向下移动一个字符</p>
<p>k或向上箭头：光标向上移动一个字符</p>
<p>l或向右箭头：光标向右移动一个字符</p>
<p>n<space>:n表示数字，按下数字后再按空格，光标会在当前位置向右移动到这一行的n个字符的后面，该命令可以跳到下一行（在一般命令模式下操作）。</p>
<p>数字0或[Home]键：光标移动到本行开头。</p>
<p>$或[End]键：光标移动到本行末尾。</p>
<p>G：光标移动到最后一行。</p>
<p>:n或 nG ：n为数字，光标移动到第n行。</p>
<p>gg ：光标移动到第一行，相当于1G。</p>
<p>n<Enter>:n为数字，光标向下移动n行。</p>
<p><strong>编辑操作</strong></p>
<p>&#x2F;word：向光标之下寻找第一个值为word的字符串（按回车后光标到达值为word的字符串前方）。</p>
<p>?word：向光标之上寻找第一个值为word的字符串（按回车与上一致）。</p>
<p>n：重复前一个查找操作，如：当查找到第一个字符串后，按下n会查找下一个与之相同的字符串，n会循环查找。</p>
<p>N：反向重复前一个查找操作（查找上一个与之相同的字符串，也是循环查找）。</p>
<p>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</p>
<p>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2</p>
<p>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，且在替换前要求用户确认（查找到的每一个字符串都需要确认）。</p>
<p>v：选中文本（可以进行删除、复制、剪切等操作）。按两下Esc取消选中。</p>
<p>d：删除选中的文本（按下v后选中文本，再按下d删除）。</p>
<p>dd: 删除当前行（不需要选中文本，d和dd操作实际上是剪切，可以粘贴回来）。</p>
<p>Del: 在键盘的功能键中，删除光标后面的字符。</p>
<p>y：复制选中的文本（按下v选中文本后进行）。</p>
<p>yy: 复制当前行（不需要选中文本）。</p>
<p>p: 将复制的数据在光标的下一行&#x2F;下一个位置粘贴（如果是通过选中文本的复制或剪切操作，则会粘贴到下一个位置，不是通过选中文本的复制或剪切操作则是粘贴到下一行）。</p>
<p>u：撤销。</p>
<p>Ctrl + r：取消撤销（返回撤销后的前一个操作）。</p>
<p>大于号 &gt;：将选中的文本整体向右缩进一次。</p>
<p>小于号 &lt;：将选中的文本整体向左缩进一次。</p>
<p>:w 保存。</p>
<p>:w! 强制保存。</p>
<p>:q 退出。</p>
<p>:q! 强制退出（在没有保存文件的情况下，但不想保存使用该操作）。</p>
<p>:wq 保存并退出。</p>
<p>:wq! 强制保存并退出。</p>
<p>:set paste 置成粘贴模式，取消代码自动缩进（进入粘贴模式后，复制代码时不会自动缩进，因为复制的代码是已经缩进好了的，如果粘贴该代码时不开启粘贴模式，会将代码再一次缩进，影响美观，同时还会有时延，可能会卡出来）。</p>
<p>:set nopaste 取消粘贴模式，开启代码自动缩进。</p>
<p>:set nu 显示行号。</p>
<p>:set nonu 隐藏行号（当要复制文本时，需要隐藏行号，否则会将行号一起复制）。</p>
<p>gg&#x3D;G：将全文代码格式化。</p>
<p>:noh 关闭查找关键词高亮。</p>
<p>Ctrl + q：当vim卡死时，可以取消当前正在执行的命令。</p>
<p>异常处理：<br>        每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。<br>        如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：<br>            (1) 找到正在打开该文件的程序，并退出<br>            (2) 直接删掉该swp文件即可</p>
<h1 id="第三讲-shell语法"><a href="#第三讲-shell语法" class="headerlink" title="第三讲 shell语法"></a>第三讲 shell语法</h1><h2 id="讲义"><a href="#讲义" class="headerlink" title="讲义"></a><a target="_blank" rel="noopener" href="https://www.acwing.com/file_system/file/content/whole/index/content/2855883/">讲义</a></h2><h3 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h3><p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/shell%E6%A6%82%E8%AE%BA1.7jbclom1eio0.webp" alt="shell概论1"></p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/shell%E6%A6%82%E8%AE%BA2.1k1qnu327okg.webp" alt="shell概论2"></p>
<p>Linux中常见的shell脚本有很多版本，最常用的版本是bash，Linux系统中一般默认使用bash，所以该shell教程主要讲解bash脚本。</p>
<p>使用bash脚本时，先用vim创建一个脚本文件，然后在文件开头需要加以下语句：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>该语句为指名运行脚本默认的解释器，一定要指名，否则在之后的运用中会报错。 </p>
<h4 id="用解释器执行："><a href="#用解释器执行：" class="headerlink" title="用解释器执行："></a>用解释器执行：</h4><p>图中脚本示例中，echo类似于C++中的cout语句。输入完该语句后，退出文件，输入 bash + 文件名来运行输出语句，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E8%BF%90%E8%A1%8CHello-World.4l8tfi3riyg0.webp" alt="运行Hello-World"></p>
<h4 id="作为可执行文件执行："><a href="#作为可执行文件执行：" class="headerlink" title="作为可执行文件执行："></a>作为可执行文件执行：</h4><p>使用语句 chmod +x 文件名 可以将文件作为可执行文件（x为执行权限），文件最开始的权限如下（没有执行权限）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%89%8D.6s3c5ttytf40.webp" alt="执行命令前"></p>
<p>给文件添加执行权限后如下（x为执行权限，文件名的颜色会改变）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E5%90%8E.7id31molb000.webp" alt="执行命令后"></p>
<p>在当前路径下执行： .&#x2F;文件名</p>
<p>绝对路径执行：&#x2F;home&#x2F;acs&#x2F;文件名</p>
<p>相对路径执行：~&#x2F;文件名</p>
<p>如下：</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6.png" alt="执行文件"></p>
<p><strong>作为可执行文件执行时，该文件一定要有执行权限。</strong></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%B3%A8%E9%87%8A.png" alt="注释"></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%AE%B2%E4%B9%89%20%E5%8F%98%E9%87%8F1.png" alt="讲义-变量1"></p>
<h4 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h4><p><strong>定义变量中，三种方式等价，等号两边不能有空格，定义的变量都是字符串类型。</strong></p>
<h4 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h4><p>$符号相当于是求值，它会将字符串转化为整数，然后再以字符串的形式输出，使用花括号时，可以在花括号后加入其它字符串，两个字符串可以同时输出。如：</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F1.png" alt="使用变量1"></p>
<p>运行结果：</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F2.png" alt="使用变量2"></p>
<h4 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h4><p>类似于C++中的const，这样在定义之后该变量的值无法改变。</p>
<p>readonly + 变量名</p>
<p>declare -r + 变量名</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%AE%B2%E4%B9%89%20%E5%8F%98%E9%87%8F2.png" alt="讲义-变量2"></p>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>unset + 变量名：删除一个变量</p>
<h4 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h4><p>1.自定义变量（局部变量）             </p>
<p>​	子进程不能访问的变量</p>
<p>2.环境变量（全局变量）</p>
<p>​	子进程可以访问的变量</p>
<p>pane就是一个进程</p>
<p>自定义变量改为环境变量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F%E6%94%B9%E4%B8%BA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.6af5ttl9gic0.webp" alt="自定义变量改为环境变量"></p>
<p>bash命令为打开了一个新的bash（子进程），之前的bash（原进程）会进入睡眠状态，exit为退出命令。</p>
<p>环境变量改为自定义变量：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%94%B9%E4%B8%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F.6j6cfckzyco0.webp" alt="环境变量改为自定义变量"></p>
<p>无法访问子进程。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E8%AE%B2%E4%B9%89-%E5%8F%98%E9%87%8F3.3nkfhkzuyl80.webp" alt="讲义-变量3"></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>单引号中的内容会原样输出，一般不会转义，不会执行、不会取变量。</p>
<p>双引号中的内容可以转义，可以执行、可以取变量，不加引号默认为双引号。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89.42n5wbfi9j80.webp" alt="字符串转义"></p>
<p>单引号没有转义出name的内容， \ “hh” \ 也没有被转义。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fei985/img@main/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E4%B9%89%E7%BB%93%E6%9E%9C.6pbldk2zx2w0.webp" alt="字符串转义结果"></p>
<p>双引号中的所有需要转义的内容都被转义，若输出的内容不加双引号，运行的结果与加双引号结果一致。</p>
<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><p>echo $</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-JAVA" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第四章-类与对象"><a href="#第四章-类与对象" class="headerlink" title="第四章 类与对象"></a>第四章 类与对象</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>calss 类名 {</p>
<p>​		类体的内容</p>
<p>}</p>
<h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>​		类体中的内容分为两部分：一部分是变量的声明，另一部分是方法的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="type">float</span> [] a;<span class="comment">//定义成员变量数组a</span></span><br><span class="line">    Workman zhang;<span class="comment">//zhang是Workman类声明的变量，即对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Workman</span>&#123;</span><br><span class="line">    <span class="type">double</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员变量在整个类的所有方法里都有效，其有效性与它在类体中出现的位置无关。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>在类中定义的方法其实就是一个函数，只不过在JAVA中称为方法。</strong></p>
<p><strong>方法与C语言的函数完全相似</strong></p>
<p>当方法中的局部变量与成员变量的名字相同时，如果想在该方法中使用成员变量，必须使用关键字<strong>this</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>, y;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        y = x + <span class="built_in">this</span>.x;<span class="comment">//this.x的值为10,x的值为5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>成员变量是全局变量，有默认值，但方法中的局部变量没有默认值，因此要使用方法中的局部变量时，要保证该局部变量有值。</strong></p>
<p><strong>在定义的类中，只能定义成员变量，不能对成员函数进行操作，要想操作只能在方法中操作。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//可以在声明的同时指定初值</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12.56f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">float</span> b;</span><br><span class="line">    a = <span class="number">12</span>;<span class="comment">//不能声明成员变量后再对成员变量赋值，这种操作只能体现在方法中</span></span><br><span class="line">    b = <span class="number">12.56f</span>;<span class="comment">//非法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构造方法与对象的创建"><a href="#构造方法与对象的创建" class="headerlink" title="构造方法与对象的创建"></a>构造方法与对象的创建</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>每一个类都有一个默认的构造方法，且该构造方法中是无参数的，方法体中也没有语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ladder()&#123;</span><br><span class="line">    <span class="comment">//该方法为Ladder类的默认的构造方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>允许在一个类中编写若干构造方法，但参数的个数不能相同，如果个数相同，则参数的类型不能相同。</p>
<p>如果类中定义了一个或多个构造方法，则默认的构造方法不存在。</p>
<p><strong>构造方法是没有类型的，构造方法只有单独的与类完全相同的名字。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    Point()&#123;<span class="comment">//构造方法，构造方法的名字必须和其所在的类的名字相同</span></span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Point(<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="comment">//构造方法</span></span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">Point</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="comment">//不是构造方法</span></span><br><span class="line">        x = a;</span><br><span class="line">        y = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">Point</span><span class="params">()</span>&#123;<span class="comment">//不是构造方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>对象的声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类的名字 对象的名字;</span></span><br><span class="line">Ladder ladder;<span class="comment">//ladder是Ladder类的对象</span></span><br></pre></td></tr></table></figure>

<p>分配变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象 = new 构造方法名(参数);（若构造方法为默认方法，则没有参数）</span></span><br><span class="line">ladder = <span class="keyword">new</span> <span class="title class_">Ladder</span>();<span class="comment">//默认的构造方法的对象变量分配</span></span><br><span class="line">Ladder(<span class="type">int</span> a, <span class="type">int</span> b)&#123;</span><br><span class="line">    <span class="comment">//类Ladder的构造方法</span></span><br><span class="line">&#125;</span><br><span class="line">ladder = <span class="keyword">new</span> <span class="title class_">Ladder</span>(<span class="number">10</span>, <span class="number">10</span>);<span class="comment">//构造方法的对象变量分配</span></span><br></pre></td></tr></table></figure>

<p>为对象分配变量时要使用new运算符。</p>
<p><strong>当定义了构造方法后，使用默认构造方法为对象分配变量是非法的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ladder = <span class="keyword">new</span> <span class="title class_">Ladder</span>();<span class="comment">//假设Ladder类定义了构造方法Ladder(int a, int b)&#123;&#125;，则该语句是非法的</span></span><br><span class="line"><span class="comment">//可以通过如下方式为对象分配变量</span></span><br><span class="line">ladder = <span class="keyword">new</span> <span class="title class_">Ladder</span>(a, b);<span class="comment">//a, b分别为int型变量</span></span><br></pre></td></tr></table></figure>

<p><strong>当定义多个构造方法后，最好也显式地写出默认的构造方法，这样就不会出现上述默认构造方法为对象分配变量非法的问题了。</strong></p>
<p><strong>没有分配变量的对象称为空对象，空对象不能使用，因此要使用某一个对象时，该对象要先分配变量。</strong></p>
<p>当给对象赋值时，系统会为该对象所在的类中的各个成员变量分配内存，这些成员变量由所赋值的对象管理，也就是说系统会申请一些空间，把被赋值的对象和该类的成员变量捆绑在一起，这些成员变量是属于该对象的。</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E9%87%8F%E5%88%86%E9%85%8D.1u0g0sgl830g.webp" alt="对象的变量分配"></p>
<p>上图中，右边的四个变量为一个类的成员变量，左边是一个对象，使用语句zhubajie &#x3D; new XiyoujiRenwu();后形成上图所示的结构，该对象与类的成员变量捆绑在了一起，这些成员变量属于对象zhubajie的，由该对象来操作管理。</p>
<p>可以创建多个对象：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E5%88%9B%E5%BB%BA%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1.40pjslocrim0.webp" alt="创建多个对象"></p>
<p>每一个对象分配同一个类的成员变量，但它们所属的内存空间是不同的，也就是说两个对象中的成员变量只是名字相同，但实际运用上两者是没有关系的。定义的对象可以理解为C语言中的指针变量，它里面存放的是地址，只不过在JAVA中被称为引用。</p>
<p><strong>new运算符只能和类的构造方法进行运算。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhubajie = <span class="keyword">new</span> <span class="title class_">XiyoujiRenwu</span>();<span class="comment">//new的后面必须是一个构造方法</span></span><br></pre></td></tr></table></figure>

<h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>对象可以访问自己的变量和对方法的调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象.变量;<span class="comment">//通过访问符&quot;.&quot;实现</span></span><br><span class="line">对象.方法;<span class="comment">//对象调用创建它的类中的方法</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的引用和实体"><a href="#对象的引用和实体" class="headerlink" title="对象的引用和实体"></a>对象的引用和实体</h3><p>分配给对象的变量称作对象的实体，分配给对象的变量就是一个类中的成员变量。</p>
<p>空对象即为没有实体的对象，该对象不能被使用，即空对象不能调用方法产生行为。</p>
<p>当使用同一个类创建了两个对象object1和object2并分配变量后可以进行如下赋值操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object2 = object1;</span><br></pre></td></tr></table></figure>

<p>其结构如下图：</p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E7%9B%B8%E5%90%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1.2v9162zwdic0.webp" alt="相同引用的对象"></p>
<p>再输出对象的引用值时，JAVA会添加一个前缀信息类名@，通过语句<code>int address = System.identityHashCode(对象名);</code>会直接输出引用值，不会添加前缀。</p>
<h2 id="参数的传值"><a href="#参数的传值" class="headerlink" title="参数的传值"></a>参数的传值</h2><p><strong>方法被调用时参数变量必须有具体的值。</strong></p>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>指在声明方法时不给出参数列表中从某项开始直至最后一项参数的名字和个数，但这些参数类型必须相同。用“…”表示若干参数。</p>
<p>如<code>public void f(int ... x)</code></p>
<p>则在方法f()的参数列表中的参数都是int型，但参数的个数不确定。</p>
<p>再如<code>public void g(double a, int ... x)</code></p>
<p>在方法g()中的第一个参数是double型，其后都是int型， 但int型参数的个数不确定。</p>
<figure class="highlight plaintext"><figcaption><span>void method(int ... x, int y)```是错误的写法。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述中x是参数代表，对于一个参数代表，x.length等于x所代表的参数的个数。</span><br><span class="line"></span><br><span class="line">参数代表可以用数组的方式来表示,如在上述g()中，x[0], x[1] 分别表示x代表的第2个参数和第3个参数。</span><br><span class="line"></span><br><span class="line">使用可变参数可以用来计算参数个数不确定的运算：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public int getSum(int ... x)&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for (int i = 0; i &lt; x.length; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        sum += x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><figcaption><span>178, 56, 2098)  getSum(1, 2, 3,)```返回了两个参数个数不同的求和结果。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 实例成员与类成员</span><br><span class="line"></span><br><span class="line">成员变量分为实例变量和类变量，类变量（又称static变量、静态变量）用关键字static修饰，否则称为实例变量：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">class Dog&#123;</span><br><span class="line">    float x;//实例变量</span><br><span class="line">    static int y;//类变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不能用static修饰局部变量，类的成员变量是全局变量。</strong></p>
<h3 id="实例变量和类变量的区别"><a href="#实例变量和类变量的区别" class="headerlink" title="实例变量和类变量的区别"></a>实例变量和类变量的区别</h3><p>同一个类创建的不同的对象，他们的<strong>实例变量</strong>是不同的，因为每创建一个对象，分配给不同对象的实例变量占有的内存空间是不同的。改变其中一个对象的实例变量不会影响其他对象的实例变量。没有创建对象，就没有实例变量被分配内存空间。</p>
<p>相反，同一个类创建的不同对象，他们的相同的<strong>类变量</strong>是共享的，改变其中一个对象的类变量，其他对象的该类变量也会改变。每一个对象的类变量存放的是同一个内存空间。</p>
<p><strong>类变量不仅可以通过某个对象访问，也可以直接通过类名访问。</strong></p>
<p><strong>对象的实例变量可以通过该对象访问，但不能使用类名访问。</strong></p>
<h3 id="实例方法和类方法的定义"><a href="#实例方法和类方法的定义" class="headerlink" title="实例方法和类方法的定义"></a>实例方法和类方法的定义</h3><p><strong>用static修饰的方法为类方法，没有static修饰的方法为实例方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">jerry</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//实例方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="comment">//类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">outPut</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="comment">//类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不能用static修饰构造方法。</strong></p>
<h3 id="实例方法和类方法的区别"><a href="#实例方法和类方法的区别" class="headerlink" title="实例方法和类方法的区别"></a>实例方法和类方法的区别</h3><p>在实例方法中不仅可以操作实例变量，也可以操作类变量，实例方法可以调用类中的实例方法和类方法（不包括构造方法）。</p>
<p>类方法不仅可以被类创建的任何对象调用、执行，也可以直接通过类名调用。而实例方法只能由对象来调用。</p>
<p>类方法不能操作实例变量，只能操作类中的类变量，不能调用类中的实例方法，只可以调用类中的类方法。</p>
<h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><h3 id="方法重载的语法规则"><a href="#方法重载的语法规则" class="headerlink" title="方法重载的语法规则"></a>方法重载的语法规则</h3><p><strong>方法重载：</strong>在一个类中可以有多个方法具有相同的名字，但这些方法的参数必须不同，其条件之一为：</p>
<pre><code>1. 参数个数不同。
1. 参数个数相同，但参数列表中对应的某个参数的类型不同。
</code></pre>
<p><strong>构造方法也可以重载，但构造方法不参与和非构造方法之间的比较。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">hello</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> <span class="title function_">hello</span><span class="params">(<span class="type">long</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> <span class="title function_">hello</span><span class="params">(<span class="type">double</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相同参数个数的两个方法中，只要两个方法中的参数有一个类型不同就是重载方法。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p><strong>this可以出现在实例方法和构造方法中，但是不能出现在类方法中。</strong></p>
<h3 id="在构造方法中使用this"><a href="#在构造方法中使用this" class="headerlink" title="在构造方法中使用this"></a>在构造方法中使用this</h3><p>当this关键字出现在类的构造方法中时，代表使用该构造方法所创建的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Peopel</span>&#123;</span><br><span class="line">    <span class="type">int</span> leg, hand;</span><br><span class="line">    String name;</span><br><span class="line">    People(String s)&#123;</span><br><span class="line">        name = s;</span><br><span class="line">        <span class="built_in">this</span>.init();<span class="comment">//this. 可以省略</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        leg = <span class="number">2</span>;</span><br><span class="line">        hand = <span class="number">2</span>;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;有&quot;</span> + hand + <span class="string">&quot;只手&quot;</span> + leg + <span class="string">&quot;条腿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Peopel</span> <span class="variable">bush</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;布什&quot;</span>);<span class="comment">//该语句为创建对象语句，bush是构造方法所创建的对象。构造方法中的this就是对象bush</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在实例方法中使用this"><a href="#在实例方法中使用this" class="headerlink" title="在实例方法中使用this"></a>在实例方法中使用this</h3><p>当this关键字出现在实例方法中时，this就代表正在调用该方法的当前对象。</p>
<p>this. 以及static变量前面的“类名.”通常情况下可以省略，但当实例或static成员变量的名字和局部变量的名字相同时，成员变量前面的“this.”或“类名.”不可以省略。</p>
<h2 id="import语句"><a href="#import语句" class="headerlink" title="import语句"></a>import语句</h2><h3 id="引入类库中的类"><a href="#引入类库中的类" class="headerlink" title="引入类库中的类"></a>引入类库中的类</h3><p>import可以引入不在同一包中的类，比如需要使用JAVA类库中的类，就必须使用import语句。</p>
<p>如果要引入包中所有的类，则可以使用通配符“ * ”来代替。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;<span class="comment">//引入java.util包中的所有类</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;<span class="comment">//只引入java.util包中的Date类</span></span><br></pre></td></tr></table></figure>

<p>引入其他包的类时，创建对象和使用对象的方式不变。</p>
<p><img src="https://cdn.jsdelivr.net/gh/lhfeiie/img@main/import%E8%AF%AD%E5%8F%A5%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.4w5scg0vdym0.webp" alt="import语句注意事项"></p>
<h3 id="引入自定义包中的类"><a href="#引入自定义包中的类" class="headerlink" title="引入自定义包中的类"></a>引入自定义包中的类</h3><p>可以使用import语句引入非类库中有包名的类，如：</p>
<p><code>import tom.jiafei.*;</code></p>
<p>无论源文件有没有包名，该源文件想引入非类库中的包名，只需要让import语句引入的非类库中的类的包名路径的父目录和有包名的源文件的包名的父目录或无包名的源文件的父目录相同即可，也就是说将源文件和要import的包文件放在同一个文件夹中。</p>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>访问限制符private,protected和public用来修饰成员变量（不可以修饰局部变量）或方法（包括构造方法）。</p>
<p><strong>类中的实例方法总是可以操作该类中的实例变量和类变量；类方法总是可以操作该类中的类变量，与访问限制符无关。</strong></p>
<h3 id="私有变量和私有方法"><a href="#私有变量和私有方法" class="headerlink" title="私有变量和私有方法"></a>私有变量和私有方法</h3><p>用关键字private修饰的成员变量和方法称为私有变量和私有方法。</p>
<p><code>private 变量类型 变量名;//定义私有变量</code></p>
<p><code>private 方法类型 方法名()&#123;  &#125;//定义私有方法</code></p>
<p>当在一个类a中用某一个类b创建一个对象b后，对象b不能访问自己的私有变量，调用类b中的私有方法。</p>
<p>如果类b中的某个成员是私有类变量（静态成员变量），那么在另外一个类中也不能通过类名b来操作这个私有变量。私有的类方法也一样。</p>
<p>可以对类中的私有变量进行间接的操作，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (age &gt;= <span class="number">7</span> &amp;&amp; age &lt;= <span class="number">28</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ingt <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example4_19</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">zhang</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">geng</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        zhang.setAge(<span class="number">23</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;zhang的年龄: &quot;</span> + zhang.getAge());</span><br><span class="line">        geng.setAge(<span class="number">25</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;geng的年龄：&quot;</span> + geng.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数中没有对Student类中的私有变量age进行直接的操作，而是通过调用类中的对应的方法来对age进行调整。</p>
<h3 id="公有变量和公有方法"><a href="#公有变量和公有方法" class="headerlink" title="公有变量和公有方法"></a>公有变量和公有方法</h3><p><code>public 变量类型 变量名;//定义公有变量</code></p>
<p><code>public 方法类型 方法名()&#123;  &#125;//定义公有方法</code></p>
<p>公有变量和公有方法可以在任何类中创建的对象来访问。</p>
<h3 id="友好变量和友好方法"><a href="#友好变量和友好方法" class="headerlink" title="友好变量和友好方法"></a>友好变量和友好方法</h3><p>不需要访问限制符的修饰的变量和方法。</p>
<p><code>变量类型 变量名;//定义友好变量</code></p>
<p><code>方法类型 方法名()&#123;  &#125;//定义友好方法</code></p>
<p>在一个类中创建了某一个类的对象后，该对象要想访问自己的友好变量和友好方法，这两个类必须在同一个包中。</p>
<p><strong>如果源文件使用import语句引入了另外一个包中的类，并用该类创建了一个对象，那么该类的这个对象将不能访问自己的友好变量和友好方法。</strong></p>
<h3 id="受保护的成员变量和方法"><a href="#受保护的成员变量和方法" class="headerlink" title="受保护的成员变量和方法"></a>受保护的成员变量和方法</h3><p><code>protected 变量类型 变量名;//定义受保护的变量</code></p>
<p><code>protected 方法类型 方法名()&#123;  &#125;//定义受保护的方法</code></p>
<p>在一个类中创建了某一个类的对象后，该对象要想访问自己受保护的变量和方法，这两个类必须在同一个包中。</p>
<h3 id="public类与友好类"><a href="#public类与友好类" class="headerlink" title="public类与友好类"></a>public类与友好类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//public类</span></span><br><span class="line">    <span class="comment">//可以在任何另外一个类中使用public类创建对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//友好类</span></span><br><span class="line">    <span class="comment">//在另外一个类中使用友好类创建对象时要保证它们在同一个包中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不能用protected和private修饰类（可以修饰内部类）。</strong></p>
<p><strong>访问限制符按访问权限从高到低排列顺序是public $-&gt;$ protected $-&gt;$ 友好的 $-&gt;$ private。</strong></p>
<h2 id="var局部变量"><a href="#var局部变量" class="headerlink" title="var局部变量"></a>var局部变量</h2><p><strong>仅限于在方法体内使用var声明局部变量。方法的参数和方法的返回类型不可以用var来声明。</strong></p>
<p>在方法的方法体内使用var声明局部变量时，必须显式地指定初值（初值不可以是null），以便编译器可以推断出var所声明的变量的类型，显式地指定初值即<code>var width = 108;</code>，指定初值后该变量只能被修改为同一类型的值。</p>
<p>var与C++中的auto类似。</p>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>对象数组即为数组元素为对象的数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Student [] stu;<span class="comment">//定义Student类的对象数组stu</span></span><br><span class="line">stu = <span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">10</span>];<span class="comment">//定义了十个元素，但此时的对象都为空对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stu.length; i ++ )&#123;</span><br><span class="line">    stu[i] = <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//创建对象stu[i],此时的对象已分配Student类中的成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章-子类与继承"><a href="#第五章-子类与继承" class="headerlink" title="第五章 子类与继承"></a>第五章 子类与继承</h1><h2 id="子类与父类"><a href="#子类与父类" class="headerlink" title="子类与父类"></a>子类与父类</h2><p>在JAVA中，子类只能有一个父类。</p>
<h3 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h3><p>使用关键字extends来定义一个类的子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class 子类名 extends 父类名&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="comment">//把Student类定义为People类的子类，People类是Student类的父类（超类）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类的树形结构"><a href="#类的树形结构" class="headerlink" title="类的树形结构"></a>类的树形结构</h3><p>如果C是B的子类，B又是A的子类，习惯上称C是A的子孙类。在树形结构中，根结点是所有类的祖先类，任何类都是该类的子孙类。一个类可以有多个或零个子类，但子类不能有两个或两个以上的父类。</p>
<h2 id="子类的继承性"><a href="#子类的继承性" class="headerlink" title="子类的继承性"></a>子类的继承性</h2><p>子类继承父类的成员变量作为自己的一个成员变量，子类继承父类的方法作为子类中的一个方法。父类中的成员变量或方法，可以被子类中自己定义的任何实例方法调用。</p>
<h3 id="子类和父类在同一包中的继承性"><a href="#子类和父类在同一包中的继承性" class="headerlink" title="子类和父类在同一包中的继承性"></a>子类和父类在同一包中的继承性</h3><p>如果子类和父类在同一包中，那么子类自然地<strong>继承了其父类中不是private的成员变量</strong>作为自己的成员变量，并且也自然地继承了父类中不是private的方法作为自己的方法，继承的成员变量或方法的访问权限保持不变。</p>
<h3 id="子类和父类不在同一包中的继承性"><a href="#子类和父类不在同一包中的继承性" class="headerlink" title="子类和父类不在同一包中的继承性"></a>子类和父类不在同一包中的继承性</h3><p>当子类和父类不在同一包中时，子类<strong>只继承父类中的protected和public访问权限的成员变量或方法</strong>作为子类的成员变量或方法。</p>
<h3 id="protected的进一步说明"><a href="#protected的进一步说明" class="headerlink" title="protected的进一步说明"></a>protected的进一步说明</h3><p>类A、B、C、D的继承关系如下：</p>
<p>A $&lt;-$ B $&lt;-$ C $&lt;-$ D</p>
<p>此时创建一个类Other，并创建一个D类对象object:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Other</span>&#123;</span><br><span class="line">    <span class="type">D</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以下情况object对象可通过“.”运算符访问protected变量和方法：</p>
<pre><code> 1. 对于子类D自己声明的protected成员变量或方法，只要Other类和D类在同一个包中，object对象就可以访问这些protected成员变量和方法。
 2. 对于子类D从父类继承的protected成员变量或方法，需要追溯到这些protected成员变量或方法所在的“祖先”类，假设D类中继承的protected变量或方法是在其祖先类A创建的，那么Other类要和A类在同一个包中，object对象才能访问继承的protected变量或方法（此时Other类中的object对象是子类D所创建的）。
</code></pre>
<p>也就是说protected变量或方法最初是在哪里创建的，那么不属于继承关系的类所创建的对象（创建该对象的类中存在protected变量或方法，此变量或方法也许是创建该对象的类创建的，也许是创建该对象的类继承的父类所创建的，不管怎样，只追究该变量或方法的出生地所在的类）若想使用该protected变量或方法，就必须使该类与最初创建protected变量或方法的类在同一包中。</p>
<h2 id="子类与对象"><a href="#子类与对象" class="headerlink" title="子类与对象"></a>子类与对象</h2><p>在一个子类中创建一个对象，该对象所分配到的成员变量或方法既包括当前子类新声明的成员变量或方法，还包括其继承的父类中所创建的成员变量或方法，但子类不继承父类的私有成员变量，若子类和父类不在同一包中，子类则不继承父类的友好成员变量。但子类所无法继承父类的私有成员变量和子类与父类不在同一包中情况下父类的友好成员变量依旧为子类所创建的对象分配了内存空间（这样的成员变量在子类中创建的对象是无法使用的）。</p>
<p><strong>子类继承的方法只能操作子类继承的成员变量或未继承的成员变量，不可能操作子类新声明的变量。</strong></p>
<h3 id="instanceof运算符"><a href="#instanceof运算符" class="headerlink" title="instanceof运算符"></a>instanceof运算符</h3><p><code>对象名 instanceof 类名</code></p>
<p>在上述表达式中，若左边的对象是右边的类或其子类所创建的对象时，返回的结果是true，否则为false。总结为右边的类是左边创建此对象的类的当前类或父类时，返回结果为true，否则为false。也就是说，把左边的对象用创建此对象的类来代替，此时比较左边和右边两个类，只要右边的类等级大于等于左边的类等级，就返回true，否则返回false。</p>
<h2 id="成员变量的隐藏和方法重写"><a href="#成员变量的隐藏和方法重写" class="headerlink" title="成员变量的隐藏和方法重写"></a>成员变量的隐藏和方法重写</h2><h3 id="成员变量的隐藏"><a href="#成员变量的隐藏" class="headerlink" title="成员变量的隐藏"></a>成员变量的隐藏</h3><p>在编写子类时仍然可以声明成员变量，一种特殊的情况是所声明的成员变量的名字和从父类继承来的成员变量的名字相同（声明的类型可以不同），在这种情况下子类就会隐藏所继承的变量（隐藏的成员变量的类型可以相同也可以不同，只要子类和父类的成员变量名字相同，就可以实现成员变量的隐藏）。</p>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheapGoods</span> <span class="keyword">extends</span> <span class="title class_">Goods</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;<span class="comment">//此时隐藏了其继承的Goods类中的成员double型变量weight</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>子类继承的方法（在父类中创建的方法）可以操作子类继承和隐藏的成员变量，不可以操作子类新声明的成员变量。子类新定义的方法可以操作子类继承和子类新声明的成员变量，但无法操作子类隐藏的成员变量（该子类的父类中的成员变量）。也就是说，在成员变量隐藏的情况下，方法是在哪个类中建立的，那么这个方法只能操作该方法所在类的对应的已对做隐藏操作的成员变量（若子类新定义的方法想操作子类隐藏的成员变量，需使用super关键字）。</strong></p>
<h3 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h3><p>子类通过重写可以隐藏已继承的方法。<strong>如果子类可以继承父类的方法，那么子类就有权利重写这个方法（不包括final方法）</strong>。</p>
<p><strong>方法重写与成员变量的隐藏类似，不同的是隐藏父类的成员变量时子类中的成员变量要与父类中的成员变量类型不同，而方法重写没有此要求。</strong></p>
<p>方法重写：子类中定义一个方法，这个方法的类型和父类的方法的类型一致或是父类的方法的类型的子类型（指如果父类的方法的类型是“类”，那么允许子类的重写方法的类型是“子类”），并且这个方法的名字、参数个数、参数的类型和父类的方法完全相同。</p>
<p><strong>父类的方法一旦被子类重写，那么子类对象只能调用重写后的方法。重写方法既可以操作继承的成员变量、调用继承的方法，也可以操作子类新声明的成员变量、调用新定义的其他方法，但无法操作被子类隐藏的成员变量和方法。</strong></p>
<p>在重写父类的方法时，不允许降低方法的访问权限，但可以提高访问权限。<strong>访问限制符按访问权限从高到低排列顺序是public $-&gt;$ protected $-&gt;$ 友好的 $-&gt;$ private。</strong></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E9%87%8D%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9.4krvqsdxa7q0.webp" alt="重写的注意事项"></p>
<h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><h3 id="用super操作被隐藏的成员变量和方法"><a href="#用super操作被隐藏的成员变量和方法" class="headerlink" title="用super操作被隐藏的成员变量和方法"></a>用super操作被隐藏的成员变量和方法</h3><p>super关键字用于操作被子类隐藏的成员变量和被子类隐藏了继承的方法。</p>
<p>super使用方法：<code>super.被隐藏的成员变量或方法</code></p>
<h3 id="使用super调用父类的构造方法"><a href="#使用super调用父类的构造方法" class="headerlink" title="使用super调用父类的构造方法"></a>使用super调用父类的构造方法</h3><p>当用子类的构造方法创建一个子类的对象时，子类的构造方法总是先调用父类的某个构造方法。也就是说，如果子类的构造方法没有明显地指明使用父类的哪个构造方法，子类就调用父类的不带参数的构造方法。</p>
<p>当子类创建一个构造方法后，子类是不会继承父类的构造方法，但是该子类的构造方法会调用父类中默认的构造方法，如果父类中有多个构造方法，可使用super关键字来让子类的构造方法决定调用父类中的哪一个构造方法。</p>
<p><strong>super关键字必须是子类构造方法中的第一句话，如果在子类的构造方法中没有显式地写出super关键字，那么默认的调用父类的默认构造方法(<code>super();</code>)，如下所示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>();<span class="comment">//super中没有参数，因此就会调用父类中默认的构造方法，此语句可写可不写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当父类中有两个或多个构造函数时，通过super关键字来选择调用哪一个</span></span><br><span class="line"><span class="comment">//假设父类中有构造方法Student()&#123;&#125;和Student(int number, String name)&#123;&#125;两个构造方法</span></span><br><span class="line"><span class="built_in">super</span>(number, name);<span class="comment">//通过super关键字来让子类构造函数调用Student(int number, String name)&#123;&#125;构造方法，super中的参数名要与被调用的构造函数的参数名和参数个数相同</span></span><br></pre></td></tr></table></figure>

<p><strong>当创建了多个构造方法，应当把默认的构造方法显式地写出来，因为当定义了一个或多个构造方法后不再提供默认的构造方法，此时需要把默认的构造方法显式地写出来，这样在子类调用父类的默认构造函数中不会报错。</strong></p>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><h3 id="final类"><a href="#final类" class="headerlink" title="final类"></a>final类</h3><p>final类不能被继承，即不能有子类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="final方法"><a href="#final方法" class="headerlink" title="final方法"></a>final方法</h3><p>如果用final修饰父类中的一个方法，那么这个方法不允许子类重写，也就是说不允许子类隐藏可以继承的final方法。</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>如果成员变量或局部变量被修饰为final，那么他就是常量。常量没有默认值，所以在声明常量时必须指定初值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.1415926</span>;<span class="comment">//PI是常量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="keyword">final</span> <span class="type">double</span> r)</span>&#123;</span><br><span class="line">        <span class="comment">//也可以在类的方法中的参数设定常量，参数r是常量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象的上转型对象"><a href="#对象的上转型对象" class="headerlink" title="对象的上转型对象"></a>对象的上转型对象</h2><p>当用子类创建一个对象b，然后把b的引用放到父类的对象a中，此时称a是b的上转型对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Animal a;</span><br><span class="line"><span class="type">Tiger</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tiger</span>();<span class="comment">//Animal是Tiger的父类</span></span><br><span class="line">a = b;<span class="comment">//a是上转型对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上述写法可简写为如下</span></span><br><span class="line">Animal a;</span><br><span class="line">a = <span class="keyword">new</span> <span class="title class_">Tiger</span>();</span><br></pre></td></tr></table></figure>

<p>上转型对象的实体是子类负责创建的，但上转型对象（a）会失去原对象（b）的一些属性和功能。</p>
<p><strong>1.上转型对象不能访问子类新增的成员变量，不能调用子类新增的方法。</strong></p>
<p><strong>2.上转型对象可以访问子类继承或隐藏的成员变量，也可以调用子类继承的方法或子类重写的实例方法。</strong></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%AF%B9%E8%B1%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.13ujdr53r668.webp" alt="上转型对象示意图"></p>
<p><strong>子类隐藏的变量和子类重写的方法不是指父类中对应的变量和方法，而是指隐藏后的新变量和重写后的新方法。</strong></p>
<p><strong>如果子类重写了父类的静态方法，那么子类对象的上转型对象不能调用子类重写的静态方法，只能调用父类的静态方法。</strong></p>
<h2 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h2><p>若一个类有很多子类，并且这些子类都重写了父类中的某个方法，那么当把子类创建的对象的引用放到一个父类的对象中时就得到了该对象的一个上转型对象，这个上转型对象在调用这个方法时就可能具有多种形态，因为不同的子类在重写父类的方法时可能产生不同的行为。</p>
<p>因为上转型对象可以调用子类重写的方法，因此当多个相同级别的子类重写了其父类的一个方法，此上转型对象在分别调用这些同等级别的子类的重写方法时就具有了多态性(上转型对象在调用子类重写方法时要先把子类创建的对象赋值给父类创建的对象，使得父类对象是被调用的子类对象的上转型对象，这样上转型对象才可以调用)。</p>
<h2 id="abstract（抽象）类和abstract方法"><a href="#abstract（抽象）类和abstract方法" class="headerlink" title="abstract（抽象）类和abstract方法"></a>abstract（抽象）类和abstract方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//A类为abstract类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>;<span class="comment">//方法min为abstract方法，无方法体</span></span><br></pre></td></tr></table></figure>

<p>abstract声明的方法不能有方法体，而且不允许使用final和abstract同时修饰一个方法或类，也不允许使用static和private修饰abstract方法。</p>
<p><strong>abstract类中可以有abstract方法也可以没有abstract方法，但非abstract类中不可以有abstract方法。</strong></p>
<p><strong>abstract类不能用new标识符创建该abstract类的对象。如果一个抽象类的子类是非抽象类，那么这个非抽象类必须重写父类的抽象方法（即去掉abstract的修饰），给出方法体，因此final和abstract不能同时修饰一个方法。</strong></p>
<p><strong>如果抽象类的子类是抽象类，那么子类可以重写父类的抽象方法也可以继承父类的抽象方法。</strong></p>
<p>虽然不能使用new标识符对abstract类创建对象，但该对象可以成为其子类对象的上转型对象，那么该对象就可以调用子类重写的方法。</p>
<ol>
<li><p>抽象类可以抽象出重要的行为标准，该行为标准用抽象方法来表示，即抽象类封装了子类必须要有的行为标准。</p>
</li>
<li><p>抽象类声明的对象可以成为其子类的对象的上转型对象，调用子类重写的方法，即体现子类根据抽象类中的行为标准给出的具体行为。</p>
</li>
</ol>
<p><strong>抽象类中的抽象方法可以由子类去实现，即行为标准的实现由子类完成。</strong></p>
<p>在设计程序时经常会使用abstract类，其原因是abstract类只关心操作（只提供方法，不提供方法体），不关心这些操作具体的实现细节（由它的非抽象子类去实现细节，提供方法体）。</p>
<p>由于抽象类的非抽象子类必须要重写其父类的抽象方法，因此当含有抽象方法的抽象类拥有多个非抽象子类时，并分别把这些子类创建的对象的引用放到父类的对象中时就得到了这些对象的一个上转型对象（每一个子类对象都有与之对应的上转型对象，总共有多个上转型对象），这些上转型对象在调用各自对应的（子类中）重写方法时就具有多态。</p>
<h2 id="面向抽象编程"><a href="#面向抽象编程" class="headerlink" title="面向抽象编程"></a>面向抽象编程</h2><p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B1.3xvxnr7ivqk0.webp" alt="面向抽象编程1"></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B2.6ogh93m4ttc0.webp" alt="面向抽象编程2"></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B3.7knw56udxa80.webp" alt="面向抽象编程3"></p>
<p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B4.4zl5v10zjxg0.webp" alt="面向抽象编程4"></p>
<h2 id="开-闭原则"><a href="#开-闭原则" class="headerlink" title="开-闭原则"></a>开-闭原则</h2><p>开-闭原则就是让设计的系统对扩展开放，对修改关闭。这样系统是易维护的，因为在系统中增加新的模块时不必去修改系统中的核心模块。</p>
<h1 id="第六章-接口与实现"><a href="#第六章-接口与实现" class="headerlink" title="第六章 接口与实现"></a>第六章 接口与实现</h1><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用关键字interface来定义一个接口。接口的定义和类的定义很相似，分为接口声明和接口体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Com</span>&#123;<span class="comment">//接口声明</span></span><br><span class="line">    ...<span class="comment">//接口体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口声明：<code>interface 接口的名字</code></p>
<p>接口体中可以有抽象方法和常量，接口体中所有抽象方法和static常量的访问权限一定都是public，而且允许省略public和abstract，public、final和static修饰符，因此接口体中不会有变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//等价写法：int MAX = 100;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;<span class="comment">//等价写法：void add();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//等价写法：float sum(float x, float y);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口体中的default实例方法：</p>
<p>​	default实例方法在接口体中定义，用关键字default修饰带方法体的实例方法（不可以定义default的static方法），default的实例方法的访问权限必须是public（public修饰符可以省略）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//等价写法：int MAX = 100;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;<span class="comment">//等价写法：void add();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//等价写法：float sum(float x, float y);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="comment">//default方法，default关键字不可以省略，因为在接口体中不允许定义通常的带方法体的public实例方法</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b?a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口体中的static方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">100</span>;<span class="comment">//等价写法：int MAX = 100;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;<span class="comment">//等价写法：void add();</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">sum</span><span class="params">(<span class="type">float</span> x, <span class="type">float</span> y)</span>;<span class="comment">//等价写法：float sum(float x, float y);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;<span class="comment">//default方法，default关键字不可以省略，因为在接口体中不允许定义通常的带方法体的public实例方法</span></span><br><span class="line">        <span class="keyword">return</span> a &gt; b?a : b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;<span class="comment">//static方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;注意是从JAVA SE 8 开始的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口体中的private方法：</p>
<p>​	private方法用来配合接口中的default实例方法，即接口可以将某些算法封装在private的方法中，供接口中的default实例方法调用，实现算法的复用。</p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>在JAVA中接口由类来实现，以便类使用接口中的方法。在类中需要使用关键字implements来声明该类实现一个或多个接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Com</span> <span class="comment">//实现一个接口</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Com</span>, Addable <span class="comment">//实现多个接口，接口名之间用逗号隔开</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> <span class="keyword">implements</span> <span class="title class_">Eatable</span>, Sleepable <span class="comment">//Animal的Dog子类实现接口</span></span><br></pre></td></tr></table></figure>

<p>如果一个类实现了某个接口，那么这个类就自然拥有了接口中的常量、default方法(也就是说该类可以使用接口中任何该类所拥有的东西)，该类也可以重写接口中的default方法（重写时要去掉default关键字，在接口体中创建default方法时public可以省略，但是类重写该default方法时必须要加上public）。如果一个非抽象类实现了某个接口，那么这个类必须重写该接口中的所有抽象方法。如果是抽象类实现了某个接口，该类可以选择重写接口的抽象方法或直接拥有接口的抽象方法。</p>
<p><strong>类实现某接口，但类不拥有接口的static方法和private方法。接口中除了private方法以外，其他方法的访问权限默认都是public，重写时不可省略public。</strong></p>
<p>可以用接口名访问接口常量、调用接口中的static方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Com.MAX;</span><br><span class="line">Com.f();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">    <span class="comment">//public接口可以被任意一个类实现</span></span><br><span class="line">&#125;</span><br><span class="line">interface 接口名&#123;</span><br><span class="line">    <span class="comment">//友好接口可以被与该接口在同一包中的类实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如果父类实现了某个接口，那么子类也就自然实现了该接口，子类就不必再显式地使用关键字implements声明实现这个接口。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//接口也可以被继承，如此代码表示接口B是接口A的子接口，因为接口中的方法和常量都是public的，所以子接口会继承父接口中的全部实例方法和常量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>import既可以引入包中的类，也可以引入包中的接口，类和接口放在同一个包中。</strong></p>
<h2 id="接口的UML图"><a href="#接口的UML图" class="headerlink" title="接口的UML图"></a>接口的UML图</h2><p><img src="https://cdn.staticaly.com/gh/lhfeiie/img@main/%E6%8E%A5%E5%8F%A3%E7%9A%84UML%E5%9B%BE.59jkl293agk0.webp" alt="接口的UML图"></p>
<h2 id="接口回调"><a href="#接口回调" class="headerlink" title="接口回调"></a>接口回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Com com;<span class="comment">//用接口名Com声明com变量，com称为接口变量，与类的声明对象类似</span></span><br></pre></td></tr></table></figure>

<p>接口变量属于引用型变量，在接口变量中可以存放实现该接口的类的实例的引用，即存放对象的引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Com</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();<span class="comment">//创建对象</span></span><br><span class="line"></span><br><span class="line">com = a;<span class="comment">//将a对象的引用赋值给com</span></span><br></pre></td></tr></table></figure>


      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/JAVA/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-Django框架课" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="第一讲-课程概论和Python3语法"><a href="#第一讲-课程概论和Python3语法" class="headerlink" title="第一讲 课程概论和Python3语法"></a>第一讲 课程概论和Python3语法</h1><h2 id="Python-教程"><a href="#Python-教程" class="headerlink" title="Python 教程"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/tutorial/index.html">Python 教程</a></h2><p> 编写Python语言时，首先在前两行加入如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python3</span></span><br><span class="line"><span class="comment">#-*- coding: utf-8 -*-</span></span><br></pre></td></tr></table></figure>

<p>在AC Terminal中运行Python代码输入<code>python3 文件名</code>即可，或者将存有Python代码的文件作为可执行文件，然后输入<code>./文件名</code>即可。（直接运行脚本）</p>
<p>在本地编写代码：输入<code>python</code>、<code>python3</code>或<code>ipython3</code>即可在本地编写python代码，<code>python</code>为python2版本，<code>python3</code>为python3版本，<code>ipython3</code>支持高亮模式，功能更全面。（交互式运行）交互式运行可以支持一句话一句话执行。</p>
<p>python注释用<code>#</code>表示。</p>
<h3 id="Python用作计算器"><a href="#Python用作计算器" class="headerlink" title="Python用作计算器"></a>Python用作计算器</h3><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p>直接输入表达式即可得到计算结果。</p>
<p>除法运算（&#x2F;）返回浮点数，（&#x2F;&#x2F;）返回整数。</p>
<p>乘法运算中（**）表示计算乘方，<code>5 ** 2</code>表示五的二次方，得到的结果为二十五。</p>
<p>取模与C++一样。</p>
<p><strong>Python取整方式为向下取整，而C++为向零取整。<code>-1 // 3</code>在Python中得到的结果为1，<code>-1 / 3</code>在C++中得到的结果为0.</strong></p>
<p>变量赋值不需要定义变量，可直接对变量赋值：<code>width = 20</code>,在C++中需要定义变量width来表示它是什么类型，而Python不需要定义。</p>
<p><strong>如果表达式中既有整数又有浮点数，得到的结果为浮点数。</strong></p>
<p>上次输出的表达式会赋给变量<code>_</code>(下划线),用该变量计算更简单，比如上次输出的结果为14.0，那么<code>_</code>的值为14.0，<code>_ * 2</code>得到的值为28.0，此时<code>_</code>又会更新为28.0。</p>
<p><code>round(x, n)</code>表示保留x的n位小数。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>不管是单引号还是双引号，其中的内容都可以表示为字符串。（C++或JAVA中单引号表示字符，双引号表示字符串）</p>
<p>在单引号之间想输出一个单引号可以将其转义，<code>&#39;doesn\&#39;t&#39;</code>输出为<code>&quot;doesn&#39;t&quot;</code>（交互式解释器会为输出的字符串加注引号，若转义单引号，则加注双引号，反之加注单引号）。单引号中的双引号不需要转义，双引号中的单引号不需要转义，只有最外层为双引号中的双引号和最外层为单引号之间的单引号需要转义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;spam eggs&#x27;</span>  <span class="comment"># single quotes</span></span><br><span class="line"><span class="string">&#x27;spam eggs&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;doesn\&#x27;t&#x27;</span>  <span class="comment"># use \&#x27; to escape the single quote...</span></span><br><span class="line"><span class="string">&quot;doesn&#x27;t&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;doesn&#x27;t&quot;</span>  <span class="comment"># ...or use double quotes instead</span></span><br><span class="line"><span class="string">&quot;doesn&#x27;t&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&quot;\&quot;Yes,\&quot; they said.&quot;</span></span><br><span class="line"><span class="string">&#x27;&quot;Yes,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span><span class="comment">#最外一层是单引号，因此内容中的单引号不需要转义</span></span><br></pre></td></tr></table></figure>



<p>交互式解释器会为输出的字符串加注引号，特殊字符使用反斜杠转义。虽然，有时输出的字符串看起来与输入的字符串不一样（外加的引号可能会改变），但两个字符串是相同的。如果字符串中有单引号而没有双引号，该字符串外将加注双引号，反之，则加注单引号。也可以使用<code>print()</code>来输出内容（注意不是printf），它会省略两边的引号，并输出转义后的特殊字符：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br><span class="line"><span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;&quot;Isn\&#x27;t,&quot; they said.&#x27;</span>)</span><br><span class="line"><span class="string">&quot;Isn&#x27;t,&quot;</span> they said.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;First line.\nSecond line.&#x27;</span>  <span class="comment"># \n means newline,这样的输出方式不会将\n转义出来</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s  <span class="comment"># without print(), \n is included in the output</span></span><br><span class="line"><span class="string">&#x27;First line.\nSecond line.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(s)  <span class="comment"># with print(), \n produces a new line</span></span><br><span class="line">First line.</span><br><span class="line">Second line.</span><br></pre></td></tr></table></figure>

<p>如果不希望前置 <code>\</code> 的字符转义成特殊字符，可以使用 <em>原始字符串</em>，在引号前添加 <code>r</code> 即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&#x27;C:\some\name&#x27;</span>)  <span class="comment"># here \n means newline!</span></span><br><span class="line">C:\some</span><br><span class="line">ame</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">r&#x27;C:\some\name&#x27;</span>)  <span class="comment"># note the r before the quote</span></span><br><span class="line">C:\some\name</span><br></pre></td></tr></table></figure>

<p>字符串字面值可以包含多行。 一种实现方式是使用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>。 字符串中将自动包括行结束符，但也可以在换行的地方添加一个 <code>\</code> 来避免此情况。 参见以下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;\</span></span><br><span class="line"><span class="string">Usage: thingy [OPTIONS]</span></span><br><span class="line"><span class="string">     -h                        Display this usage message</span></span><br><span class="line"><span class="string">     -H hostname               Hostname to connect to</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出如下（请注意开始的换行符没有被包括在内）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Usage: thingy [OPTIONS]</span><br><span class="line">     -h                        Display this usage message</span><br><span class="line">     -H hostname               Hostname to connect to</span><br></pre></td></tr></table></figure>

<p>字符串可以用 <code>+</code> 合并（粘到一起），也可以用 <code>*</code> 重复：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 3 times &#x27;un&#x27;, followed by &#x27;ium&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span> * <span class="string">&#x27;un&#x27;</span> + <span class="string">&#x27;ium&#x27;</span></span><br><span class="line"><span class="string">&#x27;unununium&#x27;</span></span><br></pre></td></tr></table></figure>

<p>相邻的两个或多个 <em>字符串字面值</em> （引号标注的字符）会自动合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;Py&#x27;</span> <span class="string">&#x27;thon&#x27;</span></span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br></pre></td></tr></table></figure>

<p>拆分长字符串时，这个功能特别实用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>text = (<span class="string">&#x27;Put several strings within parentheses &#x27;</span></span><br><span class="line"><span class="meta">... </span>        <span class="string">&#x27;to have them joined together.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>text</span><br><span class="line"><span class="string">&#x27;Put several strings within parentheses to have them joined together.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这项功能只能用于两个字面值，不能用于变量或表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix = <span class="string">&#x27;Py&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix <span class="string">&#x27;thon&#x27;</span>  <span class="comment"># can&#x27;t concatenate a variable and a string literal</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    prefix <span class="string">&#x27;thon&#x27;</span></span><br><span class="line">                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">&#x27;un&#x27;</span> * <span class="number">3</span>) <span class="string">&#x27;ium&#x27;</span></span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span></span><br><span class="line">    (<span class="string">&#x27;un&#x27;</span> * <span class="number">3</span>) <span class="string">&#x27;ium&#x27;</span></span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>合并多个变量，或合并变量与字面值，要用 <code>+</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>prefix + <span class="string">&#x27;thon&#x27;</span></span><br><span class="line"><span class="string">&#x27;Python&#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符串支持 <em>索引</em> （下标访问），第一个字符的索引是 0。单字符没有专用的类型，就是长度为一的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">0</span>]  <span class="comment"># character in position 0</span></span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[<span class="number">5</span>]  <span class="comment"># character in position 5</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>索引还支持负数，用负数索引时，从右边开始计数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">1</span>]  <span class="comment"># last character</span></span><br><span class="line"><span class="string">&#x27;n&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">2</span>]  <span class="comment"># second-last character</span></span><br><span class="line"><span class="string">&#x27;o&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>word[-<span class="number">6</span>]</span><br><span class="line"><span class="string">&#x27;P&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意，-0 和 0 一样，因此，负数索引从 -1 开始。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/Python%E6%95%99%E7%A8%8B%EF%BC%9APython%E7%94%A8%E4%BD%9C%E8%AE%A1%E7%AE%97%E5%99%A81.png" alt="Python教程：Python用作计算器1"></p>
<p>切片提取字符串是左闭右开的区间，<code>word[0:2]</code>左边包括<code>word[0]</code>右边不包括<code>word[2]</code>，因此取到的结果为Py。当省略左边时默认为0<code>word[:2]</code>,当省略右边时默认为到字符串结尾（也就是字符串长度6）<code>word[4:]</code>，也支持负数<code>word[-2:]</code>,输出结果为on，<code>word[-6:6]</code>输出结果为Python。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/Python%E6%95%99%E7%A8%8B%EF%BC%9APython%E7%94%A8%E4%BD%9C%E8%AE%A1%E7%AE%97%E5%99%A82.png" alt="Python教程：Python用作计算器2"></p>
<p>定义好的字符串不能修改，但是可以给该字符串加字符或字符串。</p>
<p><code>len()</code>函数可以求Python所有类型的长度。</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表可以理解为C++中的数组，与C++不同的是Python列表用中括号表示并且不用定义列表长度，C++数组用花括号表示并且要先定义数组长度。</p>
<p>列表中既可以有整数，也可以有浮点数，还可以有字符串，甚至可以嵌套：<code>a = [1, 2.0, &#39;yxc&#39;, [2, 3]]</code></p>
<p>列表的访问方式与字符串访问方式相同：<code>a[-1]</code>返回<code>[2, 3]</code>,<code>a[0]</code>返回<code>1</code></p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A81.png" alt="列表1"></p>
<h5 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h5><h6 id="浅拷贝知识点"><a href="#浅拷贝知识点" class="headerlink" title="浅拷贝知识点"></a><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/copy.html#shallow-vs-deep-copy">浅拷贝知识点</a></h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">y = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">a = [x, y] <span class="comment">#a是两个列表的列表</span></span><br><span class="line">b = a <span class="comment">#a和b相当于指针，它们指向的是同一个变量</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">a</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>, [<span class="number">3</span>, <span class="number">4</span>]] <span class="comment">#如果采用的是等号赋值，改变b的某一个元素，a也会随之改变，相反如果改变a，b也会随之改变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = a[:] <span class="comment">#此为浅拷贝，将a列表的第一层赋值给了b</span></span><br><span class="line">b[<span class="number">0</span>] = <span class="string">&quot;abc&quot;</span></span><br><span class="line">b</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]] <span class="comment">#可以理解为a[:]表示把a列表的一个复制品赋值给了b列表，该复制品a与原始的a的地址是不一样的,因此改变b的某一个元素不会影响到原始的a列表的元素</span></span><br><span class="line"></span><br><span class="line">b = a[:]</span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;abc&quot;</span></span><br><span class="line">a</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b</span><br><span class="line">[<span class="string">&#x27;abc&#x27;</span>, [<span class="number">3</span>, <span class="number">4</span>]] <span class="comment">#如果改变的是a中的某一个元素，因为a是原始的列表，并且b列表的内容取决于原始的a列表的内容，因此a列表中的元素改变，b也会随之改变</span></span><br></pre></td></tr></table></figure>

<p>浅层与深层复制的区别仅与复合对象（即包含列表或类的实例等其他对象的对象）相关：</p>
<p><em>浅层复制</em> 构造一个新的复合对象，然后（在尽可能的范围内）将原始对象中找到的对象的 <em>引用</em> 插入其中。</p>
<p><em>深层复制</em> 构造一个新的复合对象，然后，递归地将在原始对象里找到的对象的 <em>副本</em> 插入其中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">b = copy.deepcopy(a)</span><br><span class="line">a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line">a</span><br><span class="line">[[<span class="number">1</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">b</span><br><span class="line">[[<span class="number">1</span>, <span class="number">10</span>], [<span class="number">3</span>, <span class="number">4</span>]] <span class="comment">#深拷贝中，b不管怎么去操作，都不会改变a的值。</span></span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A82.png" alt="列表2"></p>
<p><code>append()</code>可以在列表结尾添加元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">x.append(<span class="number">6</span>)</span><br><span class="line">x</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">x += [<span class="number">7</span>]</span><br><span class="line">x</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] <span class="comment">#+=也可以在列表结尾添加元素</span></span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A83.png" alt="列表3"></p>
<h3 id="走向编程的第一步"><a href="#走向编程的第一步" class="headerlink" title="走向编程的第一步"></a>走向编程的第一步</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%B5%B0%E5%90%91%E7%BC%96%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A51.png" alt="走向编程的第一步1"></p>
<p>Python支持复合赋值方式，因此<code>a, b = 0, 1</code>表示<code>a = 0, b = 1</code></p>
<p>如果要交换两个变量的值，<code>a, b = b, a</code>即可</p>
<p>Python中所有循环判断（包括if和其他语句类型的判断语句）的后面都需要加’:’</p>
<p>与C++不同的是Python中循环判断（包括if和其他语句类型的判断语句）不用加括号，而且循环体也不需要加花括号，Python中通过缩进的方式来判断循环体。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%B5%B0%E5%90%91%E7%BC%96%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A52.png" alt="走向编程的第一步2"></p>
<p><strong>Python中没有<code>i ++ </code>操作，可以通过<code>i += 1</code>实现。</strong></p>
<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/if%E8%AF%AD%E5%8F%A5.png" alt="if语句"></p>
<p>上图中的int是一个函数，不是整数类型。match语句相当于switch语句。</p>
<p>Python中有与C++相似的问号表达式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span></span><br><span class="line">y = <span class="string">&quot;zero&quot;</span> <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;noy zero&quot;</span> </span><br><span class="line">y</span><br><span class="line"><span class="string">&#x27;zero&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/for%E8%AF%AD%E5%8F%A5.png" alt="for语句"></p>
<p>Python中for循环的循环次数是无法自己定义的（C++中可以<code>for (int i = 0; i &lt; n; i ++ )</code>,Python中的for循环只能用来遍历列表或字符串）。</p>
<p>上图中<code>users = &#123;&#39;Hans&#39;: &#39;active&#39;, &#39;Éléonore&#39;: &#39;inactive&#39;, &#39;景太郎&#39;: &#39;active&#39;&#125;</code>中的<code>&#39;Hans&#39;: &#39;active&#39;</code>这类元素，相当于C++中的map，也就是说把<code>&#39;hans&#39;映射到&#39;active&#39;</code>,此时执行<code>print(user[&#39;Hans&#39;])</code>输出的结果为<code>active</code>。注意users中的花括号，它代表一个集合，因此映射在集合中才可定义。</p>
<h4 id="items"><a href="#items" class="headerlink" title="items()"></a>items()</h4><p><code>items()</code>函数会将如上述所示的集合以列表的形式呈现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">users.items()</span><br><span class="line">dict_items([(<span class="string">&#x27;Hans&#x27;</span>, <span class="string">&#x27;active&#x27;</span>), (<span class="string">&#x27;Éléonore&#x27;</span>, <span class="string">&#x27;inactive&#x27;</span>), (<span class="string">&#x27;景太郎&#x27;</span>, <span class="string">&#x27;active&#x27;</span>)]) <span class="comment">#(&#x27;Hans&#x27;, &#x27;active&#x27;)为一对key value对，是列表中的一个元素，该列表总共有三个元素</span></span><br></pre></td></tr></table></figure>

<p>Python中是可以二元遍历的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> users.items(): <span class="comment">#此为二元遍历的，items（）列表中的每一个元素是两个元素，两个元素分别赋给key和value（第一个元素赋给key，第二个元素赋给value）</span></span><br><span class="line">    <span class="built_in">print</span>(key, value)</span><br><span class="line">    </span><br><span class="line">Hans active</span><br><span class="line">Éléonore inactive</span><br><span class="line">景太郎 active <span class="comment">#按照key value的方式输出</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> user, status <span class="keyword">in</span> users.copy().items(): <span class="comment">#users.copy().items()为users的复制品</span></span><br><span class="line">    <span class="keyword">if</span> status == <span class="string">&#x27;inactive&#x27;</span>:</span><br><span class="line">        <span class="keyword">del</span> users[user] <span class="comment"># del为删除操作</span></span><br><span class="line">users</span><br><span class="line">&#123;<span class="string">&#x27;Hans&#x27;</span>: <span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;景太郎&#x27;</span>: <span class="string">&#x27;active&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/range%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B01.png" alt="range（）函数1"></p>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a><code>range()</code>函数</h3><p><code>range()</code>函数会返回一个左闭右开的区间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ,<span class="number">4</span> , <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>] <span class="comment">#左闭右开，不包括10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>): <span class="comment">#也可以用for循环输出</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">9</span>, -<span class="number">1</span>, -<span class="number">1</span>)) <span class="comment">#实现9到0的倒序，最后一个数-1表示公差,输出倒叙不能简写，公差必须要加</span></span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>)) <span class="comment">#range（）中的参数为一个时默认为从0到9</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/range%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B02.png" alt="range（）函数2"></p>
<h3 id="循环中的break、continue语句及else子句"><a href="#循环中的break、continue语句及else子句" class="headerlink" title="循环中的break、continue语句及else子句"></a>循环中的break、continue语句及else子句</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84break%E3%80%81continue%E8%AF%AD%E5%8F%A5%E5%8F%8Aelse%E5%AD%90%E5%8F%A51.png" alt="循环中的break、continue语句及else子句1"></p>
<p>如上图代码，如果break没有被执行，当<code>for x in range(2, n):</code>循环结束后就会执行接下来的else中的内容，如果break被执行，则不会执行else中的内容（与其他类型的循环同理）。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84break%E3%80%81continue%E8%AF%AD%E5%8F%A5%E5%8F%8Aelse%E5%AD%90%E5%8F%A52.png" alt="循环中的break、continue语句及else子句2"></p>
<p>continue与C++用法一样。</p>
<p><strong>while语句见if语句的上一章内容。</strong></p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/pass%E8%AF%AD%E5%8F%A5.png" alt="pass语句"></p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B01.png" alt="定义函数1"></p>
<p><code>def f(a, b):</code>def为定义函数关键字，定义函数后也要加’:’。Python中的None与C++中的NULL类似。 </p>
<p><strong>Python中函数参数的传递方式属于引用，函数内如果传的是数组，改变数组的内容函数外与之对应的数组也会随之改变，如果传递的是变量，则不会影响函数外的值。</strong></p>
<p>定义函数中的参数不需要定义参数的类型，Python会自己判断参数的类型。可以给函数中的参数设置默认值，但设置默认值必须是连续的，从哪个参数开始设置默认值，该参数的后面都要设置默认值。</p>
<p>如果定义重名函数，会将前面的函数覆盖掉。</p>
<p>调用函数时可以采用什么等于什么的形式赋值,而且不用考虑参数的顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c, d</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c, d)</span><br><span class="line">    </span><br><span class="line">f(a = <span class="number">2</span>, b = <span class="number">3</span>, c = <span class="number">4</span>, d = <span class="number">5</span>)</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">f(b = <span class="number">3</span>, a = <span class="number">2</span>, d = <span class="number">5</span>, c = <span class="number">4</span>) <span class="comment">#打乱参数的顺序  一号代码</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">g = f <span class="comment">#函数可以直接赋值</span></span><br><span class="line">g(b = <span class="number">3</span>, a = <span class="number">2</span>, c = <span class="number">4</span>, d = <span class="number">5</span>)</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="comment">#可以把数组中的值当作参数传递给函数</span></span><br><span class="line">f(*a) <span class="comment">#*不是指针，是解包操作，将数组a展开成四个逗号隔开的变量放入函数当作参数调用</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">a = &#123; <span class="comment">#如果a是一个字典，那么解包操作用**执行,并且可以像一号代码那样打乱参数顺序的赋值</span></span><br><span class="line">    <span class="string">&#x27;b&#x27;</span> : <span class="number">3</span>, <span class="comment">#注意字典中的&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;字符要和函数中定义的参数名一致</span></span><br><span class="line">    <span class="string">&#x27;a&#x27;</span> : <span class="number">2</span>,</span><br><span class="line">    <span class="string">&#x27;d&#x27;</span> : <span class="number">5</span>,</span><br><span class="line">    <span class="string">&#x27;c&#x27;</span> : <span class="number">4</span></span><br><span class="line">&#125; <span class="comment">#此为key value形式的赋值，在Django中比较常用</span></span><br><span class="line">f(**a)</span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="comment">#如果通过数组或字典的方式作为函数参数进行赋值，数组或字典的元素的个数要与函数参数的个数相同</span></span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B02.png" alt="定义函数2"></p>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="Lambda表达式"></p>
<p>Lambda用于创建匿名函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">g = <span class="keyword">lambda</span> x, y: x + y <span class="comment">#创建匿名函数，`x, y : x + y`表示返回两个参数的和</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line">g(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A31.png" alt="列表详解1"></p>
<h4 id="append"><a href="#append" class="headerlink" title="append()"></a><code>append()</code></h4><p>可以添加任意类型的元素。</p>
<h4 id="len"><a href="#len" class="headerlink" title="len()"></a>len()</h4><p>求列表的长度。</p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A8%E8%AF%A6%E8%A7%A32.png" alt="列表详解2"></p>
<h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F%201.png" alt="列表推导式 1"></p>
<p>通过列表推导式将0到9的平方放入数组中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = [i * i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)] <span class="comment">#列表推导式，i * i表示放入数组的值，for后面的i表示传递的值，range(10)表示i的值为0到9</span></span><br><span class="line">b</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">a = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">     [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], </span><br><span class="line">     [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">    ] <span class="comment">#相当于二维数组</span></span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F2.png" alt="列表推导式2"></p>
<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F3.png" alt="列表推导式3"></p>
<h3 id="元组和序列"><a href="#元组和序列" class="headerlink" title="元组和序列"></a>元组和序列</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%85%83%E7%BB%84%E5%92%8C%E5%BA%8F%E5%88%971.png" alt="元组和序列1"></p>
<p>元组与列表的区别是列表中的元素可以修改，而元组不可以（不可以修改、删除和添加），元组用小括号表示，列表用中括号表示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">b = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">#定义元组</span></span><br><span class="line">b[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span> <span class="comment">#可以取值</span></span><br><span class="line"><span class="comment">#b[1] = 2    但不能修改</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> <span class="comment">#可以去掉小括号定义元组</span></span><br><span class="line">b</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>(b)</span><br><span class="line"><span class="number">3</span> <span class="comment">#元组也可以求长度</span></span><br><span class="line"></span><br><span class="line">x, y, z = b <span class="comment">#元组可以赋给一个变量，该赋值形式列表也适用</span></span><br><span class="line">x</span><br><span class="line"><span class="number">1</span></span><br><span class="line">y</span><br><span class="line"><span class="number">2</span></span><br><span class="line">z</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>] <span class="comment">#列表也适用</span></span><br><span class="line">x, y, z = a</span><br><span class="line">x</span><br><span class="line"><span class="number">1</span></span><br><span class="line">y</span><br><span class="line"><span class="number">4</span></span><br><span class="line">z</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="split-函数"><a href="#split-函数" class="headerlink" title="split()函数"></a><code>split()</code>函数</h4><p><code>split()</code>函数将某个字符串以某个字符分割成两个列表，被分割的字符不会在分割后的列表中出现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;123 321&quot;</span></span><br><span class="line">s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">[<span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;321&#x27;</span>]</span><br><span class="line"></span><br><span class="line">a, b = <span class="string">&quot;123 321&quot;</span>.split(<span class="string">&#x27; &#x27;</span>) <span class="comment">#可以直接将分割到的字符串赋值给变量</span></span><br><span class="line">a</span><br><span class="line"><span class="string">&#x27;123&#x27;</span></span><br><span class="line">b</span><br><span class="line"><span class="string">&#x27;321&#x27;</span>=</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%85%83%E7%BB%84%E5%92%8C%E5%BA%8F%E5%88%972.png" alt="元组和序列2"></p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E9%9B%86%E5%90%88%20.png" alt="集合 "></p>
<p><strong>创建集合用花括号或 <code>set()</code> 函数。注意，创建空集合只能用 <code>set()</code>，不能用 <code>&#123;&#125;</code>，<code>&#123;&#125;</code> 创建的是空字典。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">set</span>() <span class="comment">#定义集合</span></span><br><span class="line">a.add(<span class="number">1</span>) <span class="comment">#集合中添加元素</span></span><br><span class="line">a</span><br><span class="line">&#123;<span class="number">1</span>&#125;</span><br><span class="line">a.add(<span class="number">2</span>)</span><br><span class="line">a</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">a.add(<span class="number">2</span>)</span><br><span class="line">a</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>&#125; <span class="comment">#加入相同元素是不会加的，相同元素只保留一份</span></span><br><span class="line"></span><br><span class="line">a = &#123;&#125; <span class="comment">#a既表示集合又表示字典，a是字典还是集合取决于之后存入的内容是key value对（字典）还是单值（集合）</span></span><br></pre></td></tr></table></figure>

<p>字典对应C++中的<code>map</code>,集合对应C++中的<code>set</code>。</p>
<p>集合一般用于对数组做判重：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">set</span>(a)</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; <span class="comment">#判重后的结果，但a内容依旧是[1, 3, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">set</span>(a))</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">#判重结果，并且改变了a的内容</span></span><br></pre></td></tr></table></figure>

<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%AD%97%E5%85%B81.png" alt="字典1"></p>
<p>字典就是由多个key value对组成的集合，字典的内容是可以修改的。<code>type()</code>可以求变量的类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br><span class="line">tel[<span class="string">&#x27;jack&#x27;</span>] = <span class="number">8888</span> <span class="comment">#修改字典tel中的内容</span></span><br><span class="line">tel</span><br><span class="line">&#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">8888</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted()"></a><code>sorted()</code></h4><p><code>sorted()</code>对列表进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">sorted</span>(a) <span class="comment">#对列表a排序，但不能修改列表a的内容</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">sorted</span>(a) <span class="comment">#可使用此方式修改a</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%AD%97%E5%85%B82.png" alt="字典2"></p>
<h3 id="循环的技巧"><a href="#循环的技巧" class="headerlink" title="循环的技巧"></a>循环的技巧</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%8A%80%E5%B7%A71.png" alt="循环的技巧1"></p>
<h4 id="zip-函数"><a href="#zip-函数" class="headerlink" title="zip()函数"></a><code>zip()</code>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(a, b):</span><br><span class="line">    <span class="built_in">print</span>(x, y)</span><br><span class="line">    </span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%8A%80%E5%B7%A72.png" alt="循环的技巧2"></p>
<h4 id="reversed-翻转函数"><a href="#reversed-翻转函数" class="headerlink" title="reversed()翻转函数"></a><code>reversed()</code>翻转函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">list</span>(<span class="built_in">reversed</span>(a))</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">reversed</span>(a))</span><br><span class="line">a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a.reverse() <span class="comment">#也可以用reverse（）来翻转</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a.sort() <span class="comment">#a.sort()对a排序</span></span><br><span class="line">a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%8A%80%E5%B7%A73.png" alt="循环的技巧3"></p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%A8%A1%E5%9D%971.png" alt="模块1"></p>
<p>建立文件夹<code>python_lesson</code>，在该文件夹中建立两个文件夹<code>model_1 model_2</code>，再在<code>model_1</code>中建立文件<code>model_a.py</code>，该文件中的内容为Python代码(求斐波那契数列fib()和fib2())，打开<code>ipython3</code>进入编译器在编译器中输入如下内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> python_lesson.model_1 <span class="keyword">import</span> model_a</span><br><span class="line"></span><br><span class="line">model_a.fib(<span class="number">10</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line">model_a.fib2(<span class="number">10</span>)</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_lesson.model_1.model_a <span class="keyword">import</span> fib, fib2 <span class="comment">#也可以直接import函数名</span></span><br><span class="line">fib(<span class="number">1</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> python_lesson.model_1.model_a <span class="keyword">import</span> fib <span class="keyword">as</span> fib3, fib2 <span class="comment">#也可以对函数名进行修改，防止同名函数发生冲突</span></span><br><span class="line">fib3(<span class="number">10</span>) <span class="comment">#将fib改名为fib3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%A8%A1%E5%9D%972.png" alt="模块2"></p>
<p>Python中已经帮我们实现了许多模块，如果在写代码时需要相关模块可直接运用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint <span class="comment">#randint会随机的求两个数之间的一个随机数</span></span><br><span class="line">randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">8</span></span><br><span class="line">randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E6%97%A7%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%96%B9%E6%B3%95.png" alt="旧式字符串格式化方法"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;%04d %.2lf %s&quot;</span> % (<span class="number">2</span>, <span class="number">3.4</span>, <span class="string">&quot;abc&quot;</span>) <span class="comment">#相当于C++中的printf(&quot;%04d %.2lf %s&quot;, 2, 3.4, &quot;abc&quot;);</span></span><br><span class="line">s</span><br><span class="line"><span class="string">&#x27;0002 3.40 abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B61.png" alt="读写文件1"></p>
<p>Python可以读写文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">fout = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="comment">#创建test.txt文件，fout是自定义名称，&#x27;w&#x27;表示写文件</span></span><br><span class="line">fout.write(<span class="string">&quot;111\n&quot;</span>) <span class="comment">#将字符串&quot;111&quot;写入文件中，写入文件的内容一定是以字符串的形式写入</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    fout.write(<span class="built_in">str</span>(i) + <span class="string">&#x27;\n&#x27;</span>) <span class="comment">#写入的i是数字，因此要用str()函数将数字转换为字符串（因为写入文件的内容都是字符串） </span></span><br><span class="line">fout.close() <span class="comment">#写完之后一定要关闭文件，这样才会将缓存写入文件中</span></span><br><span class="line">ls</span><br><span class="line">python_lesson/   test.txt <span class="comment">#此时在本地多出来test.txt文件（ls可以在ipython3编译器中查询本地文件），而且Python中可以执行shell命令</span></span><br><span class="line"></span><br><span class="line">! cat test.txt <span class="comment"># cat teste.txt也可以执行显示相同结果</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span> <span class="comment">#已将全部内容写入文件</span></span><br><span class="line"></span><br><span class="line">! echo <span class="string">&quot;!!!&quot;</span> <span class="comment">#echo不是shell命令，在其前面加！就可以执行</span></span><br><span class="line">!!!</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fout: <span class="comment">#一般用此方式写入文件，with可以防止内存泄漏和数据丢失的问题（程序异常退出的情况下，而上述写入文件的方式在程序异常退出的情况下会导致内存泄漏和数据丢失的问题发生，因为在写入文件的时候突然发生异常退出，由于没有执行close()操作，会导致写入文件失败，而with不会让此类问题发生）</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        fout.write(<span class="built_in">str</span>(i) + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="comment">#不需要执行close()操作    </span></span><br><span class="line">cat test.txt</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fout.write(&quot;1&quot;) 此时执行该命令会报错，因为文件已经关闭</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fin: <span class="comment">#读取文件，&#x27;r&#x27;表示读文件，fin为自定义名称</span></span><br><span class="line">    <span class="built_in">print</span>(fin.read()) <span class="comment">#读取整个文件的所有内容</span></span><br><span class="line">    </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span>  <span class="comment">#将test.txt文件中的内容读取出来</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    <span class="built_in">print</span>(fin.readlines()) <span class="comment">#也可以读出所有行</span></span><br><span class="line">    </span><br><span class="line">[<span class="string">&#x27;0\n&#x27;</span>, <span class="string">&#x27;1\n&#x27;</span>, <span class="string">&#x27;2\n&#x27;</span>, <span class="string">&#x27;3\n&#x27;</span>, <span class="string">&#x27;4\n&#x27;</span>, <span class="string">&#x27;5\n&#x27;</span>, <span class="string">&#x27;6\n&#x27;</span>, <span class="string">&#x27;7\n&#x27;</span>, <span class="string">&#x27;8\n&#x27;</span>, <span class="string">&#x27;9\n&#x27;</span>] <span class="comment">#返回的内容为列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fin: <span class="comment">#逐行读取文件内容</span></span><br><span class="line">        <span class="built_in">print</span>(line, end=<span class="string">&#x27;&#x27;</span>) <span class="comment">#由于每一行内容都有回车，因此不需要在输出回车，用end取消回车</span></span><br><span class="line">        </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B62.png" alt="读写文件2"></p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png" alt="异常处理"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#try关键字表示尝试执行这一代码块的内容</span></span><br><span class="line">        res = x / y</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: <span class="comment">#如果遇到了异常，执行下面的代码</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line">        </span><br><span class="line">divide(<span class="number">1</span>, <span class="number">0</span>) <span class="comment">#尝试执行1/0的操作</span></span><br><span class="line">division by zero <span class="comment">#1/0发生异常，执行print(str(e))语句，程序不报错，程序还会继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1/0     如果直接执行，程序会报错并且立即结束程序</span></span><br><span class="line">divide(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">#1/1没有问题，不会执行异常代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#try关键字表示尝试执行这一代码块的内容</span></span><br><span class="line">        res = x / y</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: <span class="comment">#如果遇到了异常，执行下面的代码</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果没有发生异常，执行该语句</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;result is&quot;</span>, res)</span><br><span class="line">        </span><br><span class="line">divide(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">result <span class="keyword">is</span> <span class="number">1.0</span> <span class="comment">#1/1没有发生异常，输出该语句</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">try</span>: <span class="comment">#try关键字表示尝试执行这一代码块的内容</span></span><br><span class="line">        res = x / y</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e: <span class="comment">#如果遇到了异常，执行下面的代码</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(e))</span><br><span class="line">    <span class="keyword">else</span>: <span class="comment">#如果没有发生异常，执行该语句</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;result is&quot;</span>, res)</span><br><span class="line">    <span class="keyword">finally</span>: <span class="comment">#不管有没有发生异常，都会执行下面的语句</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;executing finally clause&quot;</span>)</span><br><span class="line">        </span><br><span class="line">divide(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">result <span class="keyword">is</span> <span class="number">1.0</span></span><br><span class="line">executing <span class="keyword">finally</span> clause</span><br><span class="line"></span><br><span class="line">divide(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">division by zero</span><br><span class="line">excuting <span class="keyword">finally</span> clause</span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h4><p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/Class%E5%AF%B9%E8%B1%A11.png" alt="Class对象1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>: <span class="comment">#定义Car类</span></span><br><span class="line">    static_a = [] <span class="comment">#定义数组，静态变量</span></span><br><span class="line">    </span><br><span class="line">a = Car() <span class="comment">#初始化对象a</span></span><br><span class="line">b = Car() <span class="comment">#初始化对象b</span></span><br><span class="line">a.static_a.append(<span class="number">1</span>)</span><br><span class="line">b.static_a.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">a.static_a <span class="comment">#static_a数组为静态变量，所有对象使用的静态变量共用这一个变量（指静态变量），因此对对象a使用的静态变量操作后，对象b与之相同的静态变量也会相应的改变，所以对a对象的数组加1，再对b对象数组加1，其实操作的是同一数组，并且结果为[1, 1]</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">b.static_a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment">#相当于C++的构造函数,此函数中一定要加self参数,在创造类的时候默认执行此函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;created!!&quot;</span>)</span><br><span class="line">        self.a = [] <span class="comment">#Python类中创建成员变量是在函数体内创建的,用self定义的变量属于独有的变量，不再是所有对象共用的静态变量</span></span><br><span class="line">        </span><br><span class="line">a = Car()</span><br><span class="line">created!! <span class="comment">#每当给对象分配变量时，就会执行此语句，因为__init__(self)为默认执行的函数</span></span><br><span class="line">b = Car()</span><br><span class="line">created!!</span><br><span class="line"></span><br><span class="line">a.a</span><br><span class="line">[] <span class="comment">#访问对象a中的成员变量</span></span><br><span class="line"></span><br><span class="line">a.a.append(<span class="number">1</span>) <span class="comment">#此时的数组a属于独有变量，一个对象使用一个变量，不再是多个对象共用同一个变量</span></span><br><span class="line">b.a.append(<span class="number">2</span>)</span><br><span class="line">a.a</span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line">b.a</span><br><span class="line">[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment">#相当于C++的构造函数,此函数中一定要加self参数,在创造类的时候默认执行此函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;created!!&quot;</span>)</span><br><span class="line">        self.a = [] <span class="comment">#Python类中创建成员变量是在函数体内创建的,用self定义的变量属于独有的变量，不再是所有对象共用的静态变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>): <span class="comment">#定义成员函数，所有的成员内部函数都要加self参数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.a)): <span class="comment">#将a数组中所有元素乘2，注意len()中是self.a不是a,self相当于JAVA中的this关键字，因此这里就好理解为什么是self.a了</span></span><br><span class="line">            self.a[i] *= <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">a = Car()</span><br><span class="line">created!!</span><br><span class="line">a.a += [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">#加入一段数组</span></span><br><span class="line">a.a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">a.update() <span class="comment">#对数组a中的元素分别乘2</span></span><br><span class="line">a.a</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>): <span class="comment">#构造函数也可以传入参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;created!!&quot;</span>)</span><br><span class="line">        self.a = [x, y] <span class="comment">#Python类中创建成员变量是在函数体内创建的,用self定义的变量属于独有的变量，不再是所有对象共用的静态变量</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>): <span class="comment">#定义成员函数，所有的成员内部函数都要加self参数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.a)): <span class="comment">#将a数组中所有元素乘2，注意len()中是self.a不是a,self相当于JAVA中的this关键字，因此这里就好理解为什么是self.a了</span></span><br><span class="line">            self.a[i] *= <span class="number">2</span></span><br><span class="line">            </span><br><span class="line">a = Car(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">created!!</span><br><span class="line">a.a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">a = Car(y=<span class="number">1</span>, x=<span class="number">2</span>) <span class="comment">#也可以通过此方式对数组传入元素</span></span><br><span class="line">a.a</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">#也可以通过解包的方式传入数组元素</span></span><br><span class="line">a = Car(*a)</span><br><span class="line">created!!</span><br><span class="line">a.a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="comment">#函数中的各种赋值方式在类中的函数同样适用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">Car</span>): <span class="comment">#继承Car类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;create tool!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">t = Tool()</span><br><span class="line">create tool!</span><br><span class="line"><span class="comment">#t.a    对象t无法访问基类（父类）的a数组，如果要访问必要在子类中显式的调用基类的构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">Car</span>): <span class="comment">#继承Car类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;create tool!&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">#显式的调用基类__init__()函数</span></span><br><span class="line">        </span><br><span class="line">t = Tool()</span><br><span class="line">create tool!</span><br><span class="line">created!! <span class="comment">#此时就可以访问基类中的对应的构造函数中的变量了</span></span><br><span class="line"></span><br><span class="line">t.a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/lhfeiie/img/main/img/Class%E5%AF%B9%E8%B1%A12.png" alt="Class对象2"></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2023/02/13/Django%E6%A1%86%E6%9E%B6%E8%AF%BE/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2023 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>